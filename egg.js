const __vite__mapDeps = (i, m = __vite__mapDeps, d = (m.f || (m.f = ["./j9-6koyx.js", "./C2bHYaEW.js", "./Vs5g2V0M.js", "./C3LaVv3x.js", "./BWRk4KA7.js", "./Cc5bCCTa.js", "./B__l47Li.js", "./DLkoZ6XF.js", "./DftQuqgp.js", "./BZYALdbj.js", "./BHXsll7X.js", "./DyO8JOHR.js", "./Dv_9kyEv.js", "./wSbNHcIL.js", "./575nGSK0.js", "./D0-o2vGv.js", "./Bw3nkGR1.js", "./index.DQAZReds.css", "./waQEoPDL.js", "./BrmFu2QI.js", "./BRq0JzQT.js", "./1a9gFDL4.js", "./udqLDpql.js", "./CqXk2UYb.js", "./Ci2I3G-0.js", "./D1tBAnAm.js", "./DEwcJRw7.js", "./C3fPimzh.js", "./DvCqd2SC.js", "./Dh9R9qtd.js", "./DXTlbuNJ.js", "./BlmDa_Bk.js", "./DLHDsG_2.js", "./DtMzF6Ps.js", "./ncxNjMGg.js", "./cskS5pPq.js", "./_py3v4u-.js", "./zhJYu0IU.js", "./3LRt3p_w.js", "./C6rfD890.js", "./2tfsRbNX.js", "./DPO_4luh.js", "./CUiw9G5T.js", "./aZ4Y0Lae.js", "./f8YF1zu8.js", "./BpiZdSC7.js", "./g1R2rD7M.js", "./zgP0N6he.js", "./Dq1RDenS.js", "./iD0nA9sm.js", "./BiypBkFv.js", "./C-5-m7rD.js", "./BZMBIxbL.js", "./DnQDlVPo.js", "./CdpTe8-F.js", "./Cgbf1oAS.js", "./vblv4vQm.js", "./Bvor1FgC.js", "./RWJD3NuS.js", "./GQQZIvEN.js", "./Pre.DfwtKMBh.css", "./UXufbzxE.js", "./UMSFwOrz.js", "./Dv1X7N87.js", "./BzgfWQNs.js", "./0e6i6oB-.js", "./CbfeJvhz.js", "./D91nHZiB.js", "./Brnk9azS.js", "./DUsHpl6e.js", "./DTfug1Wx.js", "./D9YW5nRf.js", "./znhT23nw.js", "./P_1yuZuv.js", "./BcocdFyD.js", "./BzjYKYyZ.js", "./error-404.D4dDLP34.css", "./CrPR4iX1.js", "./error-500.BmXP2UI5.css"]))) => i.map(i => d[i]);
var xf = Object.defineProperty; var Tf = (e, t, n) => t in e ? xf(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n; var Dt = (e, t, n) => Tf(e, typeof t != "symbol" ? t + "" : t, n); (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const o of document.querySelectorAll('link[rel="modulepreload"]')) s(o); new MutationObserver(o => { for (const r of o) if (r.type === "childList") for (const i of r.addedNodes) i.tagName === "LINK" && i.rel === "modulepreload" && s(i) }).observe(document, { childList: !0, subtree: !0 }); function n(o) { const r = {}; return o.integrity && (r.integrity = o.integrity), o.referrerPolicy && (r.referrerPolicy = o.referrerPolicy), o.crossOrigin === "use-credentials" ? r.credentials = "include" : o.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r } function s(o) { if (o.ep) return; o.ep = !0; const r = n(o); fetch(o.href, r) } })();/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function ko(e) { const t = Object.create(null); for (const n of e.split(",")) t[n] = 1; return n => n in t } const oe = {}, wn = [], tt = () => { }, Pf = () => !1, ms = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), Xr = e => e.startsWith("onUpdate:"), pe = Object.assign, Zr = (e, t) => { const n = e.indexOf(t); n > -1 && e.splice(n, 1) }, Sf = Object.prototype.hasOwnProperty, le = (e, t) => Sf.call(e, t), z = Array.isArray, En = e => Hn(e) === "[object Map]", fn = e => Hn(e) === "[object Set]", Hi = e => Hn(e) === "[object Date]", Cf = e => Hn(e) === "[object RegExp]", ee = e => typeof e == "function", _e = e => typeof e == "string", lt = e => typeof e == "symbol", de = e => e !== null && typeof e == "object", ei = e => (de(e) || ee(e)) && ee(e.then) && ee(e.catch), Tc = Object.prototype.toString, Hn = e => Tc.call(e), Rf = e => Hn(e).slice(8, -1), xo = e => Hn(e) === "[object Object]", ti = e => _e(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, kn = ko(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), To = e => { const t = Object.create(null); return n => t[n] || (t[n] = e(n)) }, Af = /-(\w)/g, Le = To(e => e.replace(Af, (t, n) => n ? n.toUpperCase() : "")), If = /\B([A-Z])/g, We = To(e => e.replace(If, "-$1").toLowerCase()), Po = To(e => e.charAt(0).toUpperCase() + e.slice(1)), js = To(e => e ? `on${Po(e)}` : ""), He = (e, t) => !Object.is(e, t), xn = (e, ...t) => { for (let n = 0; n < e.length; n++)e[n](...t) }, dr = (e, t, n, s = !1) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, writable: s, value: n }) }, Qs = e => { const t = parseFloat(e); return isNaN(t) ? e : t }, Js = e => { const t = _e(e) ? Number(e) : NaN; return isNaN(t) ? e : t }; let Di; const So = () => Di || (Di = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}), Of = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol", Mf = ko(Of); function Co(e) { if (z(e)) { const t = {}; for (let n = 0; n < e.length; n++) { const s = e[n], o = _e(s) ? Df(s) : Co(s); if (o) for (const r in o) t[r] = o[r] } return t } else if (_e(e) || de(e)) return e } const Lf = /;(?![^(]*\))/g, Nf = /:([^]+)/, Hf = /\/\*[^]*?\*\//g; function Df(e) { const t = {}; return e.replace(Hf, "").split(Lf).forEach(n => { if (n) { const s = n.split(Nf); s.length > 1 && (t[s[0].trim()] = s[1].trim()) } }), t } function ys(e) { let t = ""; if (_e(e)) t = e; else if (z(e)) for (let n = 0; n < e.length; n++) { const s = ys(e[n]); s && (t += s + " ") } else if (de(e)) for (const n in e) e[n] && (t += n + " "); return t.trim() } function Ff(e) { if (!e) return null; let { class: t, style: n } = e; return t && !_e(t) && (e.class = ys(t)), n && (e.style = Co(n)), e } const $f = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", jf = ko($f); function Pc(e) { return !!e || e === "" } function Uf(e, t) { if (e.length !== t.length) return !1; let n = !0; for (let s = 0; n && s < e.length; s++)n = zt(e[s], t[s]); return n } function zt(e, t) { if (e === t) return !0; let n = Hi(e), s = Hi(t); if (n || s) return n && s ? e.getTime() === t.getTime() : !1; if (n = lt(e), s = lt(t), n || s) return e === t; if (n = z(e), s = z(t), n || s) return n && s ? Uf(e, t) : !1; if (n = de(e), s = de(t), n || s) { if (!n || !s) return !1; const o = Object.keys(e).length, r = Object.keys(t).length; if (o !== r) return !1; for (const i in e) { const a = e.hasOwnProperty(i), c = t.hasOwnProperty(i); if (a && !c || !a && c || !zt(e[i], t[i])) return !1 } } return String(e) === String(t) } function Ro(e, t) { return e.findIndex(n => zt(n, t)) } const Sc = e => !!(e && e.__v_isRef === !0), Vf = e => _e(e) ? e : e == null ? "" : z(e) || de(e) && (e.toString === Tc || !ee(e.toString)) ? Sc(e) ? Vf(e.value) : JSON.stringify(e, Cc, 2) : String(e), Cc = (e, t) => Sc(t) ? Cc(e, t.value) : En(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((n, [s, o], r) => (n[Ko(s, r) + " =>"] = o, n), {}) } : fn(t) ? { [`Set(${t.size})`]: [...t.values()].map(n => Ko(n)) } : lt(t) ? Ko(t) : de(t) && !z(t) && !xo(t) ? String(t) : t, Ko = (e, t = "") => { var n; return lt(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e };/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let Ie; class Rc { constructor(t = !1) { this.detached = t, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Ie, !t && Ie && (this.index = (Ie.scopes || (Ie.scopes = [])).push(this) - 1) } get active() { return this._active } pause() { if (this._active) { this._isPaused = !0; let t, n; if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++)this.scopes[t].pause(); for (t = 0, n = this.effects.length; t < n; t++)this.effects[t].pause() } } resume() { if (this._active && this._isPaused) { this._isPaused = !1; let t, n; if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++)this.scopes[t].resume(); for (t = 0, n = this.effects.length; t < n; t++)this.effects[t].resume() } } run(t) { if (this._active) { const n = Ie; try { return Ie = this, t() } finally { Ie = n } } } on() { ++this._on === 1 && (this.prevScope = Ie, Ie = this) } off() { this._on > 0 && --this._on === 0 && (Ie = this.prevScope, this.prevScope = void 0) } stop(t) { if (this._active) { this._active = !1; let n, s; for (n = 0, s = this.effects.length; n < s; n++)this.effects[n].stop(); for (this.effects.length = 0, n = 0, s = this.cleanups.length; n < s; n++)this.cleanups[n](); if (this.cleanups.length = 0, this.scopes) { for (n = 0, s = this.scopes.length; n < s; n++)this.scopes[n].stop(!0); this.scopes.length = 0 } if (!this.detached && this.parent && !t) { const o = this.parent.scopes.pop(); o && o !== this && (this.parent.scopes[this.index] = o, o.index = this.index) } this.parent = void 0 } } } function Bf(e) { return new Rc(e) } function Ac() { return Ie } function ov(e, t = !1) { Ie && Ie.cleanups.push(e) } let ye; const zo = new WeakSet; class Xs { constructor(t) { this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Ie && Ie.active && Ie.effects.push(this) } pause() { this.flags |= 64 } resume() { this.flags & 64 && (this.flags &= -65, zo.has(this) && (zo.delete(this), this.trigger())) } notify() { this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Oc(this) } run() { if (!(this.flags & 1)) return this.fn(); this.flags |= 2, Fi(this), Mc(this); const t = ye, n = ct; ye = this, ct = !0; try { return this.fn() } finally { Lc(this), ye = t, ct = n, this.flags &= -3 } } stop() { if (this.flags & 1) { for (let t = this.deps; t; t = t.nextDep)oi(t); this.deps = this.depsTail = void 0, Fi(this), this.onStop && this.onStop(), this.flags &= -2 } } trigger() { this.flags & 64 ? zo.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty() } runIfDirty() { pr(this) && this.run() } get dirty() { return pr(this) } } let Ic = 0, Yn, Qn; function Oc(e, t = !1) { if (e.flags |= 8, t) { e.next = Qn, Qn = e; return } e.next = Yn, Yn = e } function ni() { Ic++ } function si() { if (--Ic > 0) return; if (Qn) { let t = Qn; for (Qn = void 0; t;) { const n = t.next; t.next = void 0, t.flags &= -9, t = n } } let e; for (; Yn;) { let t = Yn; for (Yn = void 0; t;) { const n = t.next; if (t.next = void 0, t.flags &= -9, t.flags & 1) try { t.trigger() } catch (s) { e || (e = s) } t = n } } if (e) throw e } function Mc(e) { for (let t = e.deps; t; t = t.nextDep)t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t } function Lc(e) { let t, n = e.depsTail, s = n; for (; s;) { const o = s.prevDep; s.version === -1 ? (s === n && (n = o), oi(s), Wf(s)) : t = s, s.dep.activeLink = s.prevActiveLink, s.prevActiveLink = void 0, s = o } e.deps = t, e.depsTail = n } function pr(e) { for (let t = e.deps; t; t = t.nextDep)if (t.dep.version !== t.version || t.dep.computed && (Nc(t.dep.computed) || t.dep.version !== t.version)) return !0; return !!e._dirty } function Nc(e) { if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === os) || (e.globalVersion = os, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !pr(e)))) return; e.flags |= 2; const t = e.dep, n = ye, s = ct; ye = e, ct = !0; try { Mc(e); const o = e.fn(e._value); (t.version === 0 || He(o, e._value)) && (e.flags |= 128, e._value = o, t.version++) } catch (o) { throw t.version++, o } finally { ye = n, ct = s, Lc(e), e.flags &= -3 } } function oi(e, t = !1) { const { dep: n, prevSub: s, nextSub: o } = e; if (s && (s.nextSub = o, e.prevSub = void 0), o && (o.prevSub = s, e.nextSub = void 0), n.subs === e && (n.subs = s, !s && n.computed)) { n.computed.flags &= -5; for (let r = n.computed.deps; r; r = r.nextDep)oi(r, !0) } !t && !--n.sc && n.map && n.map.delete(n.key) } function Wf(e) { const { prevDep: t, nextDep: n } = e; t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0) } function rv(e, t) { e.effect instanceof Xs && (e = e.effect.fn); const n = new Xs(e); t && pe(n, t); try { n.run() } catch (o) { throw n.stop(), o } const s = n.run.bind(n); return s.effect = n, s } function iv(e) { e.effect.stop() } let ct = !0; const Hc = []; function It() { Hc.push(ct), ct = !1 } function Ot() { const e = Hc.pop(); ct = e === void 0 ? !0 : e } function Fi(e) { const { cleanup: t } = e; if (e.cleanup = void 0, t) { const n = ye; ye = void 0; try { t() } finally { ye = n } } } let os = 0; class Kf { constructor(t, n) { this.sub = t, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0 } } class Ao { constructor(t) { this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0 } track(t) { if (!ye || !ct || ye === this.computed) return; let n = this.activeLink; if (n === void 0 || n.sub !== ye) n = this.activeLink = new Kf(ye, this), ye.deps ? (n.prevDep = ye.depsTail, ye.depsTail.nextDep = n, ye.depsTail = n) : ye.deps = ye.depsTail = n, Dc(n); else if (n.version === -1 && (n.version = this.version, n.nextDep)) { const s = n.nextDep; s.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = s), n.prevDep = ye.depsTail, n.nextDep = void 0, ye.depsTail.nextDep = n, ye.depsTail = n, ye.deps === n && (ye.deps = s) } return n } trigger(t) { this.version++, os++, this.notify(t) } notify(t) { ni(); try { for (let n = this.subs; n; n = n.prevSub)n.sub.notify() && n.sub.dep.notify() } finally { si() } } } function Dc(e) { if (e.dep.sc++, e.sub.flags & 4) { const t = e.dep.computed; if (t && !e.dep.subs) { t.flags |= 20; for (let s = t.deps; s; s = s.nextDep)Dc(s) } const n = e.dep.subs; n !== e && (e.prevSub = n, n && (n.nextSub = e)), e.dep.subs = e } } const Zs = new WeakMap, tn = Symbol(""), gr = Symbol(""), rs = Symbol(""); function Oe(e, t, n) { if (ct && ye) { let s = Zs.get(e); s || Zs.set(e, s = new Map); let o = s.get(n); o || (s.set(n, o = new Ao), o.map = s, o.key = n), o.track() } } function Tt(e, t, n, s, o, r) { const i = Zs.get(e); if (!i) { os++; return } const a = c => { c && c.trigger() }; if (ni(), t === "clear") i.forEach(a); else { const c = z(e), u = c && ti(n); if (c && n === "length") { const l = Number(s); i.forEach((f, h) => { (h === "length" || h === rs || !lt(h) && h >= l) && a(f) }) } else switch ((n !== void 0 || i.has(void 0)) && a(i.get(n)), u && a(i.get(rs)), t) { case "add": c ? u && a(i.get("length")) : (a(i.get(tn)), En(e) && a(i.get(gr))); break; case "delete": c || (a(i.get(tn)), En(e) && a(i.get(gr))); break; case "set": En(e) && a(i.get(tn)); break } } si() } function zf(e, t) { const n = Zs.get(e); return n && n.get(t) } function gn(e) { const t = ae(e); return t === e ? t : (Oe(t, "iterate", rs), nt(e) ? t : t.map(Re)) } function Io(e) { return Oe(e = ae(e), "iterate", rs), e } const qf = { __proto__: null, [Symbol.iterator]() { return qo(this, Symbol.iterator, Re) }, concat(...e) { return gn(this).concat(...e.map(t => z(t) ? gn(t) : t)) }, entries() { return qo(this, "entries", e => (e[1] = Re(e[1]), e)) }, every(e, t) { return wt(this, "every", e, t, void 0, arguments) }, filter(e, t) { return wt(this, "filter", e, t, n => n.map(Re), arguments) }, find(e, t) { return wt(this, "find", e, t, Re, arguments) }, findIndex(e, t) { return wt(this, "findIndex", e, t, void 0, arguments) }, findLast(e, t) { return wt(this, "findLast", e, t, Re, arguments) }, findLastIndex(e, t) { return wt(this, "findLastIndex", e, t, void 0, arguments) }, forEach(e, t) { return wt(this, "forEach", e, t, void 0, arguments) }, includes(...e) { return Go(this, "includes", e) }, indexOf(...e) { return Go(this, "indexOf", e) }, join(e) { return gn(this).join(e) }, lastIndexOf(...e) { return Go(this, "lastIndexOf", e) }, map(e, t) { return wt(this, "map", e, t, void 0, arguments) }, pop() { return jn(this, "pop") }, push(...e) { return jn(this, "push", e) }, reduce(e, ...t) { return $i(this, "reduce", e, t) }, reduceRight(e, ...t) { return $i(this, "reduceRight", e, t) }, shift() { return jn(this, "shift") }, some(e, t) { return wt(this, "some", e, t, void 0, arguments) }, splice(...e) { return jn(this, "splice", e) }, toReversed() { return gn(this).toReversed() }, toSorted(e) { return gn(this).toSorted(e) }, toSpliced(...e) { return gn(this).toSpliced(...e) }, unshift(...e) { return jn(this, "unshift", e) }, values() { return qo(this, "values", Re) } }; function qo(e, t, n) { const s = Io(e), o = s[t](); return s !== e && !nt(e) && (o._next = o.next, o.next = () => { const r = o._next(); return r.value && (r.value = n(r.value)), r }), o } const Gf = Array.prototype; function wt(e, t, n, s, o, r) { const i = Io(e), a = i !== e && !nt(e), c = i[t]; if (c !== Gf[t]) { const f = c.apply(e, r); return a ? Re(f) : f } let u = n; i !== e && (a ? u = function (f, h) { return n.call(this, Re(f), h, e) } : n.length > 2 && (u = function (f, h) { return n.call(this, f, h, e) })); const l = c.call(i, u, s); return a && o ? o(l) : l } function $i(e, t, n, s) { const o = Io(e); let r = n; return o !== e && (nt(e) ? n.length > 3 && (r = function (i, a, c) { return n.call(this, i, a, c, e) }) : r = function (i, a, c) { return n.call(this, i, Re(a), c, e) }), o[t](r, ...s) } function Go(e, t, n) { const s = ae(e); Oe(s, "iterate", rs); const o = s[t](...n); return (o === -1 || o === !1) && ri(n[0]) ? (n[0] = ae(n[0]), s[t](...n)) : o } function jn(e, t, n = []) { It(), ni(); const s = ae(e)[t].apply(e, n); return si(), Ot(), s } const Yf = ko("__proto__,__v_isRef,__isVue"), Fc = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(lt)); function Qf(e) { lt(e) || (e = String(e)); const t = ae(this); return Oe(t, "has", e), t.hasOwnProperty(e) } class $c { constructor(t = !1, n = !1) { this._isReadonly = t, this._isShallow = n } get(t, n, s) { if (n === "__v_skip") return t.__v_skip; const o = this._isReadonly, r = this._isShallow; if (n === "__v_isReactive") return !o; if (n === "__v_isReadonly") return o; if (n === "__v_isShallow") return r; if (n === "__v_raw") return s === (o ? r ? Kc : Wc : r ? Bc : Vc).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(s) ? t : void 0; const i = z(t); if (!o) { let c; if (i && (c = qf[n])) return c; if (n === "hasOwnProperty") return Qf } const a = Reflect.get(t, n, xe(t) ? t : s); return (lt(n) ? Fc.has(n) : Yf(n)) || (o || Oe(t, "get", n), r) ? a : xe(a) ? i && ti(n) ? a : a.value : de(a) ? o ? zc(a) : ht(a) : a } } class jc extends $c { constructor(t = !1) { super(!1, t) } set(t, n, s, o) { let r = t[n]; if (!this._isShallow) { const c = Mt(r); if (!nt(s) && !Mt(s) && (r = ae(r), s = ae(s)), !z(t) && xe(r) && !xe(s)) return c ? !1 : (r.value = s, !0) } const i = z(t) && ti(n) ? Number(n) < t.length : le(t, n), a = Reflect.set(t, n, s, xe(t) ? t : o); return t === ae(o) && (i ? He(s, r) && Tt(t, "set", n, s) : Tt(t, "add", n, s)), a } deleteProperty(t, n) { const s = le(t, n); t[n]; const o = Reflect.deleteProperty(t, n); return o && s && Tt(t, "delete", n, void 0), o } has(t, n) { const s = Reflect.has(t, n); return (!lt(n) || !Fc.has(n)) && Oe(t, "has", n), s } ownKeys(t) { return Oe(t, "iterate", z(t) ? "length" : tn), Reflect.ownKeys(t) } } class Uc extends $c { constructor(t = !1) { super(!0, t) } set(t, n) { return !0 } deleteProperty(t, n) { return !0 } } const Jf = new jc, Xf = new Uc, Zf = new jc(!0), eh = new Uc(!0), mr = e => e, Ps = e => Reflect.getPrototypeOf(e); function th(e, t, n) { return function (...s) { const o = this.__v_raw, r = ae(o), i = En(r), a = e === "entries" || e === Symbol.iterator && i, c = e === "keys" && i, u = o[e](...s), l = n ? mr : t ? eo : Re; return !t && Oe(r, "iterate", c ? gr : tn), { next() { const { value: f, done: h } = u.next(); return h ? { value: f, done: h } : { value: a ? [l(f[0]), l(f[1])] : l(f), done: h } }, [Symbol.iterator]() { return this } } } } function Ss(e) { return function (...t) { return e === "delete" ? !1 : e === "clear" ? void 0 : this } } function nh(e, t) { const n = { get(o) { const r = this.__v_raw, i = ae(r), a = ae(o); e || (He(o, a) && Oe(i, "get", o), Oe(i, "get", a)); const { has: c } = Ps(i), u = t ? mr : e ? eo : Re; if (c.call(i, o)) return u(r.get(o)); if (c.call(i, a)) return u(r.get(a)); r !== i && r.get(o) }, get size() { const o = this.__v_raw; return !e && Oe(ae(o), "iterate", tn), Reflect.get(o, "size", o) }, has(o) { const r = this.__v_raw, i = ae(r), a = ae(o); return e || (He(o, a) && Oe(i, "has", o), Oe(i, "has", a)), o === a ? r.has(o) : r.has(o) || r.has(a) }, forEach(o, r) { const i = this, a = i.__v_raw, c = ae(a), u = t ? mr : e ? eo : Re; return !e && Oe(c, "iterate", tn), a.forEach((l, f) => o.call(r, u(l), u(f), i)) } }; return pe(n, e ? { add: Ss("add"), set: Ss("set"), delete: Ss("delete"), clear: Ss("clear") } : { add(o) { !t && !nt(o) && !Mt(o) && (o = ae(o)); const r = ae(this); return Ps(r).has.call(r, o) || (r.add(o), Tt(r, "add", o, o)), this }, set(o, r) { !t && !nt(r) && !Mt(r) && (r = ae(r)); const i = ae(this), { has: a, get: c } = Ps(i); let u = a.call(i, o); u || (o = ae(o), u = a.call(i, o)); const l = c.call(i, o); return i.set(o, r), u ? He(r, l) && Tt(i, "set", o, r) : Tt(i, "add", o, r), this }, delete(o) { const r = ae(this), { has: i, get: a } = Ps(r); let c = i.call(r, o); c || (o = ae(o), c = i.call(r, o)), a && a.call(r, o); const u = r.delete(o); return c && Tt(r, "delete", o, void 0), u }, clear() { const o = ae(this), r = o.size !== 0, i = o.clear(); return r && Tt(o, "clear", void 0, void 0), i } }), ["keys", "values", "entries", Symbol.iterator].forEach(o => { n[o] = th(o, e, t) }), n } function Oo(e, t) { const n = nh(e, t); return (s, o, r) => o === "__v_isReactive" ? !e : o === "__v_isReadonly" ? e : o === "__v_raw" ? s : Reflect.get(le(n, o) && o in s ? n : s, o, r) } const sh = { get: Oo(!1, !1) }, oh = { get: Oo(!1, !0) }, rh = { get: Oo(!0, !1) }, ih = { get: Oo(!0, !0) }, Vc = new WeakMap, Bc = new WeakMap, Wc = new WeakMap, Kc = new WeakMap; function ah(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function ch(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : ah(Rf(e)) } function ht(e) { return Mt(e) ? e : Mo(e, !1, Jf, sh, Vc) } function Rt(e) { return Mo(e, !1, Zf, oh, Bc) } function zc(e) { return Mo(e, !0, Xf, rh, Wc) } function av(e) { return Mo(e, !0, eh, ih, Kc) } function Mo(e, t, n, s, o) { if (!de(e) || e.__v_raw && !(t && e.__v_isReactive)) return e; const r = ch(e); if (r === 0) return e; const i = o.get(e); if (i) return i; const a = new Proxy(e, r === 2 ? s : n); return o.set(e, a), a } function nn(e) { return Mt(e) ? nn(e.__v_raw) : !!(e && e.__v_isReactive) } function Mt(e) { return !!(e && e.__v_isReadonly) } function nt(e) { return !!(e && e.__v_isShallow) } function ri(e) { return e ? !!e.__v_raw : !1 } function ae(e) { const t = e && e.__v_raw; return t ? ae(t) : e } function lh(e) { return !le(e, "__v_skip") && Object.isExtensible(e) && dr(e, "__v_skip", !0), e } const Re = e => de(e) ? ht(e) : e, eo = e => de(e) ? zc(e) : e; function xe(e) { return e ? e.__v_isRef === !0 : !1 } function $e(e) { return qc(e, !1) } function an(e) { return qc(e, !0) } function qc(e, t) { return xe(e) ? e : new uh(e, t) } class uh { constructor(t, n) { this.dep = new Ao, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? t : ae(t), this._value = n ? t : Re(t), this.__v_isShallow = n } get value() { return this.dep.track(), this._value } set value(t) { const n = this._rawValue, s = this.__v_isShallow || nt(t) || Mt(t); t = s ? t : ae(t), He(t, n) && (this._rawValue = t, this._value = s ? t : Re(t), this.dep.trigger()) } } function cv(e) { e.dep && e.dep.trigger() } function be(e) { return xe(e) ? e.value : e } function fh(e) { return ee(e) ? e() : be(e) } const hh = { get: (e, t, n) => t === "__v_raw" ? e : be(Reflect.get(e, t, n)), set: (e, t, n, s) => { const o = e[t]; return xe(o) && !xe(n) ? (o.value = n, !0) : Reflect.set(e, t, n, s) } }; function Gc(e) { return nn(e) ? e : new Proxy(e, hh) } class dh { constructor(t) { this.__v_isRef = !0, this._value = void 0; const n = this.dep = new Ao, { get: s, set: o } = t(n.track.bind(n), n.trigger.bind(n)); this._get = s, this._set = o } get value() { return this._value = this._get() } set value(t) { this._set(t) } } function ph(e) { return new dh(e) } function lv(e) { const t = z(e) ? new Array(e.length) : {}; for (const n in e) t[n] = Qc(e, n); return t } class gh { constructor(t, n, s) { this._object = t, this._key = n, this._defaultValue = s, this.__v_isRef = !0, this._value = void 0 } get value() { const t = this._object[this._key]; return this._value = t === void 0 ? this._defaultValue : t } set value(t) { this._object[this._key] = t } get dep() { return zf(ae(this._object), this._key) } } class mh { constructor(t) { this._getter = t, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0 } get value() { return this._value = this._getter() } } function Yc(e, t, n) { return xe(e) ? e : ee(e) ? new mh(e) : de(e) && arguments.length > 1 ? Qc(e, t, n) : $e(e) } function Qc(e, t, n) { const s = e[t]; return xe(s) ? s : new gh(e, t, n) } class yh { constructor(t, n, s) { this.fn = t, this.setter = n, this._value = void 0, this.dep = new Ao(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = os - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = s } notify() { if (this.flags |= 16, !(this.flags & 8) && ye !== this) return Oc(this, !0), !0 } get value() { const t = this.dep.track(); return Nc(this), t && (t.version = this.dep.version), this._value } set value(t) { this.setter && this.setter(t) } } function _h(e, t, n = !1) { let s, o; return ee(e) ? s = e : (s = e.get, o = e.set), new yh(s, o, n) } const uv = { GET: "get", HAS: "has", ITERATE: "iterate" }, fv = { SET: "set", ADD: "add", DELETE: "delete", CLEAR: "clear" }, Cs = {}, to = new WeakMap; let jt; function hv() { return jt } function bh(e, t = !1, n = jt) { if (n) { let s = to.get(n); s || to.set(n, s = []), s.push(e) } } function vh(e, t, n = oe) { const { immediate: s, deep: o, once: r, scheduler: i, augmentJob: a, call: c } = n, u = y => o ? y : nt(y) || o === !1 || o === 0 ? Pt(y, 1) : Pt(y); let l, f, h, p, _ = !1, g = !1; if (xe(e) ? (f = () => e.value, _ = nt(e)) : nn(e) ? (f = () => u(e), _ = !0) : z(e) ? (g = !0, _ = e.some(y => nn(y) || nt(y)), f = () => e.map(y => { if (xe(y)) return y.value; if (nn(y)) return u(y); if (ee(y)) return c ? c(y, 2) : y() })) : ee(e) ? t ? f = c ? () => c(e, 2) : e : f = () => { if (h) { It(); try { h() } finally { Ot() } } const y = jt; jt = l; try { return c ? c(e, 3, [p]) : e(p) } finally { jt = y } } : f = tt, t && o) { const y = f, x = o === !0 ? 1 / 0 : o; f = () => Pt(y(), x) } const E = Ac(), k = () => { l.stop(), E && E.active && Zr(E.effects, l) }; if (r && t) { const y = t; t = (...x) => { y(...x), k() } } let w = g ? new Array(e.length).fill(Cs) : Cs; const d = y => { if (!(!(l.flags & 1) || !l.dirty && !y)) if (t) { const x = l.run(); if (o || _ || (g ? x.some((T, S) => He(T, w[S])) : He(x, w))) { h && h(); const T = jt; jt = l; try { const S = [x, w === Cs ? void 0 : g && w[0] === Cs ? [] : w, p]; w = x, c ? c(t, 3, S) : t(...S) } finally { jt = T } } } else l.run() }; return a && a(d), l = new Xs(f), l.scheduler = i ? () => i(d, !1) : d, p = y => bh(y, !1, l), h = l.onStop = () => { const y = to.get(l); if (y) { if (c) c(y, 4); else for (const x of y) x(); to.delete(l) } }, t ? s ? d(!0) : w = l.run() : i ? i(d.bind(null, !0), !0) : l.run(), k.pause = l.pause.bind(l), k.resume = l.resume.bind(l), k.stop = k, k } function Pt(e, t = 1 / 0, n) { if (t <= 0 || !de(e) || e.__v_skip || (n = n || new Set, n.has(e))) return e; if (n.add(e), t--, xe(e)) Pt(e.value, t, n); else if (z(e)) for (let s = 0; s < e.length; s++)Pt(e[s], t, n); else if (fn(e) || En(e)) e.forEach(s => { Pt(s, t, n) }); else if (xo(e)) { for (const s in e) Pt(e[s], t, n); for (const s of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, s) && Pt(e[s], t, n) } return e }/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/const Jc = []; function wh(e) { Jc.push(e) } function Eh() { Jc.pop() } function dv(e, t) { } const pv = { SETUP_FUNCTION: 0, 0: "SETUP_FUNCTION", RENDER_FUNCTION: 1, 1: "RENDER_FUNCTION", NATIVE_EVENT_HANDLER: 5, 5: "NATIVE_EVENT_HANDLER", COMPONENT_EVENT_HANDLER: 6, 6: "COMPONENT_EVENT_HANDLER", VNODE_HOOK: 7, 7: "VNODE_HOOK", DIRECTIVE_HOOK: 8, 8: "DIRECTIVE_HOOK", TRANSITION_HOOK: 9, 9: "TRANSITION_HOOK", APP_ERROR_HANDLER: 10, 10: "APP_ERROR_HANDLER", APP_WARN_HANDLER: 11, 11: "APP_WARN_HANDLER", FUNCTION_REF: 12, 12: "FUNCTION_REF", ASYNC_COMPONENT_LOADER: 13, 13: "ASYNC_COMPONENT_LOADER", SCHEDULER: 14, 14: "SCHEDULER", COMPONENT_UPDATE: 15, 15: "COMPONENT_UPDATE", APP_UNMOUNT_CLEANUP: 16, 16: "APP_UNMOUNT_CLEANUP" }, kh = { sp: "serverPrefetch hook", bc: "beforeCreate hook", c: "created hook", bm: "beforeMount hook", m: "mounted hook", bu: "beforeUpdate hook", u: "updated", bum: "beforeUnmount hook", um: "unmounted hook", a: "activated hook", da: "deactivated hook", ec: "errorCaptured hook", rtc: "renderTracked hook", rtg: "renderTriggered hook", 0: "setup function", 1: "render function", 2: "watcher getter", 3: "watcher callback", 4: "watcher cleanup function", 5: "native event handler", 6: "component event handler", 7: "vnode hook", 8: "directive hook", 9: "transition hook", 10: "app errorHandler", 11: "app warnHandler", 12: "ref function", 13: "async component loader", 14: "scheduler flush", 15: "component update", 16: "app unmount cleanup function" }; function _s(e, t, n, s) { try { return s ? e(...s) : e() } catch (o) { Dn(o, t, n) } } function ut(e, t, n, s) { if (ee(e)) { const o = _s(e, t, n, s); return o && ei(o) && o.catch(r => { Dn(r, t, n) }), o } if (z(e)) { const o = []; for (let r = 0; r < e.length; r++)o.push(ut(e[r], t, n, s)); return o } } function Dn(e, t, n, s = !0) { const o = t ? t.vnode : null, { errorHandler: r, throwUnhandledErrorInProduction: i } = t && t.appContext.config || oe; if (t) { let a = t.parent; const c = t.proxy, u = `https://vuejs.org/error-reference/#runtime-${n}`; for (; a;) { const l = a.ec; if (l) { for (let f = 0; f < l.length; f++)if (l[f](e, c, u) === !1) return } a = a.parent } if (r) { It(), _s(r, null, 10, [e, c, u]), Ot(); return } } xh(e, n, o, s, i) } function xh(e, t, n, s = !0, o = !1) { if (o) throw e; console.error(e) } const De = []; let yt = -1; const Tn = []; let Ut = null, yn = 0; const Xc = Promise.resolve(); let no = null; function qt(e) { const t = no || Xc; return e ? t.then(this ? e.bind(this) : e) : t } function Th(e) { let t = yt + 1, n = De.length; for (; t < n;) { const s = t + n >>> 1, o = De[s], r = is(o); r < e || r === e && o.flags & 2 ? t = s + 1 : n = s } return t } function ii(e) { if (!(e.flags & 1)) { const t = is(e), n = De[De.length - 1]; !n || !(e.flags & 2) && t >= is(n) ? De.push(e) : De.splice(Th(t), 0, e), e.flags |= 1, Zc() } } function Zc() { no || (no = Xc.then(el)) } function so(e) { z(e) ? Tn.push(...e) : Ut && e.id === -1 ? Ut.splice(yn + 1, 0, e) : e.flags & 1 || (Tn.push(e), e.flags |= 1), Zc() } function ji(e, t, n = yt + 1) { for (; n < De.length; n++) { const s = De[n]; if (s && s.flags & 2) { if (e && s.id !== e.uid) continue; De.splice(n, 1), n--, s.flags & 4 && (s.flags &= -2), s(), s.flags & 4 || (s.flags &= -2) } } } function oo(e) { if (Tn.length) { const t = [...new Set(Tn)].sort((n, s) => is(n) - is(s)); if (Tn.length = 0, Ut) { Ut.push(...t); return } for (Ut = t, yn = 0; yn < Ut.length; yn++) { const n = Ut[yn]; n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2 } Ut = null, yn = 0 } } const is = e => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id; function el(e) { try { for (yt = 0; yt < De.length; yt++) { const t = De[yt]; t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), _s(t, t.i, t.i ? 15 : 14), t.flags & 4 || (t.flags &= -2)) } } finally { for (; yt < De.length; yt++) { const t = De[yt]; t && (t.flags &= -2) } yt = -1, De.length = 0, oo(), no = null, (De.length || Tn.length) && el() } } let _n, Rs = []; function tl(e, t) { var n, s; _n = e, _n ? (_n.enabled = !0, Rs.forEach(({ event: o, args: r }) => _n.emit(o, ...r)), Rs = []) : typeof window < "u" && window.HTMLElement && !((s = (n = window.navigator) == null ? void 0 : n.userAgent) != null && s.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(r => { tl(r, t) }), setTimeout(() => { _n || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Rs = []) }, 3e3)) : Rs = [] } let Se = null, Lo = null; function as(e) { const t = Se; return Se = e, Lo = e && e.type.__scopeId || null, t } function gv(e) { Lo = e } function mv() { Lo = null } const yv = e => ai; function ai(e, t = Se, n) { if (!t || e._n) return e; const s = (...o) => { s._d && ea(-1); const r = as(t); let i; try { i = e(...o) } finally { as(r), s._d && ea(1) } return i }; return s._n = !0, s._c = !0, s._d = !0, s } function _v(e, t) { if (Se === null) return e; const n = xs(Se), s = e.dirs || (e.dirs = []); for (let o = 0; o < t.length; o++) { let [r, i, a, c = oe] = t[o]; r && (ee(r) && (r = { mounted: r, updated: r }), r.deep && Pt(i), s.push({ dir: r, instance: n, value: i, oldValue: void 0, arg: a, modifiers: c })) } return e } function _t(e, t, n, s) { const o = e.dirs, r = t && t.dirs; for (let i = 0; i < o.length; i++) { const a = o[i]; r && (a.oldValue = r[i].value); let c = a.dir[s]; c && (It(), ut(c, n, 8, [e.el, a, e, t]), Ot()) } } const nl = Symbol("_vte"), sl = e => e.__isTeleport, Jn = e => e && (e.disabled || e.disabled === ""), Ui = e => e && (e.defer || e.defer === ""), Vi = e => typeof SVGElement < "u" && e instanceof SVGElement, Bi = e => typeof MathMLElement == "function" && e instanceof MathMLElement, yr = (e, t) => { const n = e && e.to; return _e(n) ? t ? t(n) : null : n }, ol = { name: "Teleport", __isTeleport: !0, process(e, t, n, s, o, r, i, a, c, u) { const { mc: l, pc: f, pbc: h, o: { insert: p, querySelector: _, createText: g, createComment: E } } = u, k = Jn(t.props); let { shapeFlag: w, children: d, dynamicChildren: y } = t; if (e == null) { const x = t.el = g(""), T = t.anchor = g(""); p(x, n, s), p(T, n, s); const S = (O, I) => { w & 16 && (o && o.isCE && (o.ce._teleportTarget = O), l(d, O, I, o, r, i, a, c)) }, F = () => { const O = t.target = yr(t.props, _), I = rl(O, t, g, p); O && (i !== "svg" && Vi(O) ? i = "svg" : i !== "mathml" && Bi(O) && (i = "mathml"), k || (S(O, I), Us(t, !1))) }; k && (S(n, T), Us(t, !0)), Ui(t.props) ? (t.el.__isMounted = !1, Te(() => { F(), delete t.el.__isMounted }, r)) : F() } else { if (Ui(t.props) && e.el.__isMounted === !1) { Te(() => { ol.process(e, t, n, s, o, r, i, a, c, u) }, r); return } t.el = e.el, t.targetStart = e.targetStart; const x = t.anchor = e.anchor, T = t.target = e.target, S = t.targetAnchor = e.targetAnchor, F = Jn(e.props), O = F ? n : T, I = F ? x : S; if (i === "svg" || Vi(T) ? i = "svg" : (i === "mathml" || Bi(T)) && (i = "mathml"), y ? (h(e.dynamicChildren, y, O, o, r, i, a), yi(e, t, !0)) : c || f(e, t, O, I, o, r, i, a, !1), k) F ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : As(t, n, x, u, 1); else if ((t.props && t.props.to) !== (e.props && e.props.to)) { const q = t.target = yr(t.props, _); q && As(t, q, null, u, 0) } else F && As(t, T, S, u, 1); Us(t, k) } }, remove(e, t, n, { um: s, o: { remove: o } }, r) { const { shapeFlag: i, children: a, anchor: c, targetStart: u, targetAnchor: l, target: f, props: h } = e; if (f && (o(u), o(l)), r && o(c), i & 16) { const p = r || !Jn(h); for (let _ = 0; _ < a.length; _++) { const g = a[_]; s(g, t, n, p, !!g.dynamicChildren) } } }, move: As, hydrate: Ph }; function As(e, t, n, { o: { insert: s }, m: o }, r = 2) { r === 0 && s(e.targetAnchor, t, n); const { el: i, anchor: a, shapeFlag: c, children: u, props: l } = e, f = r === 2; if (f && s(i, t, n), (!f || Jn(l)) && c & 16) for (let h = 0; h < u.length; h++)o(u[h], t, n, 2); f && s(a, t, n) } function Ph(e, t, n, s, o, r, { o: { nextSibling: i, parentNode: a, querySelector: c, insert: u, createText: l } }, f) { const h = t.target = yr(t.props, c); if (h) { const p = Jn(t.props), _ = h._lpa || h.firstChild; if (t.shapeFlag & 16) if (p) t.anchor = f(i(e), t, a(e), n, s, o, r), t.targetStart = _, t.targetAnchor = _ && i(_); else { t.anchor = i(e); let g = _; for (; g;) { if (g && g.nodeType === 8) { if (g.data === "teleport start anchor") t.targetStart = g; else if (g.data === "teleport anchor") { t.targetAnchor = g, h._lpa = t.targetAnchor && i(t.targetAnchor); break } } g = i(g) } t.targetAnchor || rl(h, t, l, u), f(_ && i(_), t, h, n, s, o, r) } Us(t, p) } return t.anchor && i(t.anchor) } const bv = ol; function Us(e, t) { const n = e.ctx; if (n && n.ut) { let s, o; for (t ? (s = e.el, o = e.anchor) : (s = e.targetStart, o = e.targetAnchor); s && s !== o;)s.nodeType === 1 && s.setAttribute("data-v-owner", n.uid), s = s.nextSibling; n.ut() } } function rl(e, t, n, s) { const o = t.targetStart = n(""), r = t.targetAnchor = n(""); return o[nl] = r, e && (s(o, e), s(r, e)), r } const Vt = Symbol("_leaveCb"), Is = Symbol("_enterCb"); function il() { const e = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map }; return hn(() => { e.isMounted = !0 }), vs(() => { e.isUnmounting = !0 }), e } const Xe = [Function, Array], al = { mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: Xe, onEnter: Xe, onAfterEnter: Xe, onEnterCancelled: Xe, onBeforeLeave: Xe, onLeave: Xe, onAfterLeave: Xe, onLeaveCancelled: Xe, onBeforeAppear: Xe, onAppear: Xe, onAfterAppear: Xe, onAppearCancelled: Xe }, cl = e => { const t = e.subTree; return t.component ? cl(t.component) : t }, Sh = { name: "BaseTransition", props: al, setup(e, { slots: t }) { const n = Je(), s = il(); return () => { const o = t.default && ci(t.default(), !0); if (!o || !o.length) return; const r = ll(o), i = ae(e), { mode: a } = i; if (s.isLeaving) return Yo(r); const c = Wi(r); if (!c) return Yo(r); let u = cs(c, i, s, n, f => u = f); c.type !== ke && Gt(c, u); let l = n.subTree && Wi(n.subTree); if (l && l.type !== ke && !at(c, l) && cl(n).type !== ke) { let f = cs(l, i, s, n); if (Gt(l, f), a === "out-in" && c.type !== ke) return s.isLeaving = !0, f.afterLeave = () => { s.isLeaving = !1, n.job.flags & 8 || n.update(), delete f.afterLeave, l = void 0 }, Yo(r); a === "in-out" && c.type !== ke ? f.delayLeave = (h, p, _) => { const g = ul(s, l); g[String(l.key)] = l, h[Vt] = () => { p(), h[Vt] = void 0, delete u.delayedLeave, l = void 0 }, u.delayedLeave = () => { _(), delete u.delayedLeave, l = void 0 } } : l = void 0 } else l && (l = void 0); return r } } }; function ll(e) { let t = e[0]; if (e.length > 1) { for (const n of e) if (n.type !== ke) { t = n; break } } return t } const Ch = Sh; function ul(e, t) { const { leavingVNodes: n } = e; let s = n.get(t.type); return s || (s = Object.create(null), n.set(t.type, s)), s } function cs(e, t, n, s, o) { const { appear: r, mode: i, persisted: a = !1, onBeforeEnter: c, onEnter: u, onAfterEnter: l, onEnterCancelled: f, onBeforeLeave: h, onLeave: p, onAfterLeave: _, onLeaveCancelled: g, onBeforeAppear: E, onAppear: k, onAfterAppear: w, onAppearCancelled: d } = t, y = String(e.key), x = ul(n, e), T = (O, I) => { O && ut(O, s, 9, I) }, S = (O, I) => { const q = I[1]; T(O, I), z(O) ? O.every(A => A.length <= 1) && q() : O.length <= 1 && q() }, F = { mode: i, persisted: a, beforeEnter(O) { let I = c; if (!n.isMounted) if (r) I = E || c; else return; O[Vt] && O[Vt](!0); const q = x[y]; q && at(e, q) && q.el[Vt] && q.el[Vt](), T(I, [O]) }, enter(O) { let I = u, q = l, A = f; if (!n.isMounted) if (r) I = k || u, q = w || l, A = d || f; else return; let W = !1; const ne = O[Is] = ie => { W || (W = !0, ie ? T(A, [O]) : T(q, [O]), F.delayedLeave && F.delayedLeave(), O[Is] = void 0) }; I ? S(I, [O, ne]) : ne() }, leave(O, I) { const q = String(e.key); if (O[Is] && O[Is](!0), n.isUnmounting) return I(); T(h, [O]); let A = !1; const W = O[Vt] = ne => { A || (A = !0, I(), ne ? T(g, [O]) : T(_, [O]), O[Vt] = void 0, x[q] === e && delete x[q]) }; x[q] = e, p ? S(p, [O, W]) : W() }, clone(O) { const I = cs(O, t, n, s, o); return o && o(I), I } }; return F } function Yo(e) { if (bs(e)) return e = Lt(e), e.children = null, e } function Wi(e) { if (!bs(e)) return sl(e.type) && e.children ? ll(e.children) : e; if (e.component) return e.component.subTree; const { shapeFlag: t, children: n } = e; if (n) { if (t & 16) return n[0]; if (t & 32 && ee(n.default)) return n.default() } } function Gt(e, t) { e.shapeFlag & 6 && e.component ? (e.transition = t, Gt(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t } function ci(e, t = !1, n) { let s = [], o = 0; for (let r = 0; r < e.length; r++) { let i = e[r]; const a = n == null ? i.key : String(n) + String(i.key != null ? i.key : r); i.type === Ce ? (i.patchFlag & 128 && o++, s = s.concat(ci(i.children, t, a))) : (t || i.type !== ke) && s.push(a != null ? Lt(i, { key: a }) : i) } if (o > 1) for (let r = 0; r < s.length; r++)s[r].patchFlag = -2; return s }/*! #__NO_SIDE_EFFECTS__ */function vt(e, t) { return ee(e) ? pe({ name: e.name }, t, { setup: e }) : e } function vv() { const e = Je(); return e ? (e.appContext.config.idPrefix || "v") + "-" + e.ids[0] + e.ids[1]++ : "" } function li(e) { e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0] } function wv(e) { const t = Je(), n = an(null); if (t) { const o = t.refs === oe ? t.refs = {} : t.refs; Object.defineProperty(o, e, { enumerable: !0, get: () => n.value, set: r => n.value = r }) } return n } function Pn(e, t, n, s, o = !1) { if (z(e)) { e.forEach((_, g) => Pn(_, t && (z(t) ? t[g] : t), n, s, o)); return } if (Kt(s) && !o) { s.shapeFlag & 512 && s.type.__asyncResolved && s.component.subTree.component && Pn(e, t, n, s.component.subTree); return } const r = s.shapeFlag & 4 ? xs(s.component) : s.el, i = o ? null : r, { i: a, r: c } = e, u = t && t.r, l = a.refs === oe ? a.refs = {} : a.refs, f = a.setupState, h = ae(f), p = f === oe ? () => !1 : _ => le(h, _); if (u != null && u !== c && (_e(u) ? (l[u] = null, p(u) && (f[u] = null)) : xe(u) && (u.value = null)), ee(c)) _s(c, a, 12, [i, l]); else { const _ = _e(c), g = xe(c); if (_ || g) { const E = () => { if (e.f) { const k = _ ? p(c) ? f[c] : l[c] : c.value; o ? z(k) && Zr(k, r) : z(k) ? k.includes(r) || k.push(r) : _ ? (l[c] = [r], p(c) && (f[c] = l[c])) : (c.value = [r], e.k && (l[e.k] = c.value)) } else _ ? (l[c] = i, p(c) && (f[c] = i)) : g && (c.value = i, e.k && (l[e.k] = i)) }; i ? (E.id = -1, Te(E, n)) : E() } } } let Ki = !1; const mn = () => { Ki || (console.error("Hydration completed but contains mismatches."), Ki = !0) }, Rh = e => e.namespaceURI.includes("svg") && e.tagName !== "foreignObject", Ah = e => e.namespaceURI.includes("MathML"), Os = e => { if (e.nodeType === 1) { if (Rh(e)) return "svg"; if (Ah(e)) return "mathml" } }, vn = e => e.nodeType === 8; function Ih(e) {
    const { mt: t, p: n, o: { patchProp: s, createText: o, nextSibling: r, parentNode: i, remove: a, insert: c, createComment: u } } = e, l = (d, y) => { if (!y.hasChildNodes()) { n(null, d, y), oo(), y._vnode = d; return } f(y.firstChild, d, null, null, null), oo(), y._vnode = d }, f = (d, y, x, T, S, F = !1) => { F = F || !!y.dynamicChildren; const O = vn(d) && d.data === "[", I = () => g(d, y, x, T, S, O), { type: q, ref: A, shapeFlag: W, patchFlag: ne } = y; let ie = d.nodeType; y.el = d, ne === -2 && (F = !1, y.dynamicChildren = null); let K = null; switch (q) { case on: ie !== 3 ? y.children === "" ? (c(y.el = o(""), i(d), d), K = d) : K = I() : (d.data !== y.children && (mn(), d.data = y.children), K = r(d)); break; case ke: w(d) ? (K = r(d), k(y.el = d.content.firstChild, d, x)) : ie !== 8 || O ? K = I() : K = r(d); break; case Rn: if (O && (d = r(d), ie = d.nodeType), ie === 1 || ie === 3) { K = d; const Z = !y.children.length; for (let v = 0; v < y.staticCount; v++)Z && (y.children += K.nodeType === 1 ? K.outerHTML : K.data), v === y.staticCount - 1 && (y.anchor = K), K = r(K); return O ? r(K) : K } else I(); break; case Ce: O ? K = _(d, y, x, T, S, F) : K = I(); break; default: if (W & 1) (ie !== 1 || y.type.toLowerCase() !== d.tagName.toLowerCase()) && !w(d) ? K = I() : K = h(d, y, x, T, S, F); else if (W & 6) { y.slotScopeIds = S; const Z = i(d); if (O ? K = E(d) : vn(d) && d.data === "teleport start" ? K = E(d, d.data, "teleport end") : K = r(d), t(y, Z, null, x, T, Os(Z), F), Kt(y) && !y.type.__asyncResolved) { let v; O ? (v = he(Ce), v.anchor = K ? K.previousSibling : Z.lastChild) : v = d.nodeType === 3 ? Ul("") : he("div"), v.el = d, y.component.subTree = v } } else W & 64 ? ie !== 8 ? K = I() : K = y.type.hydrate(d, y, x, T, S, F, e, p) : W & 128 && (K = y.type.hydrate(d, y, x, T, Os(i(d)), S, F, e, f)) }return A != null && Pn(A, null, T, y), K }, h = (d, y, x, T, S, F) => {
        F = F || !!y.dynamicChildren; const { type: O, props: I, patchFlag: q, shapeFlag: A, dirs: W, transition: ne } = y, ie = O === "input" || O === "option"; if (ie || q !== -1) {
            W && _t(y, null, x, "created"); let K = !1; if (w(d)) { K = Rl(null, ne) && x && x.vnode.props && x.vnode.props.appear; const v = d.content.firstChild; if (K) { const L = v.getAttribute("class"); L && (v.$cls = L), ne.beforeEnter(v) } k(v, d, x), y.el = d = v } if (A & 16 && !(I && (I.innerHTML || I.textContent))) { let v = p(d.firstChild, y, d, x, T, S, F); for (; v;) { Ms(d, 1) || mn(); const L = v; v = v.nextSibling, a(L) } } else if (A & 8) {
                let v = y.children; v[0] === `
`&& (d.tagName === "PRE" || d.tagName === "TEXTAREA") && (v = v.slice(1)), d.textContent !== v && (Ms(d, 0) || mn(), d.textContent = y.children)
            } if (I) { if (ie || !F || q & 48) { const v = d.tagName.includes("-"); for (const L in I) (ie && (L.endsWith("value") || L === "indeterminate") || ms(L) && !kn(L) || L[0] === "." || v) && s(d, L, null, I[L], void 0, x) } else if (I.onClick) s(d, "onClick", null, I.onClick, void 0, x); else if (q & 4 && nn(I.style)) for (const v in I.style) I.style[v] } let Z; (Z = I && I.onVnodeBeforeMount) && Ve(Z, x, y), W && _t(y, null, x, "beforeMount"), ((Z = I && I.onVnodeMounted) || W || K) && Hl(() => { Z && Ve(Z, x, y), K && ne.enter(d), W && _t(y, null, x, "mounted") }, T)
        } return d.nextSibling
    }, p = (d, y, x, T, S, F, O) => { O = O || !!y.dynamicChildren; const I = y.children, q = I.length; for (let A = 0; A < q; A++) { const W = O ? I[A] : I[A] = Be(I[A]), ne = W.type === on; d ? (ne && !O && A + 1 < q && Be(I[A + 1]).type === on && (c(o(d.data.slice(W.children.length)), x, r(d)), d.data = W.children), d = f(d, W, T, S, F, O)) : ne && !W.children ? c(W.el = o(""), x) : (Ms(x, 1) || mn(), n(null, W, x, null, T, S, Os(x), F)) } return d }, _ = (d, y, x, T, S, F) => { const { slotScopeIds: O } = y; O && (S = S ? S.concat(O) : O); const I = i(d), q = p(r(d), y, I, x, T, S, F); return q && vn(q) && q.data === "]" ? r(y.anchor = q) : (mn(), c(y.anchor = u("]"), I, q), q) }, g = (d, y, x, T, S, F) => { if (Ms(d.parentElement, 1) || mn(), y.el = null, F) { const q = E(d); for (; ;) { const A = r(d); if (A && A !== q) a(A); else break } } const O = r(d), I = i(d); return a(d), n(null, y, I, O, x, T, Os(I), S), x && (x.vnode.el = y.el, Fo(x, y.el)), O }, E = (d, y = "[", x = "]") => { let T = 0; for (; d;)if (d = r(d), d && vn(d) && (d.data === y && T++, d.data === x)) { if (T === 0) return r(d); T-- } return d }, k = (d, y, x) => { const T = y.parentNode; T && T.replaceChild(d, y); let S = x; for (; S;)S.vnode.el === y && (S.vnode.el = S.subTree.el = d), S = S.parent }, w = d => d.nodeType === 1 && d.tagName === "TEMPLATE"; return [l, f]
} const zi = "data-allow-mismatch", Oh = { 0: "text", 1: "children", 2: "class", 3: "style", 4: "attribute" }; function Ms(e, t) { if (t === 0 || t === 1) for (; e && !e.hasAttribute(zi);)e = e.parentElement; const n = e && e.getAttribute(zi); if (n == null) return !1; if (n === "") return !0; { const s = n.split(","); return t === 0 && s.includes("children") ? !0 : s.includes(Oh[t]) } } const Mh = So().requestIdleCallback || (e => setTimeout(e, 1)), Lh = So().cancelIdleCallback || (e => clearTimeout(e)), Ev = (e = 1e4) => t => { const n = Mh(t, { timeout: e }); return () => Lh(n) }; function Nh(e) { const { top: t, left: n, bottom: s, right: o } = e.getBoundingClientRect(), { innerHeight: r, innerWidth: i } = window; return (t > 0 && t < r || s > 0 && s < r) && (n > 0 && n < i || o > 0 && o < i) } const kv = e => (t, n) => { const s = new IntersectionObserver(o => { for (const r of o) if (r.isIntersecting) { s.disconnect(), t(); break } }, e); return n(o => { if (o instanceof Element) { if (Nh(o)) return t(), s.disconnect(), !1; s.observe(o) } }), () => s.disconnect() }, xv = e => t => { if (e) { const n = matchMedia(e); if (n.matches) t(); else return n.addEventListener("change", t, { once: !0 }), () => n.removeEventListener("change", t) } }, Tv = (e = []) => (t, n) => { _e(e) && (e = [e]); let s = !1; const o = i => { s || (s = !0, r(), t(), i.target.dispatchEvent(new i.constructor(i.type, i))) }, r = () => { n(i => { for (const a of e) i.removeEventListener(a, o) }) }; return n(i => { for (const a of e) i.addEventListener(a, o, { once: !0 }) }), r }; function Hh(e, t) { if (vn(e) && e.data === "[") { let n = 1, s = e.nextSibling; for (; s;) { if (s.nodeType === 1) { if (t(s) === !1) break } else if (vn(s)) if (s.data === "]") { if (--n === 0) break } else s.data === "[" && n++; s = s.nextSibling } } else t(e) } const Kt = e => !!e.type.__asyncLoader;/*! #__NO_SIDE_EFFECTS__ */function X(e) { ee(e) && (e = { loader: e }); const { loader: t, loadingComponent: n, errorComponent: s, delay: o = 200, hydrate: r, timeout: i, suspensible: a = !0, onError: c } = e; let u = null, l, f = 0; const h = () => (f++, u = null, p()), p = () => { let _; return u || (_ = u = t().catch(g => { if (g = g instanceof Error ? g : new Error(String(g)), c) return new Promise((E, k) => { c(g, () => E(h()), () => k(g), f + 1) }); throw g }).then(g => _ !== u && u ? u : (g && (g.__esModule || g[Symbol.toStringTag] === "Module") && (g = g.default), l = g, g))) }; return vt({ name: "AsyncComponentWrapper", __asyncLoader: p, __asyncHydrate(_, g, E) { const k = r ? () => { const d = r(() => { E() }, y => Hh(_, y)); d && (g.bum || (g.bum = [])).push(d), (g.u || (g.u = [])).push(() => !0) } : E; l ? k() : p().then(() => !g.isUnmounted && k()) }, get __asyncResolved() { return l }, setup() { const _ = Pe; if (li(_), l) return () => Qo(l, _); const g = d => { u = null, Dn(d, _, 13, !s) }; if (a && _.suspense || In) return p().then(d => () => Qo(d, _)).catch(d => (g(d), () => s ? he(s, { error: d }) : null)); const E = $e(!1), k = $e(), w = $e(!!o); return o && setTimeout(() => { w.value = !1 }, o), i != null && setTimeout(() => { if (!E.value && !k.value) { const d = new Error(`Async component timed out after ${i}ms.`); g(d), k.value = d } }, i), p().then(() => { E.value = !0, _.parent && bs(_.parent.vnode) && _.parent.update() }).catch(d => { g(d), k.value = d }), () => { if (E.value && l) return Qo(l, _); if (k.value && s) return he(s, { error: k.value }); if (n && !w.value) return he(n) } } }) } function Qo(e, t) { const { ref: n, props: s, children: o, ce: r } = t.vnode, i = he(e, s, o); return i.ref = n, i.ce = r, delete t.vnode.ce, i } const bs = e => e.type.__isKeepAlive, Dh = { name: "KeepAlive", __isKeepAlive: !0, props: { include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number] }, setup(e, { slots: t }) { const n = Je(), s = n.ctx; if (!s.renderer) return () => { const w = t.default && t.default(); return w && w.length === 1 ? w[0] : w }; const o = new Map, r = new Set; let i = null; const a = n.suspense, { renderer: { p: c, m: u, um: l, o: { createElement: f } } } = s, h = f("div"); s.activate = (w, d, y, x, T) => { const S = w.component; u(w, d, y, 0, a), c(S.vnode, w, d, y, S, a, x, w.slotScopeIds, T), Te(() => { S.isDeactivated = !1, S.a && xn(S.a); const F = w.props && w.props.onVnodeMounted; F && Ve(F, S.parent, w) }, a) }, s.deactivate = w => { const d = w.component; io(d.m), io(d.a), u(w, h, null, 1, a), Te(() => { d.da && xn(d.da); const y = w.props && w.props.onVnodeUnmounted; y && Ve(y, d.parent, w), d.isDeactivated = !0 }, a) }; function p(w) { Jo(w), l(w, n, a, !0) } function _(w) { o.forEach((d, y) => { const x = Cr(d.type); x && !w(x) && g(y) }) } function g(w) { const d = o.get(w); d && (!i || !at(d, i)) ? p(d) : i && Jo(i), o.delete(w), r.delete(w) } bt(() => [e.include, e.exclude], ([w, d]) => { w && _(y => qn(w, y)), d && _(y => !qn(d, y)) }, { flush: "post", deep: !0 }); let E = null; const k = () => { E != null && (ao(n.subTree.type) ? Te(() => { o.set(E, Ls(n.subTree)) }, n.subTree.suspense) : o.set(E, Ls(n.subTree))) }; return hn(k), ui(k), vs(() => { o.forEach(w => { const { subTree: d, suspense: y } = n, x = Ls(d); if (w.type === x.type && w.key === x.key) { Jo(x); const T = x.component.da; T && Te(T, y); return } p(w) }) }), () => { if (E = null, !t.default) return i = null; const w = t.default(), d = w[0]; if (w.length > 1) return i = null, w; if (!Yt(d) || !(d.shapeFlag & 4) && !(d.shapeFlag & 128)) return i = null, d; let y = Ls(d); if (y.type === ke) return i = null, y; const x = y.type, T = Cr(Kt(y) ? y.type.__asyncResolved || {} : x), { include: S, exclude: F, max: O } = e; if (S && (!T || !qn(S, T)) || F && T && qn(F, T)) return y.shapeFlag &= -257, i = y, d; const I = y.key == null ? x : y.key, q = o.get(I); return y.el && (y = Lt(y), d.shapeFlag & 128 && (d.ssContent = y)), E = I, q ? (y.el = q.el, y.component = q.component, y.transition && Gt(y, y.transition), y.shapeFlag |= 512, r.delete(I), r.add(I)) : (r.add(I), O && r.size > parseInt(O, 10) && g(r.values().next().value)), y.shapeFlag |= 256, i = y, ao(d.type) ? d : y } } }, Fh = Dh; function qn(e, t) { return z(e) ? e.some(n => qn(n, t)) : _e(e) ? e.split(",").includes(t) : Cf(e) ? (e.lastIndex = 0, e.test(t)) : !1 } function fl(e, t) { dl(e, "a", t) } function hl(e, t) { dl(e, "da", t) } function dl(e, t, n = Pe) { const s = e.__wdc || (e.__wdc = () => { let o = n; for (; o;) { if (o.isDeactivated) return; o = o.parent } return e() }); if (No(t, s, n), n) { let o = n.parent; for (; o && o.parent;)bs(o.parent.vnode) && $h(s, t, n, o), o = o.parent } } function $h(e, t, n, s) { const o = No(t, e, s, !0); ws(() => { Zr(s[t], o) }, n) } function Jo(e) { e.shapeFlag &= -257, e.shapeFlag &= -513 } function Ls(e) { return e.shapeFlag & 128 ? e.ssContent : e } function No(e, t, n = Pe, s = !1) { if (n) { const o = n[e] || (n[e] = []), r = t.__weh || (t.__weh = (...i) => { It(); const a = ln(n), c = ut(t, n, e, i); return a(), Ot(), c }); return s ? o.unshift(r) : o.push(r), r } } const Nt = e => (t, n = Pe) => { (!In || e === "sp") && No(e, (...s) => t(...s), n) }, jh = Nt("bm"), hn = Nt("m"), pl = Nt("bu"), ui = Nt("u"), vs = Nt("bum"), ws = Nt("um"), Uh = Nt("sp"), Vh = Nt("rtg"), Bh = Nt("rtc"); function gl(e, t = Pe) { No("ec", e, t) } const fi = "components", Wh = "directives"; function Pv(e, t) { return hi(fi, e, !0, t) || e } const ml = Symbol.for("v-ndc"); function Kh(e) { return _e(e) ? hi(fi, e, !1) || e : e || ml } function Sv(e) { return hi(Wh, e) } function hi(e, t, n = !0, s = !1) { const o = Se || Pe; if (o) { const r = o.type; if (e === fi) { const a = Cr(r, !1); if (a && (a === t || a === Le(t) || a === Po(Le(t)))) return r } const i = qi(o[e] || r[e], t) || qi(o.appContext[e], t); return !i && s ? r : i } } function qi(e, t) { return e && (e[t] || e[Le(t)] || e[Po(Le(t))]) } function Cv(e, t, n, s) { let o; const r = n && n[s], i = z(e); if (i || _e(e)) { const a = i && nn(e); let c = !1, u = !1; a && (c = !nt(e), u = Mt(e), e = Io(e)), o = new Array(e.length); for (let l = 0, f = e.length; l < f; l++)o[l] = t(c ? u ? eo(Re(e[l])) : Re(e[l]) : e[l], l, void 0, r && r[l]) } else if (typeof e == "number") { o = new Array(e); for (let a = 0; a < e; a++)o[a] = t(a + 1, a, void 0, r && r[a]) } else if (de(e)) if (e[Symbol.iterator]) o = Array.from(e, (a, c) => t(a, c, void 0, r && r[c])); else { const a = Object.keys(e); o = new Array(a.length); for (let c = 0, u = a.length; c < u; c++) { const l = a[c]; o[c] = t(e[l], l, c, r && r[c]) } } else o = []; return n && (n[s] = o), o } function Rv(e, t) { for (let n = 0; n < t.length; n++) { const s = t[n]; if (z(s)) for (let o = 0; o < s.length; o++)e[s[o].name] = s[o].fn; else s && (e[s.name] = s.key ? (...o) => { const r = s.fn(...o); return r && (r.key = s.key), r } : s.fn) } return e } function Av(e, t, n = {}, s, o) { if (Se.ce || Se.parent && Kt(Se.parent) && Se.parent.ce) return t !== "default" && (n.name = t), Fe(), St(Ce, null, [he("slot", n, s && s())], 64); let r = e[t]; r && r._c && (r._d = !1), Fe(); const i = r && di(r(n)), a = n.key || i && i.key, c = St(Ce, { key: (a && !lt(a) ? a : `_${t}`) + (!i && s ? "_fb" : "") }, i || (s ? s() : []), i && e._ === 1 ? 64 : -2); return !o && c.scopeId && (c.slotScopeIds = [c.scopeId + "-s"]), r && r._c && (r._d = !0), c } function di(e) { return e.some(t => Yt(t) ? !(t.type === ke || t.type === Ce && !di(t.children)) : !0) ? e : null } function Iv(e, t) { const n = {}; for (const s in e) n[t && /[A-Z]/.test(s) ? `on:${s}` : js(s)] = e[s]; return n } const _r = e => e ? Bl(e) ? xs(e) : _r(e.parent) : null, Xn = pe(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => _r(e.parent), $root: e => _r(e.root), $host: e => e.ce, $emit: e => e.emit, $options: e => pi(e), $forceUpdate: e => e.f || (e.f = () => { ii(e.update) }), $nextTick: e => e.n || (e.n = qt.bind(e.proxy)), $watch: e => dd.bind(e) }), Xo = (e, t) => e !== oe && !e.__isScriptSetup && le(e, t), br = { get({ _: e }, t) { if (t === "__v_skip") return !0; const { ctx: n, setupState: s, data: o, props: r, accessCache: i, type: a, appContext: c } = e; let u; if (t[0] !== "$") { const p = i[t]; if (p !== void 0) switch (p) { case 1: return s[t]; case 2: return o[t]; case 4: return n[t]; case 3: return r[t] } else { if (Xo(s, t)) return i[t] = 1, s[t]; if (o !== oe && le(o, t)) return i[t] = 2, o[t]; if ((u = e.propsOptions[0]) && le(u, t)) return i[t] = 3, r[t]; if (n !== oe && le(n, t)) return i[t] = 4, n[t]; vr && (i[t] = 0) } } const l = Xn[t]; let f, h; if (l) return t === "$attrs" && Oe(e.attrs, "get", ""), l(e); if ((f = a.__cssModules) && (f = f[t])) return f; if (n !== oe && le(n, t)) return i[t] = 4, n[t]; if (h = c.config.globalProperties, le(h, t)) return h[t] }, set({ _: e }, t, n) { const { data: s, setupState: o, ctx: r } = e; return Xo(o, t) ? (o[t] = n, !0) : s !== oe && le(s, t) ? (s[t] = n, !0) : le(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (r[t] = n, !0) }, has({ _: { data: e, setupState: t, accessCache: n, ctx: s, appContext: o, propsOptions: r } }, i) { let a; return !!n[i] || e !== oe && le(e, i) || Xo(t, i) || (a = r[0]) && le(a, i) || le(s, i) || le(Xn, i) || le(o.config.globalProperties, i) }, defineProperty(e, t, n) { return n.get != null ? e._.accessCache[t] = 0 : le(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n) } }, zh = pe({}, br, { get(e, t) { if (t !== Symbol.unscopables) return br.get(e, t, e) }, has(e, t) { return t[0] !== "_" && !Mf(t) } }); function Ov() { return null } function Mv() { return null } function Lv(e) { } function Nv(e) { } function Hv() { return null } function Dv() { } function Fv(e, t) { return null } function $v() { return yl().slots } function jv() { return yl().attrs } function yl() { const e = Je(); return e.setupContext || (e.setupContext = zl(e)) } function ls(e) { return z(e) ? e.reduce((t, n) => (t[n] = null, t), {}) : e } function Uv(e, t) { const n = ls(e); for (const s in t) { if (s.startsWith("__skip")) continue; let o = n[s]; o ? z(o) || ee(o) ? o = n[s] = { type: o, default: t[s] } : o.default = t[s] : o === null && (o = n[s] = { default: t[s] }), o && t[`__skip_${s}`] && (o.skipFactory = !0) } return n } function Vv(e, t) { return !e || !t ? e || t : z(e) && z(t) ? e.concat(t) : pe({}, ls(e), ls(t)) } function Bv(e, t) { const n = {}; for (const s in e) t.includes(s) || Object.defineProperty(n, s, { enumerable: !0, get: () => e[s] }); return n } function Wv(e) { const t = Je(); let n = e(); return Tr(), ei(n) && (n = n.catch(s => { throw ln(t), s })), [n, () => ln(t)] } let vr = !0; function qh(e) { const t = pi(e), n = e.proxy, s = e.ctx; vr = !1, t.beforeCreate && Gi(t.beforeCreate, e, "bc"); const { data: o, computed: r, methods: i, watch: a, provide: c, inject: u, created: l, beforeMount: f, mounted: h, beforeUpdate: p, updated: _, activated: g, deactivated: E, beforeDestroy: k, beforeUnmount: w, destroyed: d, unmounted: y, render: x, renderTracked: T, renderTriggered: S, errorCaptured: F, serverPrefetch: O, expose: I, inheritAttrs: q, components: A, directives: W, filters: ne } = t; if (u && Gh(u, s, null), i) for (const Z in i) { const v = i[Z]; ee(v) && (s[Z] = v.bind(n)) } if (o) { const Z = o.call(n, n); de(Z) && (e.data = ht(Z)) } if (vr = !0, r) for (const Z in r) { const v = r[Z], L = ee(v) ? v.bind(n, n) : ee(v.get) ? v.get.bind(n, n) : tt, se = !ee(v) && ee(v.set) ? v.set.bind(n) : tt, Ee = et({ get: L, set: se }); Object.defineProperty(s, Z, { enumerable: !0, configurable: !0, get: () => Ee.value, set: ve => Ee.value = ve }) } if (a) for (const Z in a) _l(a[Z], s, n, Z); if (c) { const Z = ee(c) ? c.call(n) : c; Reflect.ownKeys(Z).forEach(v => { Sn(v, Z[v]) }) } l && Gi(l, e, "c"); function K(Z, v) { z(v) ? v.forEach(L => Z(L.bind(n))) : v && Z(v.bind(n)) } if (K(jh, f), K(hn, h), K(pl, p), K(ui, _), K(fl, g), K(hl, E), K(gl, F), K(Bh, T), K(Vh, S), K(vs, w), K(ws, y), K(Uh, O), z(I)) if (I.length) { const Z = e.exposed || (e.exposed = {}); I.forEach(v => { Object.defineProperty(Z, v, { get: () => n[v], set: L => n[v] = L }) }) } else e.exposed || (e.exposed = {}); x && e.render === tt && (e.render = x), q != null && (e.inheritAttrs = q), A && (e.components = A), W && (e.directives = W), O && li(e) } function Gh(e, t, n = tt) { z(e) && (e = wr(e)); for (const s in e) { const o = e[s]; let r; de(o) ? "default" in o ? r = ze(o.from || s, o.default, !0) : r = ze(o.from || s) : r = ze(o), xe(r) ? Object.defineProperty(t, s, { enumerable: !0, configurable: !0, get: () => r.value, set: i => r.value = i }) : t[s] = r } } function Gi(e, t, n) { ut(z(e) ? e.map(s => s.bind(t.proxy)) : e.bind(t.proxy), t, n) } function _l(e, t, n, s) { let o = s.includes(".") ? Il(n, s) : () => n[s]; if (_e(e)) { const r = t[e]; ee(r) && bt(o, r) } else if (ee(e)) bt(o, e.bind(n)); else if (de(e)) if (z(e)) e.forEach(r => _l(r, t, n, s)); else { const r = ee(e.handler) ? e.handler.bind(n) : t[e.handler]; ee(r) && bt(o, r, e) } } function pi(e) { const t = e.type, { mixins: n, extends: s } = t, { mixins: o, optionsCache: r, config: { optionMergeStrategies: i } } = e.appContext, a = r.get(t); let c; return a ? c = a : !o.length && !n && !s ? c = t : (c = {}, o.length && o.forEach(u => ro(c, u, i, !0)), ro(c, t, i)), de(t) && r.set(t, c), c } function ro(e, t, n, s = !1) { const { mixins: o, extends: r } = t; r && ro(e, r, n, !0), o && o.forEach(i => ro(e, i, n, !0)); for (const i in t) if (!(s && i === "expose")) { const a = Yh[i] || n && n[i]; e[i] = a ? a(e[i], t[i]) : t[i] } return e } const Yh = { data: Yi, props: Qi, emits: Qi, methods: Gn, computed: Gn, beforeCreate: Ne, created: Ne, beforeMount: Ne, mounted: Ne, beforeUpdate: Ne, updated: Ne, beforeDestroy: Ne, beforeUnmount: Ne, destroyed: Ne, unmounted: Ne, activated: Ne, deactivated: Ne, errorCaptured: Ne, serverPrefetch: Ne, components: Gn, directives: Gn, watch: Jh, provide: Yi, inject: Qh }; function Yi(e, t) { return t ? e ? function () { return pe(ee(e) ? e.call(this, this) : e, ee(t) ? t.call(this, this) : t) } : t : e } function Qh(e, t) { return Gn(wr(e), wr(t)) } function wr(e) { if (z(e)) { const t = {}; for (let n = 0; n < e.length; n++)t[e[n]] = e[n]; return t } return e } function Ne(e, t) { return e ? [...new Set([].concat(e, t))] : t } function Gn(e, t) { return e ? pe(Object.create(null), e, t) : t } function Qi(e, t) { return e ? z(e) && z(t) ? [...new Set([...e, ...t])] : pe(Object.create(null), ls(e), ls(t ?? {})) : t } function Jh(e, t) { if (!e) return t; if (!t) return e; const n = pe(Object.create(null), e); for (const s in t) n[s] = Ne(e[s], t[s]); return n } function bl() { return { app: null, config: { isNativeTag: Pf, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let Xh = 0; function Zh(e, t) { return function (s, o = null) { ee(s) || (s = pe({}, s)), o != null && !de(o) && (o = null); const r = bl(), i = new WeakSet, a = []; let c = !1; const u = r.app = { _uid: Xh++, _component: s, _props: o, _container: null, _context: r, _instance: null, version: Ld, get config() { return r.config }, set config(l) { }, use(l, ...f) { return i.has(l) || (l && ee(l.install) ? (i.add(l), l.install(u, ...f)) : ee(l) && (i.add(l), l(u, ...f))), u }, mixin(l) { return r.mixins.includes(l) || r.mixins.push(l), u }, component(l, f) { return f ? (r.components[l] = f, u) : r.components[l] }, directive(l, f) { return f ? (r.directives[l] = f, u) : r.directives[l] }, mount(l, f, h) { if (!c) { const p = u._ceVNode || he(s, o); return p.appContext = r, h === !0 ? h = "svg" : h === !1 && (h = void 0), f && t ? t(p, l) : e(p, l, h), c = !0, u._container = l, l.__vue_app__ = u, xs(p.component) } }, onUnmount(l) { a.push(l) }, unmount() { c && (ut(a, u._instance, 16), e(null, u._container), delete u._container.__vue_app__) }, provide(l, f) { return r.provides[l] = f, u }, runWithContext(l) { const f = sn; sn = u; try { return l() } finally { sn = f } } }; return u } } let sn = null; function Sn(e, t) { if (Pe) { let n = Pe.provides; const s = Pe.parent && Pe.parent.provides; s === n && (n = Pe.provides = Object.create(s)), n[e] = t } } function ze(e, t, n = !1) { const s = Pe || Se; if (s || sn) { let o = sn ? sn._context.provides : s ? s.parent == null || s.ce ? s.vnode.appContext && s.vnode.appContext.provides : s.parent.provides : void 0; if (o && e in o) return o[e]; if (arguments.length > 1) return n && ee(t) ? t.call(s && s.proxy) : t } } function Ho() { return !!(Pe || Se || sn) } const vl = {}, wl = () => Object.create(vl), El = e => Object.getPrototypeOf(e) === vl; function ed(e, t, n, s = !1) { const o = {}, r = wl(); e.propsDefaults = Object.create(null), kl(e, t, o, r); for (const i in e.propsOptions[0]) i in o || (o[i] = void 0); n ? e.props = s ? o : Rt(o) : e.type.props ? e.props = o : e.props = r, e.attrs = r } function td(e, t, n, s) { const { props: o, attrs: r, vnode: { patchFlag: i } } = e, a = ae(o), [c] = e.propsOptions; let u = !1; if ((s || i > 0) && !(i & 16)) { if (i & 8) { const l = e.vnode.dynamicProps; for (let f = 0; f < l.length; f++) { let h = l[f]; if (Do(e.emitsOptions, h)) continue; const p = t[h]; if (c) if (le(r, h)) p !== r[h] && (r[h] = p, u = !0); else { const _ = Le(h); o[_] = Er(c, a, _, p, e, !1) } else p !== r[h] && (r[h] = p, u = !0) } } } else { kl(e, t, o, r) && (u = !0); let l; for (const f in a) (!t || !le(t, f) && ((l = We(f)) === f || !le(t, l))) && (c ? n && (n[f] !== void 0 || n[l] !== void 0) && (o[f] = Er(c, a, f, void 0, e, !0)) : delete o[f]); if (r !== a) for (const f in r) (!t || !le(t, f)) && (delete r[f], u = !0) } u && Tt(e.attrs, "set", "") } function kl(e, t, n, s) { const [o, r] = e.propsOptions; let i = !1, a; if (t) for (let c in t) { if (kn(c)) continue; const u = t[c]; let l; o && le(o, l = Le(c)) ? !r || !r.includes(l) ? n[l] = u : (a || (a = {}))[l] = u : Do(e.emitsOptions, c) || (!(c in s) || u !== s[c]) && (s[c] = u, i = !0) } if (r) { const c = ae(n), u = a || oe; for (let l = 0; l < r.length; l++) { const f = r[l]; n[f] = Er(o, c, f, u[f], e, !le(u, f)) } } return i } function Er(e, t, n, s, o, r) { const i = e[n]; if (i != null) { const a = le(i, "default"); if (a && s === void 0) { const c = i.default; if (i.type !== Function && !i.skipFactory && ee(c)) { const { propsDefaults: u } = o; if (n in u) s = u[n]; else { const l = ln(o); s = u[n] = c.call(null, t), l() } } else s = c; o.ce && o.ce._setProp(n, s) } i[0] && (r && !a ? s = !1 : i[1] && (s === "" || s === We(n)) && (s = !0)) } return s } const nd = new WeakMap; function xl(e, t, n = !1) { const s = n ? nd : t.propsCache, o = s.get(e); if (o) return o; const r = e.props, i = {}, a = []; let c = !1; if (!ee(e)) { const l = f => { c = !0; const [h, p] = xl(f, t, !0); pe(i, h), p && a.push(...p) }; !n && t.mixins.length && t.mixins.forEach(l), e.extends && l(e.extends), e.mixins && e.mixins.forEach(l) } if (!r && !c) return de(e) && s.set(e, wn), wn; if (z(r)) for (let l = 0; l < r.length; l++) { const f = Le(r[l]); Ji(f) && (i[f] = oe) } else if (r) for (const l in r) { const f = Le(l); if (Ji(f)) { const h = r[l], p = i[f] = z(h) || ee(h) ? { type: h } : pe({}, h), _ = p.type; let g = !1, E = !0; if (z(_)) for (let k = 0; k < _.length; ++k) { const w = _[k], d = ee(w) && w.name; if (d === "Boolean") { g = !0; break } else d === "String" && (E = !1) } else g = ee(_) && _.name === "Boolean"; p[0] = g, p[1] = E, (g || le(p, "default")) && a.push(f) } } const u = [i, a]; return de(e) && s.set(e, u), u } function Ji(e) { return e[0] !== "$" && !kn(e) } const gi = e => e[0] === "_" || e === "$stable", mi = e => z(e) ? e.map(Be) : [Be(e)], sd = (e, t, n) => { if (t._n) return t; const s = ai((...o) => mi(t(...o)), n); return s._c = !1, s }, Tl = (e, t, n) => { const s = e._ctx; for (const o in e) { if (gi(o)) continue; const r = e[o]; if (ee(r)) t[o] = sd(o, r, s); else if (r != null) { const i = mi(r); t[o] = () => i } } }, Pl = (e, t) => { const n = mi(t); e.slots.default = () => n }, Sl = (e, t, n) => { for (const s in t) (n || !gi(s)) && (e[s] = t[s]) }, od = (e, t, n) => { const s = e.slots = wl(); if (e.vnode.shapeFlag & 32) { const o = t.__; o && dr(s, "__", o, !0); const r = t._; r ? (Sl(s, t, n), n && dr(s, "_", r, !0)) : Tl(t, s) } else t && Pl(e, t) }, rd = (e, t, n) => { const { vnode: s, slots: o } = e; let r = !0, i = oe; if (s.shapeFlag & 32) { const a = t._; a ? n && a === 1 ? r = !1 : Sl(o, t, n) : (r = !t.$stable, Tl(t, o)), i = t } else t && (Pl(e, t), i = { default: 1 }); if (r) for (const a in o) !gi(a) && i[a] == null && delete o[a] }, Te = Hl; function id(e) { return Cl(e) } function ad(e) { return Cl(e, Ih) } function Cl(e, t) { const n = So(); n.__VUE__ = !0; const { insert: s, remove: o, patchProp: r, createElement: i, createText: a, createComment: c, setText: u, setElementText: l, parentNode: f, nextSibling: h, setScopeId: p = tt, insertStaticContent: _ } = e, g = (m, b, P, M = null, C = null, N = null, U = void 0, $ = null, D = !!b.dynamicChildren) => { if (m === b) return; m && !at(m, b) && (M = R(m), ve(m, C, N, !0), m = null), b.patchFlag === -2 && (D = !1, b.dynamicChildren = null); const { type: H, ref: Q, shapeFlag: V } = b; switch (H) { case on: E(m, b, P, M); break; case ke: k(m, b, P, M); break; case Rn: m == null && w(b, P, M, U); break; case Ce: A(m, b, P, M, C, N, U, $, D); break; default: V & 1 ? x(m, b, P, M, C, N, U, $, D) : V & 6 ? W(m, b, P, M, C, N, U, $, D) : (V & 64 || V & 128) && H.process(m, b, P, M, C, N, U, $, D, G) }Q != null && C ? Pn(Q, m && m.ref, N, b || m, !b) : Q == null && m && m.ref != null && Pn(m.ref, null, N, m, !0) }, E = (m, b, P, M) => { if (m == null) s(b.el = a(b.children), P, M); else { const C = b.el = m.el; b.children !== m.children && u(C, b.children) } }, k = (m, b, P, M) => { m == null ? s(b.el = c(b.children || ""), P, M) : b.el = m.el }, w = (m, b, P, M) => { [m.el, m.anchor] = _(m.children, b, P, M, m.el, m.anchor) }, d = ({ el: m, anchor: b }, P, M) => { let C; for (; m && m !== b;)C = h(m), s(m, P, M), m = C; s(b, P, M) }, y = ({ el: m, anchor: b }) => { let P; for (; m && m !== b;)P = h(m), o(m), m = P; o(b) }, x = (m, b, P, M, C, N, U, $, D) => { b.type === "svg" ? U = "svg" : b.type === "math" && (U = "mathml"), m == null ? T(b, P, M, C, N, U, $, D) : O(m, b, C, N, U, $, D) }, T = (m, b, P, M, C, N, U, $) => { let D, H; const { props: Q, shapeFlag: V, transition: Y, dirs: te } = m; if (D = m.el = i(m.type, N, Q && Q.is, Q), V & 8 ? l(D, m.children) : V & 16 && F(m.children, D, null, M, C, Zo(m, N), U, $), te && _t(m, null, M, "created"), S(D, m, m.scopeId, U, M), Q) { for (const me in Q) me !== "value" && !kn(me) && r(D, me, null, Q[me], N, M); "value" in Q && r(D, "value", null, Q.value, N), (H = Q.onVnodeBeforeMount) && Ve(H, M, m) } te && _t(m, null, M, "beforeMount"); const re = Rl(C, Y); re && Y.beforeEnter(D), s(D, b, P), ((H = Q && Q.onVnodeMounted) || re || te) && Te(() => { H && Ve(H, M, m), re && Y.enter(D), te && _t(m, null, M, "mounted") }, C) }, S = (m, b, P, M, C) => { if (P && p(m, P), M) for (let N = 0; N < M.length; N++)p(m, M[N]); if (C) { let N = C.subTree; if (b === N || ao(N.type) && (N.ssContent === b || N.ssFallback === b)) { const U = C.vnode; S(m, U, U.scopeId, U.slotScopeIds, C.parent) } } }, F = (m, b, P, M, C, N, U, $, D = 0) => { for (let H = D; H < m.length; H++) { const Q = m[H] = $ ? Bt(m[H]) : Be(m[H]); g(null, Q, b, P, M, C, N, U, $) } }, O = (m, b, P, M, C, N, U) => { const $ = b.el = m.el; let { patchFlag: D, dynamicChildren: H, dirs: Q } = b; D |= m.patchFlag & 16; const V = m.props || oe, Y = b.props || oe; let te; if (P && Jt(P, !1), (te = Y.onVnodeBeforeUpdate) && Ve(te, P, b, m), Q && _t(b, m, P, "beforeUpdate"), P && Jt(P, !0), (V.innerHTML && Y.innerHTML == null || V.textContent && Y.textContent == null) && l($, ""), H ? I(m.dynamicChildren, H, $, P, M, Zo(b, C), N) : U || v(m, b, $, null, P, M, Zo(b, C), N, !1), D > 0) { if (D & 16) q($, V, Y, P, C); else if (D & 2 && V.class !== Y.class && r($, "class", null, Y.class, C), D & 4 && r($, "style", V.style, Y.style, C), D & 8) { const re = b.dynamicProps; for (let me = 0; me < re.length; me++) { const fe = re[me], Ue = V[fe], Ae = Y[fe]; (Ae !== Ue || fe === "value") && r($, fe, Ue, Ae, C, P) } } D & 1 && m.children !== b.children && l($, b.children) } else !U && H == null && q($, V, Y, P, C); ((te = Y.onVnodeUpdated) || Q) && Te(() => { te && Ve(te, P, b, m), Q && _t(b, m, P, "updated") }, M) }, I = (m, b, P, M, C, N, U) => { for (let $ = 0; $ < b.length; $++) { const D = m[$], H = b[$], Q = D.el && (D.type === Ce || !at(D, H) || D.shapeFlag & 198) ? f(D.el) : P; g(D, H, Q, null, M, C, N, U, !0) } }, q = (m, b, P, M, C) => { if (b !== P) { if (b !== oe) for (const N in b) !kn(N) && !(N in P) && r(m, N, b[N], null, C, M); for (const N in P) { if (kn(N)) continue; const U = P[N], $ = b[N]; U !== $ && N !== "value" && r(m, N, $, U, C, M) } "value" in P && r(m, "value", b.value, P.value, C) } }, A = (m, b, P, M, C, N, U, $, D) => { const H = b.el = m ? m.el : a(""), Q = b.anchor = m ? m.anchor : a(""); let { patchFlag: V, dynamicChildren: Y, slotScopeIds: te } = b; te && ($ = $ ? $.concat(te) : te), m == null ? (s(H, P, M), s(Q, P, M), F(b.children || [], P, Q, C, N, U, $, D)) : V > 0 && V & 64 && Y && m.dynamicChildren ? (I(m.dynamicChildren, Y, P, C, N, U, $), (b.key != null || C && b === C.subTree) && yi(m, b, !0)) : v(m, b, P, Q, C, N, U, $, D) }, W = (m, b, P, M, C, N, U, $, D) => { b.slotScopeIds = $, m == null ? b.shapeFlag & 512 ? C.ctx.activate(b, P, M, U, D) : ne(b, P, M, C, N, U, D) : ie(m, b, D) }, ne = (m, b, P, M, C, N, U) => { const $ = m.component = Vl(m, M, C); if (bs(m) && ($.ctx.renderer = G), Wl($, !1, U), $.asyncDep) { if (C && C.registerDep($, K, U), !m.el) { const D = $.subTree = he(ke); k(null, D, b, P) } } else K($, m, b, P, C, N, U) }, ie = (m, b, P) => { const M = b.component = m.component; if (_d(m, b, P)) if (M.asyncDep && !M.asyncResolved) { Z(M, b, P); return } else M.next = b, M.update(); else b.el = m.el, M.vnode = b }, K = (m, b, P, M, C, N, U) => { const $ = () => { if (m.isMounted) { let { next: V, bu: Y, u: te, parent: re, vnode: me } = m; { const Ge = Al(m); if (Ge) { V && (V.el = me.el, Z(m, V, U)), Ge.asyncDep.then(() => { m.isUnmounted || $() }); return } } let fe = V, Ue; Jt(m, !1), V ? (V.el = me.el, Z(m, V, U)) : V = me, Y && xn(Y), (Ue = V.props && V.props.onVnodeBeforeUpdate) && Ve(Ue, re, V, me), Jt(m, !0); const Ae = Vs(m), rt = m.subTree; m.subTree = Ae, g(rt, Ae, f(rt.el), R(rt), m, C, N), V.el = Ae.el, fe === null && Fo(m, Ae.el), te && Te(te, C), (Ue = V.props && V.props.onVnodeUpdated) && Te(() => Ve(Ue, re, V, me), C) } else { let V; const { el: Y, props: te } = b, { bm: re, m: me, parent: fe, root: Ue, type: Ae } = m, rt = Kt(b); if (Jt(m, !1), re && xn(re), !rt && (V = te && te.onVnodeBeforeMount) && Ve(V, fe, b), Jt(m, !0), Y && ge) { const Ge = () => { m.subTree = Vs(m), ge(Y, m.subTree, m, C, null) }; rt && Ae.__asyncHydrate ? Ae.__asyncHydrate(Y, m, Ge) : Ge() } else { Ue.ce && Ue.ce._def.shadowRoot !== !1 && Ue.ce._injectChildStyle(Ae); const Ge = m.subTree = Vs(m); g(null, Ge, P, M, m, C, N), b.el = Ge.el } if (me && Te(me, C), !rt && (V = te && te.onVnodeMounted)) { const Ge = b; Te(() => Ve(V, fe, Ge), C) } (b.shapeFlag & 256 || fe && Kt(fe.vnode) && fe.vnode.shapeFlag & 256) && m.a && Te(m.a, C), m.isMounted = !0, b = P = M = null } }; m.scope.on(); const D = m.effect = new Xs($); m.scope.off(); const H = m.update = D.run.bind(D), Q = m.job = D.runIfDirty.bind(D); Q.i = m, Q.id = m.uid, D.scheduler = () => ii(Q), Jt(m, !0), H() }, Z = (m, b, P) => { b.component = m; const M = m.vnode.props; m.vnode = b, m.next = null, td(m, b.props, M, P), rd(m, b.children, P), It(), ji(m), Ot() }, v = (m, b, P, M, C, N, U, $, D = !1) => { const H = m && m.children, Q = m ? m.shapeFlag : 0, V = b.children, { patchFlag: Y, shapeFlag: te } = b; if (Y > 0) { if (Y & 128) { se(H, V, P, M, C, N, U, $, D); return } else if (Y & 256) { L(H, V, P, M, C, N, U, $, D); return } } te & 8 ? (Q & 16 && je(H, C, N), V !== H && l(P, V)) : Q & 16 ? te & 16 ? se(H, V, P, M, C, N, U, $, D) : je(H, C, N, !0) : (Q & 8 && l(P, ""), te & 16 && F(V, P, M, C, N, U, $, D)) }, L = (m, b, P, M, C, N, U, $, D) => { m = m || wn, b = b || wn; const H = m.length, Q = b.length, V = Math.min(H, Q); let Y; for (Y = 0; Y < V; Y++) { const te = b[Y] = D ? Bt(b[Y]) : Be(b[Y]); g(m[Y], te, P, null, C, N, U, $, D) } H > Q ? je(m, C, N, !0, !1, V) : F(b, P, M, C, N, U, $, D, V) }, se = (m, b, P, M, C, N, U, $, D) => { let H = 0; const Q = b.length; let V = m.length - 1, Y = Q - 1; for (; H <= V && H <= Y;) { const te = m[H], re = b[H] = D ? Bt(b[H]) : Be(b[H]); if (at(te, re)) g(te, re, P, null, C, N, U, $, D); else break; H++ } for (; H <= V && H <= Y;) { const te = m[V], re = b[Y] = D ? Bt(b[Y]) : Be(b[Y]); if (at(te, re)) g(te, re, P, null, C, N, U, $, D); else break; V--, Y-- } if (H > V) { if (H <= Y) { const te = Y + 1, re = te < Q ? b[te].el : M; for (; H <= Y;)g(null, b[H] = D ? Bt(b[H]) : Be(b[H]), P, re, C, N, U, $, D), H++ } } else if (H > Y) for (; H <= V;)ve(m[H], C, N, !0), H++; else { const te = H, re = H, me = new Map; for (H = re; H <= Y; H++) { const Ye = b[H] = D ? Bt(b[H]) : Be(b[H]); Ye.key != null && me.set(Ye.key, H) } let fe, Ue = 0; const Ae = Y - re + 1; let rt = !1, Ge = 0; const $n = new Array(Ae); for (H = 0; H < Ae; H++)$n[H] = 0; for (H = te; H <= V; H++) { const Ye = m[H]; if (Ue >= Ae) { ve(Ye, C, N, !0); continue } let pt; if (Ye.key != null) pt = me.get(Ye.key); else for (fe = re; fe <= Y; fe++)if ($n[fe - re] === 0 && at(Ye, b[fe])) { pt = fe; break } pt === void 0 ? ve(Ye, C, N, !0) : ($n[pt - re] = H + 1, pt >= Ge ? Ge = pt : rt = !0, g(Ye, b[pt], P, null, C, N, U, $, D), Ue++) } const Li = rt ? cd($n) : wn; for (fe = Li.length - 1, H = Ae - 1; H >= 0; H--) { const Ye = re + H, pt = b[Ye], Ni = Ye + 1 < Q ? b[Ye + 1].el : M; $n[H] === 0 ? g(null, pt, P, Ni, C, N, U, $, D) : rt && (fe < 0 || H !== Li[fe] ? Ee(pt, P, Ni, 2) : fe--) } } }, Ee = (m, b, P, M, C = null) => { const { el: N, type: U, transition: $, children: D, shapeFlag: H } = m; if (H & 6) { Ee(m.component.subTree, b, P, M); return } if (H & 128) { m.suspense.move(b, P, M); return } if (H & 64) { U.move(m, b, P, G); return } if (U === Ce) { s(N, b, P); for (let V = 0; V < D.length; V++)Ee(D[V], b, P, M); s(m.anchor, b, P); return } if (U === Rn) { d(m, b, P); return } if (M !== 2 && H & 1 && $) if (M === 0) $.beforeEnter(N), s(N, b, P), Te(() => $.enter(N), C); else { const { leave: V, delayLeave: Y, afterLeave: te } = $, re = () => { m.ctx.isUnmounted ? o(N) : s(N, b, P) }, me = () => { V(N, () => { re(), te && te() }) }; Y ? Y(N, re, me) : me() } else s(N, b, P) }, ve = (m, b, P, M = !1, C = !1) => { const { type: N, props: U, ref: $, children: D, dynamicChildren: H, shapeFlag: Q, patchFlag: V, dirs: Y, cacheIndex: te } = m; if (V === -2 && (C = !1), $ != null && (It(), Pn($, null, P, m, !0), Ot()), te != null && (b.renderCache[te] = void 0), Q & 256) { b.ctx.deactivate(m); return } const re = Q & 1 && Y, me = !Kt(m); let fe; if (me && (fe = U && U.onVnodeBeforeUnmount) && Ve(fe, b, m), Q & 6) Ht(m.component, P, M); else { if (Q & 128) { m.suspense.unmount(P, M); return } re && _t(m, null, b, "beforeUnmount"), Q & 64 ? m.type.remove(m, b, P, G, M) : H && !H.hasOnce && (N !== Ce || V > 0 && V & 64) ? je(H, b, P, !1, !0) : (N === Ce && V & 384 || !C && Q & 16) && je(D, b, P), M && dt(m) } (me && (fe = U && U.onVnodeUnmounted) || re) && Te(() => { fe && Ve(fe, b, m), re && _t(m, null, b, "unmounted") }, P) }, dt = m => { const { type: b, el: P, anchor: M, transition: C } = m; if (b === Ce) { ot(P, M); return } if (b === Rn) { y(m); return } const N = () => { o(P), C && !C.persisted && C.afterLeave && C.afterLeave() }; if (m.shapeFlag & 1 && C && !C.persisted) { const { leave: U, delayLeave: $ } = C, D = () => U(P, N); $ ? $(m.el, N, D) : D() } else N() }, ot = (m, b) => { let P; for (; m !== b;)P = h(m), o(m), m = P; o(b) }, Ht = (m, b, P) => { const { bum: M, scope: C, job: N, subTree: U, um: $, m: D, a: H, parent: Q, slots: { __: V } } = m; io(D), io(H), M && xn(M), Q && z(V) && V.forEach(Y => { Q.renderCache[Y] = void 0 }), C.stop(), N && (N.flags |= 8, ve(U, m, b, P)), $ && Te($, b), Te(() => { m.isUnmounted = !0 }, b), b && b.pendingBranch && !b.isUnmounted && m.asyncDep && !m.asyncResolved && m.suspenseId === b.pendingId && (b.deps--, b.deps === 0 && b.resolve()) }, je = (m, b, P, M = !1, C = !1, N = 0) => { for (let U = N; U < m.length; U++)ve(m[U], b, P, M, C) }, R = m => { if (m.shapeFlag & 6) return R(m.component.subTree); if (m.shapeFlag & 128) return m.suspense.next(); const b = h(m.anchor || m.el), P = b && b[nl]; return P ? h(P) : b }; let B = !1; const j = (m, b, P) => { m == null ? b._vnode && ve(b._vnode, null, null, !0) : g(b._vnode || null, m, b, null, null, null, P), b._vnode = m, B || (B = !0, ji(), oo(), B = !1) }, G = { p: g, um: ve, m: Ee, r: dt, mt: ne, mc: F, pc: v, pbc: I, n: R, o: e }; let ce, ge; return t && ([ce, ge] = t(G)), { render: j, hydrate: ce, createApp: Zh(j, ce) } } function Zo({ type: e, props: t }, n) { return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n } function Jt({ effect: e, job: t }, n) { n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5) } function Rl(e, t) { return (!e || e && !e.pendingBranch) && t && !t.persisted } function yi(e, t, n = !1) { const s = e.children, o = t.children; if (z(s) && z(o)) for (let r = 0; r < s.length; r++) { const i = s[r]; let a = o[r]; a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = o[r] = Bt(o[r]), a.el = i.el), !n && a.patchFlag !== -2 && yi(i, a)), a.type === on && (a.el = i.el), a.type === ke && !a.el && (a.el = i.el) } } function cd(e) { const t = e.slice(), n = [0]; let s, o, r, i, a; const c = e.length; for (s = 0; s < c; s++) { const u = e[s]; if (u !== 0) { if (o = n[n.length - 1], e[o] < u) { t[s] = o, n.push(s); continue } for (r = 0, i = n.length - 1; r < i;)a = r + i >> 1, e[n[a]] < u ? r = a + 1 : i = a; u < e[n[r]] && (r > 0 && (t[s] = n[r - 1]), n[r] = s) } } for (r = n.length, i = n[r - 1]; r-- > 0;)n[r] = i, i = t[i]; return n } function Al(e) { const t = e.subTree.component; if (t) return t.asyncDep && !t.asyncResolved ? t : Al(t) } function io(e) { if (e) for (let t = 0; t < e.length; t++)e[t].flags |= 8 } const ld = Symbol.for("v-scx"), ud = () => ze(ld); function fd(e, t) { return Es(e, null, t) } function Kv(e, t) { return Es(e, null, { flush: "post" }) } function hd(e, t) { return Es(e, null, { flush: "sync" }) } function bt(e, t, n) { return Es(e, t, n) } function Es(e, t, n = oe) { const { immediate: s, deep: o, flush: r, once: i } = n, a = pe({}, n), c = t && s || !t && r !== "post"; let u; if (In) { if (r === "sync") { const p = ud(); u = p.__watcherHandles || (p.__watcherHandles = []) } else if (!c) { const p = () => { }; return p.stop = tt, p.resume = tt, p.pause = tt, p } } const l = Pe; a.call = (p, _, g) => ut(p, l, _, g); let f = !1; r === "post" ? a.scheduler = p => { Te(p, l && l.suspense) } : r !== "sync" && (f = !0, a.scheduler = (p, _) => { _ ? p() : ii(p) }), a.augmentJob = p => { t && (p.flags |= 4), f && (p.flags |= 2, l && (p.id = l.uid, p.i = l)) }; const h = vh(e, t, a); return In && (u ? u.push(h) : c && h()), h } function dd(e, t, n) { const s = this.proxy, o = _e(e) ? e.includes(".") ? Il(s, e) : () => s[e] : e.bind(s, s); let r; ee(t) ? r = t : (r = t.handler, n = t); const i = ln(this), a = Es(o, r.bind(s), n); return i(), a } function Il(e, t) { const n = t.split("."); return () => { let s = e; for (let o = 0; o < n.length && s; o++)s = s[n[o]]; return s } } function zv(e, t, n = oe) { const s = Je(), o = Le(t), r = We(t), i = Ol(e, o), a = ph((c, u) => { let l, f = oe, h; return hd(() => { const p = e[o]; He(l, p) && (l = p, u()) }), { get() { return c(), n.get ? n.get(l) : l }, set(p) { const _ = n.set ? n.set(p) : p; if (!He(_, l) && !(f !== oe && He(p, f))) return; const g = s.vnode.props; g && (t in g || o in g || r in g) && (`onUpdate:${t}` in g || `onUpdate:${o}` in g || `onUpdate:${r}` in g) || (l = p, u()), s.emit(`update:${t}`, _), He(p, _) && He(p, f) && !He(_, h) && u(), f = p, h = _ } } }); return a[Symbol.iterator] = () => { let c = 0; return { next() { return c < 2 ? { value: c++ ? i || oe : a, done: !1 } : { done: !0 } } } }, a } const Ol = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${Le(t)}Modifiers`] || e[`${We(t)}Modifiers`]; function pd(e, t, ...n) { if (e.isUnmounted) return; const s = e.vnode.props || oe; let o = n; const r = t.startsWith("update:"), i = r && Ol(s, t.slice(7)); i && (i.trim && (o = n.map(l => _e(l) ? l.trim() : l)), i.number && (o = n.map(Qs))); let a, c = s[a = js(t)] || s[a = js(Le(t))]; !c && r && (c = s[a = js(We(t))]), c && ut(c, e, 6, o); const u = s[a + "Once"]; if (u) { if (!e.emitted) e.emitted = {}; else if (e.emitted[a]) return; e.emitted[a] = !0, ut(u, e, 6, o) } } function Ml(e, t, n = !1) { const s = t.emitsCache, o = s.get(e); if (o !== void 0) return o; const r = e.emits; let i = {}, a = !1; if (!ee(e)) { const c = u => { const l = Ml(u, t, !0); l && (a = !0, pe(i, l)) }; !n && t.mixins.length && t.mixins.forEach(c), e.extends && c(e.extends), e.mixins && e.mixins.forEach(c) } return !r && !a ? (de(e) && s.set(e, null), null) : (z(r) ? r.forEach(c => i[c] = null) : pe(i, r), de(e) && s.set(e, i), i) } function Do(e, t) { return !e || !ms(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), le(e, t[0].toLowerCase() + t.slice(1)) || le(e, We(t)) || le(e, t)) } function Vs(e) { const { type: t, vnode: n, proxy: s, withProxy: o, propsOptions: [r], slots: i, attrs: a, emit: c, render: u, renderCache: l, props: f, data: h, setupState: p, ctx: _, inheritAttrs: g } = e, E = as(e); let k, w; try { if (n.shapeFlag & 4) { const y = o || s, x = y; k = Be(u.call(x, y, l, f, p, h, _)), w = a } else { const y = t; k = Be(y.length > 1 ? y(f, { attrs: a, slots: i, emit: c }) : y(f, null)), w = t.props ? a : md(a) } } catch (y) { Zn.length = 0, Dn(y, e, 1), k = he(ke) } let d = k; if (w && g !== !1) { const y = Object.keys(w), { shapeFlag: x } = d; y.length && x & 7 && (r && y.some(Xr) && (w = yd(w, r)), d = Lt(d, w, !1, !0)) } return n.dirs && (d = Lt(d, null, !1, !0), d.dirs = d.dirs ? d.dirs.concat(n.dirs) : n.dirs), n.transition && Gt(d, n.transition), k = d, as(E), k } function gd(e, t = !0) { let n; for (let s = 0; s < e.length; s++) { const o = e[s]; if (Yt(o)) { if (o.type !== ke || o.children === "v-if") { if (n) return; n = o } } else return } return n } const md = e => { let t; for (const n in e) (n === "class" || n === "style" || ms(n)) && ((t || (t = {}))[n] = e[n]); return t }, yd = (e, t) => { const n = {}; for (const s in e) (!Xr(s) || !(s.slice(9) in t)) && (n[s] = e[s]); return n }; function _d(e, t, n) { const { props: s, children: o, component: r } = e, { props: i, children: a, patchFlag: c } = t, u = r.emitsOptions; if (t.dirs || t.transition) return !0; if (n && c >= 0) { if (c & 1024) return !0; if (c & 16) return s ? Xi(s, i, u) : !!i; if (c & 8) { const l = t.dynamicProps; for (let f = 0; f < l.length; f++) { const h = l[f]; if (i[h] !== s[h] && !Do(u, h)) return !0 } } } else return (o || a) && (!a || !a.$stable) ? !0 : s === i ? !1 : s ? i ? Xi(s, i, u) : !0 : !!i; return !1 } function Xi(e, t, n) { const s = Object.keys(t); if (s.length !== Object.keys(e).length) return !0; for (let o = 0; o < s.length; o++) { const r = s[o]; if (t[r] !== e[r] && !Do(n, r)) return !0 } return !1 } function Fo({ vnode: e, parent: t }, n) { for (; t;) { const s = t.subTree; if (s.suspense && s.suspense.activeBranch === e && (s.el = e.el), s === e) (e = t.vnode).el = n, t = t.parent; else break } } const ao = e => e.__isSuspense; let kr = 0; const bd = { name: "Suspense", __isSuspense: !0, process(e, t, n, s, o, r, i, a, c, u) { if (e == null) vd(t, n, s, o, r, i, a, c, u); else { if (r && r.deps > 0 && !e.suspense.isInFallback) { t.suspense = e.suspense, t.suspense.vnode = t, t.el = e.el; return } wd(e, t, n, s, o, i, a, c, u) } }, hydrate: Ed, normalize: kd }, Ll = bd; function us(e, t) { const n = e.props && e.props[t]; ee(n) && n() } function vd(e, t, n, s, o, r, i, a, c) { const { p: u, o: { createElement: l } } = c, f = l("div"), h = e.suspense = Nl(e, o, s, t, f, n, r, i, a, c); u(null, h.pendingBranch = e.ssContent, f, null, s, h, r, i), h.deps > 0 ? (us(e, "onPending"), us(e, "onFallback"), u(null, e.ssFallback, t, n, s, null, r, i), Cn(h, e.ssFallback)) : h.resolve(!1, !0) } function wd(e, t, n, s, o, r, i, a, { p: c, um: u, o: { createElement: l } }) { const f = t.suspense = e.suspense; f.vnode = t, t.el = e.el; const h = t.ssContent, p = t.ssFallback, { activeBranch: _, pendingBranch: g, isInFallback: E, isHydrating: k } = f; if (g) f.pendingBranch = h, at(h, g) ? (c(g, h, f.hiddenContainer, null, o, f, r, i, a), f.deps <= 0 ? f.resolve() : E && (k || (c(_, p, n, s, o, null, r, i, a), Cn(f, p)))) : (f.pendingId = kr++, k ? (f.isHydrating = !1, f.activeBranch = g) : u(g, o, f), f.deps = 0, f.effects.length = 0, f.hiddenContainer = l("div"), E ? (c(null, h, f.hiddenContainer, null, o, f, r, i, a), f.deps <= 0 ? f.resolve() : (c(_, p, n, s, o, null, r, i, a), Cn(f, p))) : _ && at(h, _) ? (c(_, h, n, s, o, f, r, i, a), f.resolve(!0)) : (c(null, h, f.hiddenContainer, null, o, f, r, i, a), f.deps <= 0 && f.resolve())); else if (_ && at(h, _)) c(_, h, n, s, o, f, r, i, a), Cn(f, h); else if (us(t, "onPending"), f.pendingBranch = h, h.shapeFlag & 512 ? f.pendingId = h.component.suspenseId : f.pendingId = kr++, c(null, h, f.hiddenContainer, null, o, f, r, i, a), f.deps <= 0) f.resolve(); else { const { timeout: w, pendingId: d } = f; w > 0 ? setTimeout(() => { f.pendingId === d && f.fallback(p) }, w) : w === 0 && f.fallback(p) } } function Nl(e, t, n, s, o, r, i, a, c, u, l = !1) { const { p: f, m: h, um: p, n: _, o: { parentNode: g, remove: E } } = u; let k; const w = xd(e); w && t && t.pendingBranch && (k = t.pendingId, t.deps++); const d = e.props ? Js(e.props.timeout) : void 0, y = r, x = { vnode: e, parent: t, parentComponent: n, namespace: i, container: s, hiddenContainer: o, deps: 0, pendingId: kr++, timeout: typeof d == "number" ? d : -1, activeBranch: null, pendingBranch: null, isInFallback: !l, isHydrating: l, isUnmounted: !1, effects: [], resolve(T = !1, S = !1) { const { vnode: F, activeBranch: O, pendingBranch: I, pendingId: q, effects: A, parentComponent: W, container: ne } = x; let ie = !1; x.isHydrating ? x.isHydrating = !1 : T || (ie = O && I.transition && I.transition.mode === "out-in", ie && (O.transition.afterLeave = () => { q === x.pendingId && (h(I, ne, r === y ? _(O) : r, 0), so(A)) }), O && (g(O.el) === ne && (r = _(O)), p(O, W, x, !0)), ie || h(I, ne, r, 0)), Cn(x, I), x.pendingBranch = null, x.isInFallback = !1; let K = x.parent, Z = !1; for (; K;) { if (K.pendingBranch) { K.effects.push(...A), Z = !0; break } K = K.parent } !Z && !ie && so(A), x.effects = [], w && t && t.pendingBranch && k === t.pendingId && (t.deps--, t.deps === 0 && !S && t.resolve()), us(F, "onResolve") }, fallback(T) { if (!x.pendingBranch) return; const { vnode: S, activeBranch: F, parentComponent: O, container: I, namespace: q } = x; us(S, "onFallback"); const A = _(F), W = () => { x.isInFallback && (f(null, T, I, A, O, null, q, a, c), Cn(x, T)) }, ne = T.transition && T.transition.mode === "out-in"; ne && (F.transition.afterLeave = W), x.isInFallback = !0, p(F, O, null, !0), ne || W() }, move(T, S, F) { x.activeBranch && h(x.activeBranch, T, S, F), x.container = T }, next() { return x.activeBranch && _(x.activeBranch) }, registerDep(T, S, F) { const O = !!x.pendingBranch; O && x.deps++; const I = T.vnode.el; T.asyncDep.catch(q => { Dn(q, T, 0) }).then(q => { if (T.isUnmounted || x.isUnmounted || x.pendingId !== T.suspenseId) return; T.asyncResolved = !0; const { vnode: A } = T; Pr(T, q, !1), I && (A.el = I); const W = !I && T.subTree.el; S(T, A, g(I || T.subTree.el), I ? null : _(T.subTree), x, i, F), W && E(W), Fo(T, A.el), O && --x.deps === 0 && x.resolve() }) }, unmount(T, S) { x.isUnmounted = !0, x.activeBranch && p(x.activeBranch, n, T, S), x.pendingBranch && p(x.pendingBranch, n, T, S) } }; return x } function Ed(e, t, n, s, o, r, i, a, c) { const u = t.suspense = Nl(t, s, n, e.parentNode, document.createElement("div"), null, o, r, i, a, !0), l = c(e, u.pendingBranch = t.ssContent, n, u, r, i); return u.deps === 0 && u.resolve(!1, !0), l } function kd(e) { const { shapeFlag: t, children: n } = e, s = t & 32; e.ssContent = Zi(s ? n.default : n), e.ssFallback = s ? Zi(n.fallback) : he(ke) } function Zi(e) { let t; if (ee(e)) { const n = cn && e._c; n && (e._d = !1, Fe()), e = e(), n && (e._d = !0, t = Me, Dl()) } return z(e) && (e = gd(e)), e = Be(e), t && !e.dynamicChildren && (e.dynamicChildren = t.filter(n => n !== e)), e } function Hl(e, t) { t && t.pendingBranch ? z(e) ? t.effects.push(...e) : t.effects.push(e) : so(e) } function Cn(e, t) { e.activeBranch = t; const { vnode: n, parentComponent: s } = e; let o = t.el; for (; !o && t.component;)t = t.component.subTree, o = t.el; n.el = o, s && s.subTree === n && (s.vnode.el = o, Fo(s, o)) } function xd(e) { const t = e.props && e.props.suspensible; return t != null && t !== !1 } const Ce = Symbol.for("v-fgt"), on = Symbol.for("v-txt"), ke = Symbol.for("v-cmt"), Rn = Symbol.for("v-stc"), Zn = []; let Me = null; function Fe(e = !1) { Zn.push(Me = e ? null : []) } function Dl() { Zn.pop(), Me = Zn[Zn.length - 1] || null } let cn = 1; function ea(e, t = !1) { cn += e, e < 0 && Me && t && (Me.hasOnce = !0) } function Fl(e) { return e.dynamicChildren = cn > 0 ? Me || wn : null, Dl(), cn > 0 && Me && Me.push(e), e } function ks(e, t, n, s, o, r) { return Fl(it(e, t, n, s, o, r, !0)) } function St(e, t, n, s, o) { return Fl(he(e, t, n, s, o, !0)) } function Yt(e) { return e ? e.__v_isVNode === !0 : !1 } function at(e, t) { return e.type === t.type && e.key === t.key } function qv(e) { } const $l = ({ key: e }) => e ?? null, Bs = ({ ref: e, ref_key: t, ref_for: n }) => (typeof e == "number" && (e = "" + e), e != null ? _e(e) || xe(e) || ee(e) ? { i: Se, r: e, k: t, f: !!n } : e : null); function it(e, t = null, n = null, s = 0, o = null, r = e === Ce ? 0 : 1, i = !1, a = !1) { const c = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && $l(t), ref: t && Bs(t), scopeId: Lo, slotScopeIds: null, children: n, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetStart: null, targetAnchor: null, staticCount: 0, shapeFlag: r, patchFlag: s, dynamicProps: o, dynamicChildren: null, appContext: null, ctx: Se }; return a ? (_i(c, n), r & 128 && e.normalize(c)) : n && (c.shapeFlag |= _e(n) ? 8 : 16), cn > 0 && !i && Me && (c.patchFlag > 0 || r & 6) && c.patchFlag !== 32 && Me.push(c), c } const he = Td; function Td(e, t = null, n = null, s = 0, o = null, r = !1) { if ((!e || e === ml) && (e = ke), Yt(e)) { const a = Lt(e, t, !0); return n && _i(a, n), cn > 0 && !r && Me && (a.shapeFlag & 6 ? Me[Me.indexOf(e)] = a : Me.push(a)), a.patchFlag = -2, a } if (Od(e) && (e = e.__vccOpts), t) { t = jl(t); let { class: a, style: c } = t; a && !_e(a) && (t.class = ys(a)), de(c) && (ri(c) && !z(c) && (c = pe({}, c)), t.style = Co(c)) } const i = _e(e) ? 1 : ao(e) ? 128 : sl(e) ? 64 : de(e) ? 4 : ee(e) ? 2 : 0; return it(e, t, n, s, o, i, r, !0) } function jl(e) { return e ? ri(e) || El(e) ? pe({}, e) : e : null } function Lt(e, t, n = !1, s = !1) { const { props: o, ref: r, patchFlag: i, children: a, transition: c } = e, u = t ? Sd(o || {}, t) : o, l = { __v_isVNode: !0, __v_skip: !0, type: e.type, props: u, key: u && $l(u), ref: t && t.ref ? n && r ? z(r) ? r.concat(Bs(t)) : [r, Bs(t)] : Bs(t) : r, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: a, target: e.target, targetStart: e.targetStart, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== Ce ? i === -1 ? 16 : i | 16 : i, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: c, component: e.component, suspense: e.suspense, ssContent: e.ssContent && Lt(e.ssContent), ssFallback: e.ssFallback && Lt(e.ssFallback), el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce }; return c && s && Gt(l, c.clone(l)), l } function Ul(e = " ", t = 0) { return he(on, null, e, t) } function Pd(e, t) { const n = he(Rn, null, e); return n.staticCount = t, n } function Gv(e = "", t = !1) { return t ? (Fe(), St(ke, null, e)) : he(ke, null, e) } function Be(e) { return e == null || typeof e == "boolean" ? he(ke) : z(e) ? he(Ce, null, e.slice()) : Yt(e) ? Bt(e) : he(on, null, String(e)) } function Bt(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : Lt(e) } function _i(e, t) { let n = 0; const { shapeFlag: s } = e; if (t == null) t = null; else if (z(t)) n = 16; else if (typeof t == "object") if (s & 65) { const o = t.default; o && (o._c && (o._d = !1), _i(e, o()), o._c && (o._d = !0)); return } else { n = 32; const o = t._; !o && !El(t) ? t._ctx = Se : o === 3 && Se && (Se.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) } else ee(t) ? (t = { default: t, _ctx: Se }, n = 32) : (t = String(t), s & 64 ? (n = 16, t = [Ul(t)]) : n = 8); e.children = t, e.shapeFlag |= n } function Sd(...e) { const t = {}; for (let n = 0; n < e.length; n++) { const s = e[n]; for (const o in s) if (o === "class") t.class !== s.class && (t.class = ys([t.class, s.class])); else if (o === "style") t.style = Co([t.style, s.style]); else if (ms(o)) { const r = t[o], i = s[o]; i && r !== i && !(z(r) && r.includes(i)) && (t[o] = r ? [].concat(r, i) : i) } else o !== "" && (t[o] = s[o]) } return t } function Ve(e, t, n, s = null) { ut(e, t, 7, [n, s]) } const Cd = bl(); let Rd = 0; function Vl(e, t, n) { const s = e.type, o = (t ? t.appContext : e.appContext) || Cd, r = { uid: Rd++, vnode: e, type: s, parent: t, appContext: o, root: null, next: null, subTree: null, effect: null, update: null, job: null, scope: new Rc(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(o.provides), ids: t ? t.ids : ["", 0, 0], accessCache: null, renderCache: [], components: null, directives: null, propsOptions: xl(s, o), emitsOptions: Ml(s, o), emit: null, emitted: null, propsDefaults: oe, inheritAttrs: s.inheritAttrs, ctx: oe, data: oe, props: oe, attrs: oe, slots: oe, refs: oe, setupState: oe, setupContext: null, suspense: n, suspenseId: n ? n.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return r.ctx = { _: r }, r.root = t ? t.root : r, r.emit = pd.bind(null, r), e.ce && e.ce(r), r } let Pe = null; const Je = () => Pe || Se; let co, xr; { const e = So(), t = (n, s) => { let o; return (o = e[n]) || (o = e[n] = []), o.push(s), r => { o.length > 1 ? o.forEach(i => i(r)) : o[0](r) } }; co = t("__VUE_INSTANCE_SETTERS__", n => Pe = n), xr = t("__VUE_SSR_SETTERS__", n => In = n) } const ln = e => { const t = Pe; return co(e), e.scope.on(), () => { e.scope.off(), co(t) } }, Tr = () => { Pe && Pe.scope.off(), co(null) }; function Bl(e) { return e.vnode.shapeFlag & 4 } let In = !1; function Wl(e, t = !1, n = !1) { t && xr(t); const { props: s, children: o } = e.vnode, r = Bl(e); ed(e, s, r, t), od(e, o, n || t); const i = r ? Ad(e, t) : void 0; return t && xr(!1), i } function Ad(e, t) { const n = e.type; e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, br); const { setup: s } = n; if (s) { It(); const o = e.setupContext = s.length > 1 ? zl(e) : null, r = ln(e), i = _s(s, e, 0, [e.props, o]), a = ei(i); if (Ot(), r(), (a || e.sp) && !Kt(e) && li(e), a) { if (i.then(Tr, Tr), t) return i.then(c => { Pr(e, c, t) }).catch(c => { Dn(c, e, 0) }); e.asyncDep = i } else Pr(e, i, t) } else Kl(e, t) } function Pr(e, t, n) { ee(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : de(t) && (e.setupState = Gc(t)), Kl(e, n) } let lo, Sr; function Yv(e) { lo = e, Sr = t => { t.render._rc && (t.withProxy = new Proxy(t.ctx, zh)) } } const Qv = () => !lo; function Kl(e, t, n) { const s = e.type; if (!e.render) { if (!t && lo && !s.render) { const o = s.template || pi(e).template; if (o) { const { isCustomElement: r, compilerOptions: i } = e.appContext.config, { delimiters: a, compilerOptions: c } = s, u = pe(pe({ isCustomElement: r, delimiters: a }, i), c); s.render = lo(o, u) } } e.render = s.render || tt, Sr && Sr(e) } { const o = ln(e); It(); try { qh(e) } finally { Ot(), o() } } } const Id = { get(e, t) { return Oe(e, "get", ""), e[t] } }; function zl(e) { const t = n => { e.exposed = n || {} }; return { attrs: new Proxy(e.attrs, Id), slots: e.slots, emit: e.emit, expose: t } } function xs(e) { return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(Gc(lh(e.exposed)), { get(t, n) { if (n in t) return t[n]; if (n in Xn) return Xn[n](e) }, has(t, n) { return n in t || n in Xn } })) : e.proxy } function Cr(e, t = !0) { return ee(e) ? e.displayName || e.name : e.name || t && e.__name } function Od(e) { return ee(e) && "__vccOpts" in e } const et = (e, t) => _h(e, t, In); function Ke(e, t, n) { const s = arguments.length; return s === 2 ? de(t) && !z(t) ? Yt(t) ? he(e, null, [t]) : he(e, t) : he(e, null, t) : (s > 3 ? n = Array.prototype.slice.call(arguments, 2) : s === 3 && Yt(n) && (n = [n]), he(e, t, n)) } function Jv() { } function Xv(e, t, n, s) { const o = n[s]; if (o && Md(o, e)) return o; const r = t(); return r.memo = e.slice(), r.cacheIndex = s, n[s] = r } function Md(e, t) { const n = e.memo; if (n.length != t.length) return !1; for (let s = 0; s < n.length; s++)if (He(n[s], t[s])) return !1; return cn > 0 && Me && Me.push(e), !0 } const Ld = "3.5.17", Zv = tt, ew = kh, tw = _n, nw = tl, Nd = { createComponentInstance: Vl, setupComponent: Wl, renderComponentRoot: Vs, setCurrentRenderingInstance: as, isVNode: Yt, normalizeVNode: Be, getComponentPublicInstance: xs, ensureValidVNode: di, pushWarningContext: wh, popWarningContext: Eh }, sw = Nd, ow = null, rw = null, iw = null;/**
* @vue/runtime-dom v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let Rr; const ta = typeof window < "u" && window.trustedTypes; if (ta) try { Rr = ta.createPolicy("vue", { createHTML: e => e }) } catch { } const ql = Rr ? e => Rr.createHTML(e) : e => e, Hd = "http://www.w3.org/2000/svg", Dd = "http://www.w3.org/1998/Math/MathML", xt = typeof document < "u" ? document : null, na = xt && xt.createElement("template"), Fd = { insert: (e, t, n) => { t.insertBefore(e, n || null) }, remove: e => { const t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, n, s) => { const o = t === "svg" ? xt.createElementNS(Hd, e) : t === "mathml" ? xt.createElementNS(Dd, e) : n ? xt.createElement(e, { is: n }) : xt.createElement(e); return e === "select" && s && s.multiple != null && o.setAttribute("multiple", s.multiple), o }, createText: e => xt.createTextNode(e), createComment: e => xt.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => xt.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, insertStaticContent(e, t, n, s, o, r) { const i = n ? n.previousSibling : t.lastChild; if (o && (o === r || o.nextSibling)) for (; t.insertBefore(o.cloneNode(!0), n), !(o === r || !(o = o.nextSibling));); else { na.innerHTML = ql(s === "svg" ? `<svg>${e}</svg>` : s === "mathml" ? `<math>${e}</math>` : e); const a = na.content; if (s === "svg" || s === "mathml") { const c = a.firstChild; for (; c.firstChild;)a.appendChild(c.firstChild); a.removeChild(c) } t.insertBefore(a, n) } return [i ? i.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild] } }, Ft = "transition", Un = "animation", On = Symbol("_vtc"), Gl = { name: String, type: String, css: { type: Boolean, default: !0 }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String }, Yl = pe({}, al, Gl), $d = e => (e.displayName = "Transition", e.props = Yl, e), jd = $d((e, { slots: t }) => Ke(Ch, Ql(e), t)), Xt = (e, t = []) => { z(e) ? e.forEach(n => n(...t)) : e && e(...t) }, sa = e => e ? z(e) ? e.some(t => t.length > 1) : e.length > 1 : !1; function Ql(e) { const t = {}; for (const A in e) A in Gl || (t[A] = e[A]); if (e.css === !1) return t; const { name: n = "v", type: s, duration: o, enterFromClass: r = `${n}-enter-from`, enterActiveClass: i = `${n}-enter-active`, enterToClass: a = `${n}-enter-to`, appearFromClass: c = r, appearActiveClass: u = i, appearToClass: l = a, leaveFromClass: f = `${n}-leave-from`, leaveActiveClass: h = `${n}-leave-active`, leaveToClass: p = `${n}-leave-to` } = e, _ = Ud(o), g = _ && _[0], E = _ && _[1], { onBeforeEnter: k, onEnter: w, onEnterCancelled: d, onLeave: y, onLeaveCancelled: x, onBeforeAppear: T = k, onAppear: S = w, onAppearCancelled: F = d } = t, O = (A, W, ne, ie) => { A._enterCancelled = ie, $t(A, W ? l : a), $t(A, W ? u : i), ne && ne() }, I = (A, W) => { A._isLeaving = !1, $t(A, f), $t(A, p), $t(A, h), W && W() }, q = A => (W, ne) => { const ie = A ? S : w, K = () => O(W, A, ne); Xt(ie, [W, K]), oa(() => { $t(W, A ? c : r), mt(W, A ? l : a), sa(ie) || ra(W, s, g, K) }) }; return pe(t, { onBeforeEnter(A) { Xt(k, [A]), mt(A, r), mt(A, i) }, onBeforeAppear(A) { Xt(T, [A]), mt(A, c), mt(A, u) }, onEnter: q(!1), onAppear: q(!0), onLeave(A, W) { A._isLeaving = !0; const ne = () => I(A, W); mt(A, f), A._enterCancelled ? (mt(A, h), Ar()) : (Ar(), mt(A, h)), oa(() => { A._isLeaving && ($t(A, f), mt(A, p), sa(y) || ra(A, s, E, ne)) }), Xt(y, [A, ne]) }, onEnterCancelled(A) { O(A, !1, void 0, !0), Xt(d, [A]) }, onAppearCancelled(A) { O(A, !0, void 0, !0), Xt(F, [A]) }, onLeaveCancelled(A) { I(A), Xt(x, [A]) } }) } function Ud(e) { if (e == null) return null; if (de(e)) return [er(e.enter), er(e.leave)]; { const t = er(e); return [t, t] } } function er(e) { return Js(e) } function mt(e, t) { t.split(/\s+/).forEach(n => n && e.classList.add(n)), (e[On] || (e[On] = new Set)).add(t) } function $t(e, t) { t.split(/\s+/).forEach(s => s && e.classList.remove(s)); const n = e[On]; n && (n.delete(t), n.size || (e[On] = void 0)) } function oa(e) { requestAnimationFrame(() => { requestAnimationFrame(e) }) } let Vd = 0; function ra(e, t, n, s) { const o = e._endId = ++Vd, r = () => { o === e._endId && s() }; if (n != null) return setTimeout(r, n); const { type: i, timeout: a, propCount: c } = Jl(e, t); if (!i) return s(); const u = i + "end"; let l = 0; const f = () => { e.removeEventListener(u, h), r() }, h = p => { p.target === e && ++l >= c && f() }; setTimeout(() => { l < c && f() }, a + 1), e.addEventListener(u, h) } function Jl(e, t) { const n = window.getComputedStyle(e), s = _ => (n[_] || "").split(", "), o = s(`${Ft}Delay`), r = s(`${Ft}Duration`), i = ia(o, r), a = s(`${Un}Delay`), c = s(`${Un}Duration`), u = ia(a, c); let l = null, f = 0, h = 0; t === Ft ? i > 0 && (l = Ft, f = i, h = r.length) : t === Un ? u > 0 && (l = Un, f = u, h = c.length) : (f = Math.max(i, u), l = f > 0 ? i > u ? Ft : Un : null, h = l ? l === Ft ? r.length : c.length : 0); const p = l === Ft && /\b(transform|all)(,|$)/.test(s(`${Ft}Property`).toString()); return { type: l, timeout: f, propCount: h, hasTransform: p } } function ia(e, t) { for (; e.length < t.length;)e = e.concat(e); return Math.max(...t.map((n, s) => aa(n) + aa(e[s]))) } function aa(e) { return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3 } function Ar() { return document.body.offsetHeight } function Bd(e, t, n) { const s = e[On]; s && (t = (t ? [t, ...s] : [...s]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t } const uo = Symbol("_vod"), Xl = Symbol("_vsh"), Wd = { beforeMount(e, { value: t }, { transition: n }) { e[uo] = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : Vn(e, t) }, mounted(e, { value: t }, { transition: n }) { n && t && n.enter(e) }, updated(e, { value: t, oldValue: n }, { transition: s }) { !t != !n && (s ? t ? (s.beforeEnter(e), Vn(e, !0), s.enter(e)) : s.leave(e, () => { Vn(e, !1) }) : Vn(e, t)) }, beforeUnmount(e, { value: t }) { Vn(e, t) } }; function Vn(e, t) { e.style.display = t ? e[uo] : "none", e[Xl] = !t } function Kd() { Wd.getSSRProps = ({ value: e }) => { if (!e) return { style: { display: "none" } } } } const Zl = Symbol(""); function aw(e) { const t = Je(); if (!t) return; const n = t.ut = (o = e(t.proxy)) => { Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach(r => fo(r, o)) }, s = () => { const o = e(t.proxy); t.ce ? fo(t.ce, o) : Ir(t.subTree, o), n(o) }; pl(() => { so(s) }), hn(() => { bt(s, tt, { flush: "post" }); const o = new MutationObserver(s); o.observe(t.subTree.el.parentNode, { childList: !0 }), ws(() => o.disconnect()) }) } function Ir(e, t) { if (e.shapeFlag & 128) { const n = e.suspense; e = n.activeBranch, n.pendingBranch && !n.isHydrating && n.effects.push(() => { Ir(n.activeBranch, t) }) } for (; e.component;)e = e.component.subTree; if (e.shapeFlag & 1 && e.el) fo(e.el, t); else if (e.type === Ce) e.children.forEach(n => Ir(n, t)); else if (e.type === Rn) { let { el: n, anchor: s } = e; for (; n && (fo(n, t), n !== s);)n = n.nextSibling } } function fo(e, t) { if (e.nodeType === 1) { const n = e.style; let s = ""; for (const o in t) n.setProperty(`--${o}`, t[o]), s += `--${o}: ${t[o]};`; n[Zl] = s } } const zd = /(^|;)\s*display\s*:/; function qd(e, t, n) { const s = e.style, o = _e(n); let r = !1; if (n && !o) { if (t) if (_e(t)) for (const i of t.split(";")) { const a = i.slice(0, i.indexOf(":")).trim(); n[a] == null && Ws(s, a, "") } else for (const i in t) n[i] == null && Ws(s, i, ""); for (const i in n) i === "display" && (r = !0), Ws(s, i, n[i]) } else if (o) { if (t !== n) { const i = s[Zl]; i && (n += ";" + i), s.cssText = n, r = zd.test(n) } } else t && e.removeAttribute("style"); uo in e && (e[uo] = r ? s.display : "", e[Xl] && (s.display = "none")) } const ca = /\s*!important$/; function Ws(e, t, n) { if (z(n)) n.forEach(s => Ws(e, t, s)); else if (n == null && (n = ""), t.startsWith("--")) e.setProperty(t, n); else { const s = Gd(e, t); ca.test(n) ? e.setProperty(We(s), n.replace(ca, ""), "important") : e[s] = n } } const la = ["Webkit", "Moz", "ms"], tr = {}; function Gd(e, t) { const n = tr[t]; if (n) return n; let s = Le(t); if (s !== "filter" && s in e) return tr[t] = s; s = Po(s); for (let o = 0; o < la.length; o++) { const r = la[o] + s; if (r in e) return tr[t] = r } return t } const ua = "http://www.w3.org/1999/xlink"; function fa(e, t, n, s, o, r = jf(t)) { s && t.startsWith("xlink:") ? n == null ? e.removeAttributeNS(ua, t.slice(6, t.length)) : e.setAttributeNS(ua, t, n) : n == null || r && !Pc(n) ? e.removeAttribute(t) : e.setAttribute(t, r ? "" : lt(n) ? String(n) : n) } function ha(e, t, n, s, o) { if (t === "innerHTML" || t === "textContent") { n != null && (e[t] = t === "innerHTML" ? ql(n) : n); return } const r = e.tagName; if (t === "value" && r !== "PROGRESS" && !r.includes("-")) { const a = r === "OPTION" ? e.getAttribute("value") || "" : e.value, c = n == null ? e.type === "checkbox" ? "on" : "" : String(n); (a !== c || !("_value" in e)) && (e.value = c), n == null && e.removeAttribute(t), e._value = n; return } let i = !1; if (n === "" || n == null) { const a = typeof e[t]; a === "boolean" ? n = Pc(n) : n == null && a === "string" ? (n = "", i = !0) : a === "number" && (n = 0, i = !0) } try { e[t] = n } catch { } i && e.removeAttribute(o || t) } function Ct(e, t, n, s) { e.addEventListener(t, n, s) } function Yd(e, t, n, s) { e.removeEventListener(t, n, s) } const da = Symbol("_vei"); function Qd(e, t, n, s, o = null) { const r = e[da] || (e[da] = {}), i = r[t]; if (s && i) i.value = s; else { const [a, c] = Jd(t); if (s) { const u = r[t] = ep(s, o); Ct(e, a, u, c) } else i && (Yd(e, a, i, c), r[t] = void 0) } } const pa = /(?:Once|Passive|Capture)$/; function Jd(e) { let t; if (pa.test(e)) { t = {}; let s; for (; s = e.match(pa);)e = e.slice(0, e.length - s[0].length), t[s[0].toLowerCase()] = !0 } return [e[2] === ":" ? e.slice(3) : We(e.slice(2)), t] } let nr = 0; const Xd = Promise.resolve(), Zd = () => nr || (Xd.then(() => nr = 0), nr = Date.now()); function ep(e, t) { const n = s => { if (!s._vts) s._vts = Date.now(); else if (s._vts <= n.attached) return; ut(tp(s, n.value), t, 5, [s]) }; return n.value = e, n.attached = Zd(), n } function tp(e, t) { if (z(t)) { const n = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { n.call(e), e._stopped = !0 }, t.map(s => o => !o._stopped && s && s(o)) } else return t } const ga = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, np = (e, t, n, s, o, r) => { const i = o === "svg"; t === "class" ? Bd(e, s, i) : t === "style" ? qd(e, n, s) : ms(t) ? Xr(t) || Qd(e, t, n, s, r) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : sp(e, t, s, i)) ? (ha(e, t, s), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && fa(e, t, s, i, r, t !== "value")) : e._isVueCE && (/[A-Z]/.test(t) || !_e(s)) ? ha(e, Le(t), s, r, t) : (t === "true-value" ? e._trueValue = s : t === "false-value" && (e._falseValue = s), fa(e, t, s, i)) }; function sp(e, t, n, s) { if (s) return !!(t === "innerHTML" || t === "textContent" || t in e && ga(t) && ee(n)); if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1; if (t === "width" || t === "height") { const o = e.tagName; if (o === "IMG" || o === "VIDEO" || o === "CANVAS" || o === "SOURCE") return !1 } return ga(t) && _e(n) ? !1 : t in e } const ma = {};/*! #__NO_SIDE_EFFECTS__ */function op(e, t, n) { const s = vt(e, t); xo(s) && pe(s, t); class o extends bi { constructor(i) { super(s, i, n) } } return o.def = s, o }/*! #__NO_SIDE_EFFECTS__ */const cw = (e, t) => op(e, t, lu), rp = typeof HTMLElement < "u" ? HTMLElement : class { }; class bi extends rp { constructor(t, n = {}, s = Mr) { super(), this._def = t, this._props = n, this._createApp = s, this._isVueCE = !0, this._instance = null, this._app = null, this._nonce = this._def.nonce, this._connected = !1, this._resolved = !1, this._numberProps = null, this._styleChildren = new WeakSet, this._ob = null, this.shadowRoot && s !== Mr ? this._root = this.shadowRoot : t.shadowRoot !== !1 ? (this.attachShadow({ mode: "open" }), this._root = this.shadowRoot) : this._root = this } connectedCallback() { if (!this.isConnected) return; !this.shadowRoot && !this._resolved && this._parseSlots(), this._connected = !0; let t = this; for (; t = t && (t.parentNode || t.host);)if (t instanceof bi) { this._parent = t; break } this._instance || (this._resolved ? this._mount(this._def) : t && t._pendingResolve ? this._pendingResolve = t._pendingResolve.then(() => { this._pendingResolve = void 0, this._resolveDef() }) : this._resolveDef()) } _setParent(t = this._parent) { t && (this._instance.parent = t._instance, this._inheritParentContext(t)) } _inheritParentContext(t = this._parent) { t && this._app && Object.setPrototypeOf(this._app._context.provides, t._instance.provides) } disconnectedCallback() { this._connected = !1, qt(() => { this._connected || (this._ob && (this._ob.disconnect(), this._ob = null), this._app && this._app.unmount(), this._instance && (this._instance.ce = void 0), this._app = this._instance = null) }) } _resolveDef() { if (this._pendingResolve) return; for (let s = 0; s < this.attributes.length; s++)this._setAttr(this.attributes[s].name); this._ob = new MutationObserver(s => { for (const o of s) this._setAttr(o.attributeName) }), this._ob.observe(this, { attributes: !0 }); const t = (s, o = !1) => { this._resolved = !0, this._pendingResolve = void 0; const { props: r, styles: i } = s; let a; if (r && !z(r)) for (const c in r) { const u = r[c]; (u === Number || u && u.type === Number) && (c in this._props && (this._props[c] = Js(this._props[c])), (a || (a = Object.create(null)))[Le(c)] = !0) } this._numberProps = a, this._resolveProps(s), this.shadowRoot && this._applyStyles(i), this._mount(s) }, n = this._def.__asyncLoader; n ? this._pendingResolve = n().then(s => { s.configureApp = this._def.configureApp, t(this._def = s, !0) }) : t(this._def) } _mount(t) { this._app = this._createApp(t), this._inheritParentContext(), t.configureApp && t.configureApp(this._app), this._app._ceVNode = this._createVNode(), this._app.mount(this._root); const n = this._instance && this._instance.exposed; if (n) for (const s in n) le(this, s) || Object.defineProperty(this, s, { get: () => be(n[s]) }) } _resolveProps(t) { const { props: n } = t, s = z(n) ? n : Object.keys(n || {}); for (const o of Object.keys(this)) o[0] !== "_" && s.includes(o) && this._setProp(o, this[o]); for (const o of s.map(Le)) Object.defineProperty(this, o, { get() { return this._getProp(o) }, set(r) { this._setProp(o, r, !0, !0) } }) } _setAttr(t) { if (t.startsWith("data-v-")) return; const n = this.hasAttribute(t); let s = n ? this.getAttribute(t) : ma; const o = Le(t); n && this._numberProps && this._numberProps[o] && (s = Js(s)), this._setProp(o, s, !1, !0) } _getProp(t) { return this._props[t] } _setProp(t, n, s = !0, o = !1) { if (n !== this._props[t] && (n === ma ? delete this._props[t] : (this._props[t] = n, t === "key" && this._app && (this._app._ceVNode.key = n)), o && this._instance && this._update(), s)) { const r = this._ob; r && r.disconnect(), n === !0 ? this.setAttribute(We(t), "") : typeof n == "string" || typeof n == "number" ? this.setAttribute(We(t), n + "") : n || this.removeAttribute(We(t)), r && r.observe(this, { attributes: !0 }) } } _update() { const t = this._createVNode(); this._app && (t.appContext = this._app._context), vp(t, this._root) } _createVNode() { const t = {}; this.shadowRoot || (t.onVnodeMounted = t.onVnodeUpdated = this._renderSlots.bind(this)); const n = he(this._def, pe(t, this._props)); return this._instance || (n.ce = s => { this._instance = s, s.ce = this, s.isCE = !0; const o = (r, i) => { this.dispatchEvent(new CustomEvent(r, xo(i[0]) ? pe({ detail: i }, i[0]) : { detail: i })) }; s.emit = (r, ...i) => { o(r, i), We(r) !== r && o(We(r), i) }, this._setParent() }), n } _applyStyles(t, n) { if (!t) return; if (n) { if (n === this._def || this._styleChildren.has(n)) return; this._styleChildren.add(n) } const s = this._nonce; for (let o = t.length - 1; o >= 0; o--) { const r = document.createElement("style"); s && r.setAttribute("nonce", s), r.textContent = t[o], this.shadowRoot.prepend(r) } } _parseSlots() { const t = this._slots = {}; let n; for (; n = this.firstChild;) { const s = n.nodeType === 1 && n.getAttribute("slot") || "default"; (t[s] || (t[s] = [])).push(n), this.removeChild(n) } } _renderSlots() { const t = (this._teleportTarget || this).querySelectorAll("slot"), n = this._instance.type.__scopeId; for (let s = 0; s < t.length; s++) { const o = t[s], r = o.getAttribute("name") || "default", i = this._slots[r], a = o.parentNode; if (i) for (const c of i) { if (n && c.nodeType === 1) { const u = n + "-s", l = document.createTreeWalker(c, 1); c.setAttribute(u, ""); let f; for (; f = l.nextNode();)f.setAttribute(u, "") } a.insertBefore(c, o) } else for (; o.firstChild;)a.insertBefore(o.firstChild, o); a.removeChild(o) } } _injectChildStyle(t) { this._applyStyles(t.styles, t) } _removeChildStyle(t) { } } function ip(e) { const t = Je(), n = t && t.ce; return n || null } function lw() { const e = ip(); return e && e.shadowRoot } function uw(e = "$style") { { const t = Je(); if (!t) return oe; const n = t.type.__cssModules; if (!n) return oe; const s = n[e]; return s || oe } } const eu = new WeakMap, tu = new WeakMap, ho = Symbol("_moveCb"), ya = Symbol("_enterCb"), ap = e => (delete e.props.mode, e), cp = ap({ name: "TransitionGroup", props: pe({}, Yl, { tag: String, moveClass: String }), setup(e, { slots: t }) { const n = Je(), s = il(); let o, r; return ui(() => { if (!o.length) return; const i = e.moveClass || `${e.name || "v"}-move`; if (!hp(o[0].el, n.vnode.el, i)) { o = []; return } o.forEach(lp), o.forEach(up); const a = o.filter(fp); Ar(), a.forEach(c => { const u = c.el, l = u.style; mt(u, i), l.transform = l.webkitTransform = l.transitionDuration = ""; const f = u[ho] = h => { h && h.target !== u || (!h || /transform$/.test(h.propertyName)) && (u.removeEventListener("transitionend", f), u[ho] = null, $t(u, i)) }; u.addEventListener("transitionend", f) }), o = [] }), () => { const i = ae(e), a = Ql(i); let c = i.tag || Ce; if (o = [], r) for (let u = 0; u < r.length; u++) { const l = r[u]; l.el && l.el instanceof Element && (o.push(l), Gt(l, cs(l, a, s, n)), eu.set(l, l.el.getBoundingClientRect())) } r = t.default ? ci(t.default()) : []; for (let u = 0; u < r.length; u++) { const l = r[u]; l.key != null && Gt(l, cs(l, a, s, n)) } return he(c, null, r) } } }), fw = cp; function lp(e) { const t = e.el; t[ho] && t[ho](), t[ya] && t[ya]() } function up(e) { tu.set(e, e.el.getBoundingClientRect()) } function fp(e) { const t = eu.get(e), n = tu.get(e), s = t.left - n.left, o = t.top - n.top; if (s || o) { const r = e.el.style; return r.transform = r.webkitTransform = `translate(${s}px,${o}px)`, r.transitionDuration = "0s", e } } function hp(e, t, n) { const s = e.cloneNode(), o = e[On]; o && o.forEach(a => { a.split(/\s+/).forEach(c => c && s.classList.remove(c)) }), n.split(/\s+/).forEach(a => a && s.classList.add(a)), s.style.display = "none"; const r = t.nodeType === 1 ? t : t.parentNode; r.appendChild(s); const { hasTransform: i } = Jl(s); return r.removeChild(s), i } const Qt = e => { const t = e.props["onUpdate:modelValue"] || !1; return z(t) ? n => xn(t, n) : t }; function dp(e) { e.target.composing = !0 } function _a(e) { const t = e.target; t.composing && (t.composing = !1, t.dispatchEvent(new Event("input"))) } const st = Symbol("_assign"), Or = { created(e, { modifiers: { lazy: t, trim: n, number: s } }, o) { e[st] = Qt(o); const r = s || o.props && o.props.type === "number"; Ct(e, t ? "change" : "input", i => { if (i.target.composing) return; let a = e.value; n && (a = a.trim()), r && (a = Qs(a)), e[st](a) }), n && Ct(e, "change", () => { e.value = e.value.trim() }), t || (Ct(e, "compositionstart", dp), Ct(e, "compositionend", _a), Ct(e, "change", _a)) }, mounted(e, { value: t }) { e.value = t ?? "" }, beforeUpdate(e, { value: t, oldValue: n, modifiers: { lazy: s, trim: o, number: r } }, i) { if (e[st] = Qt(i), e.composing) return; const a = (r || e.type === "number") && !/^0\d/.test(e.value) ? Qs(e.value) : e.value, c = t ?? ""; a !== c && (document.activeElement === e && e.type !== "range" && (s && t === n || o && e.value.trim() === c) || (e.value = c)) } }, nu = { deep: !0, created(e, t, n) { e[st] = Qt(n), Ct(e, "change", () => { const s = e._modelValue, o = Mn(e), r = e.checked, i = e[st]; if (z(s)) { const a = Ro(s, o), c = a !== -1; if (r && !c) i(s.concat(o)); else if (!r && c) { const u = [...s]; u.splice(a, 1), i(u) } } else if (fn(s)) { const a = new Set(s); r ? a.add(o) : a.delete(o), i(a) } else i(ou(e, r)) }) }, mounted: ba, beforeUpdate(e, t, n) { e[st] = Qt(n), ba(e, t, n) } }; function ba(e, { value: t, oldValue: n }, s) { e._modelValue = t; let o; if (z(t)) o = Ro(t, s.props.value) > -1; else if (fn(t)) o = t.has(s.props.value); else { if (t === n) return; o = zt(t, ou(e, !0)) } e.checked !== o && (e.checked = o) } const su = { created(e, { value: t }, n) { e.checked = zt(t, n.props.value), e[st] = Qt(n), Ct(e, "change", () => { e[st](Mn(e)) }) }, beforeUpdate(e, { value: t, oldValue: n }, s) { e[st] = Qt(s), t !== n && (e.checked = zt(t, s.props.value)) } }, pp = { deep: !0, created(e, { value: t, modifiers: { number: n } }, s) { const o = fn(t); Ct(e, "change", () => { const r = Array.prototype.filter.call(e.options, i => i.selected).map(i => n ? Qs(Mn(i)) : Mn(i)); e[st](e.multiple ? o ? new Set(r) : r : r[0]), e._assigning = !0, qt(() => { e._assigning = !1 }) }), e[st] = Qt(s) }, mounted(e, { value: t }) { va(e, t) }, beforeUpdate(e, t, n) { e[st] = Qt(n) }, updated(e, { value: t }) { e._assigning || va(e, t) } }; function va(e, t) { const n = e.multiple, s = z(t); if (!(n && !s && !fn(t))) { for (let o = 0, r = e.options.length; o < r; o++) { const i = e.options[o], a = Mn(i); if (n) if (s) { const c = typeof a; c === "string" || c === "number" ? i.selected = t.some(u => String(u) === String(a)) : i.selected = Ro(t, a) > -1 } else i.selected = t.has(a); else if (zt(Mn(i), t)) { e.selectedIndex !== o && (e.selectedIndex = o); return } } !n && e.selectedIndex !== -1 && (e.selectedIndex = -1) } } function Mn(e) { return "_value" in e ? e._value : e.value } function ou(e, t) { const n = t ? "_trueValue" : "_falseValue"; return n in e ? e[n] : t } const gp = { created(e, t, n) { Ns(e, t, n, null, "created") }, mounted(e, t, n) { Ns(e, t, n, null, "mounted") }, beforeUpdate(e, t, n, s) { Ns(e, t, n, s, "beforeUpdate") }, updated(e, t, n, s) { Ns(e, t, n, s, "updated") } }; function ru(e, t) { switch (e) { case "SELECT": return pp; case "TEXTAREA": return Or; default: switch (t) { case "checkbox": return nu; case "radio": return su; default: return Or } } } function Ns(e, t, n, s, o) { const i = ru(e.tagName, n.props && n.props.type)[o]; i && i(e, t, n, s) } function mp() { Or.getSSRProps = ({ value: e }) => ({ value: e }), su.getSSRProps = ({ value: e }, t) => { if (t.props && zt(t.props.value, e)) return { checked: !0 } }, nu.getSSRProps = ({ value: e }, t) => { if (z(e)) { if (t.props && Ro(e, t.props.value) > -1) return { checked: !0 } } else if (fn(e)) { if (t.props && e.has(t.props.value)) return { checked: !0 } } else if (e) return { checked: !0 } }, gp.getSSRProps = (e, t) => { if (typeof t.type != "string") return; const n = ru(t.type.toUpperCase(), t.props && t.props.type); if (n.getSSRProps) return n.getSSRProps(e, t) } } const yp = ["ctrl", "shift", "alt", "meta"], _p = { stop: e => e.stopPropagation(), prevent: e => e.preventDefault(), self: e => e.target !== e.currentTarget, ctrl: e => !e.ctrlKey, shift: e => !e.shiftKey, alt: e => !e.altKey, meta: e => !e.metaKey, left: e => "button" in e && e.button !== 0, middle: e => "button" in e && e.button !== 1, right: e => "button" in e && e.button !== 2, exact: (e, t) => yp.some(n => e[`${n}Key`] && !t.includes(n)) }, hw = (e, t) => { const n = e._withMods || (e._withMods = {}), s = t.join("."); return n[s] || (n[s] = (o, ...r) => { for (let i = 0; i < t.length; i++) { const a = _p[t[i]]; if (a && a(o, t)) return } return e(o, ...r) }) }, bp = { esc: "escape", space: " ", up: "arrow-up", left: "arrow-left", right: "arrow-right", down: "arrow-down", delete: "backspace" }, dw = (e, t) => { const n = e._withKeys || (e._withKeys = {}), s = t.join("."); return n[s] || (n[s] = o => { if (!("key" in o)) return; const r = We(o.key); if (t.some(i => i === r || bp[i] === r)) return e(o) }) }, iu = pe({ patchProp: np }, Fd); let es, wa = !1; function au() { return es || (es = id(iu)) } function cu() { return es = wa ? es : ad(iu), wa = !0, es } const vp = (...e) => { au().render(...e) }, pw = (...e) => { cu().hydrate(...e) }, Mr = (...e) => { const t = au().createApp(...e), { mount: n } = t; return t.mount = s => { const o = fu(s); if (!o) return; const r = t._component; !ee(r) && !r.render && !r.template && (r.template = o.innerHTML), o.nodeType === 1 && (o.textContent = ""); const i = n(o, !1, uu(o)); return o instanceof Element && (o.removeAttribute("v-cloak"), o.setAttribute("data-v-app", "")), i }, t }, lu = (...e) => { const t = cu().createApp(...e), { mount: n } = t; return t.mount = s => { const o = fu(s); if (o) return n(o, !0, uu(o)) }, t }; function uu(e) { if (e instanceof SVGElement) return "svg"; if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml" } function fu(e) { return _e(e) ? document.querySelector(e) : e } let Ea = !1; const gw = () => { Ea || (Ea = !0, mp(), Kd()) }, wp = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, Ep = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, kp = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/; function xp(e, t) { if (e === "__proto__" || e === "constructor" && t && typeof t == "object" && "prototype" in t) { Tp(e); return } return t } function Tp(e) { console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`) } function po(e, t = {}) { if (typeof e != "string") return e; if (e[0] === '"' && e[e.length - 1] === '"' && e.indexOf("\\") === -1) return e.slice(1, -1); const n = e.trim(); if (n.length <= 9) switch (n.toLowerCase()) { case "true": return !0; case "false": return !1; case "undefined": return; case "null": return null; case "nan": return Number.NaN; case "infinity": return Number.POSITIVE_INFINITY; case "-infinity": return Number.NEGATIVE_INFINITY }if (!kp.test(e)) { if (t.strict) throw new SyntaxError("[destr] Invalid JSON"); return e } try { if (wp.test(e) || Ep.test(e)) { if (t.strict) throw new Error("[destr] Possible prototype pollution"); return JSON.parse(e, xp) } return JSON.parse(e) } catch (s) { if (t.strict) throw s; return e } } const Pp = /#/g, Sp = /&/g, Cp = /\//g, Rp = /=/g, vi = /\+/g, Ap = /%5e/gi, Ip = /%60/gi, Op = /%7c/gi, Mp = /%20/gi; function Lp(e) { return encodeURI("" + e).replace(Op, "|") } function Lr(e) { return Lp(typeof e == "string" ? e : JSON.stringify(e)).replace(vi, "%2B").replace(Mp, "+").replace(Pp, "%23").replace(Sp, "%26").replace(Ip, "`").replace(Ap, "^").replace(Cp, "%2F") } function sr(e) { return Lr(e).replace(Rp, "%3D") } function go(e = "") { try { return decodeURIComponent("" + e) } catch { return "" + e } } function Np(e) { return go(e.replace(vi, " ")) } function Hp(e) { return go(e.replace(vi, " ")) } function hu(e = "") { const t = Object.create(null); e[0] === "?" && (e = e.slice(1)); for (const n of e.split("&")) { const s = n.match(/([^=]+)=?(.*)/) || []; if (s.length < 2) continue; const o = Np(s[1]); if (o === "__proto__" || o === "constructor") continue; const r = Hp(s[2] || ""); t[o] === void 0 ? t[o] = r : Array.isArray(t[o]) ? t[o].push(r) : t[o] = [t[o], r] } return t } function Dp(e, t) { return (typeof t == "number" || typeof t == "boolean") && (t = String(t)), t ? Array.isArray(t) ? t.map(n => `${sr(e)}=${Lr(n)}`).join("&") : `${sr(e)}=${Lr(t)}` : sr(e) } function Fp(e) { return Object.keys(e).filter(t => e[t] !== void 0).map(t => Dp(t, e[t])).filter(Boolean).join("&") } const $p = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/, jp = /^[\s\w\0+.-]{2,}:([/\\]{2})?/, Up = /^([/\\]\s*){2,}[^/\\]/, Vp = /^[\s\0]*(blob|data|javascript|vbscript):$/i, Bp = /\/$|\/\?|\/#/, Wp = /^\.?\//; function dn(e, t = {}) { return typeof t == "boolean" && (t = { acceptRelative: t }), t.strict ? $p.test(e) : jp.test(e) || (t.acceptRelative ? Up.test(e) : !1) } function Kp(e) { return !!e && Vp.test(e) } function Nr(e = "", t) { return t ? Bp.test(e) : e.endsWith("/") } function fs(e = "", t) { if (!t) return (Nr(e) ? e.slice(0, -1) : e) || "/"; if (!Nr(e, !0)) return e || "/"; let n = e, s = ""; const o = e.indexOf("#"); o !== -1 && (n = e.slice(0, o), s = e.slice(o)); const [r, ...i] = n.split("?"); return ((r.endsWith("/") ? r.slice(0, -1) : r) || "/") + (i.length > 0 ? `?${i.join("?")}` : "") + s } function zp(e = "", t) { if (!t) return e.endsWith("/") ? e : e + "/"; if (Nr(e, !0)) return e || "/"; let n = e, s = ""; const o = e.indexOf("#"); if (o !== -1 && (n = e.slice(0, o), s = e.slice(o), !n)) return s; const [r, ...i] = n.split("?"); return r + "/" + (i.length > 0 ? `?${i.join("?")}` : "") + s } function qp(e = "") { return e.startsWith("/") } function mw(e = "") { return qp(e) ? e : "/" + e } function Gp(e, t) { if (pu(t) || dn(e)) return e; const n = fs(t); return e.startsWith(n) ? e : wi(n, e) } function ka(e, t) { if (pu(t)) return e; const n = fs(t); if (!e.startsWith(n)) return e; const s = e.slice(n.length); return s[0] === "/" ? s : "/" + s } function du(e, t) { const n = yu(e), s = { ...hu(n.search), ...t }; return n.search = Fp(s), Jp(n) } function pu(e) { return !e || e === "/" } function Yp(e) { return e && e !== "/" } function wi(e, ...t) { let n = e || ""; for (const s of t.filter(o => Yp(o))) if (n) { const o = s.replace(Wp, ""); n = zp(n) + o } else n = s; return n } function gu(...e) { var i, a, c, u; const t = /\/(?!\/)/, n = e.filter(Boolean), s = []; let o = 0; for (const l of n) if (!(!l || l === "/")) { for (const [f, h] of l.split(t).entries()) if (!(!h || h === ".")) { if (h === "..") { if (s.length === 1 && dn(s[0])) continue; s.pop(), o--; continue } if (f === 1 && ((i = s[s.length - 1]) != null && i.endsWith(":/"))) { s[s.length - 1] += "/" + h; continue } s.push(h), o++ } } let r = s.join("/"); return o >= 0 ? (a = n[0]) != null && a.startsWith("/") && !r.startsWith("/") ? r = "/" + r : (c = n[0]) != null && c.startsWith("./") && !r.startsWith("./") && (r = "./" + r) : r = "../".repeat(-1 * o) + r, (u = n[n.length - 1]) != null && u.endsWith("/") && !r.endsWith("/") && (r += "/"), r } function Qp(e, t) { return go(fs(e)) === go(fs(t)) } const mu = Symbol.for("ufo:protocolRelative"); function yu(e = "", t) { const n = e.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i); if (n) { const [, f, h = ""] = n; return { protocol: f.toLowerCase(), pathname: h, href: f + h, auth: "", host: "", search: "", hash: "" } } if (!dn(e, { acceptRelative: !0 })) return xa(e); const [, s = "", o, r = ""] = e.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || []; let [, i = "", a = ""] = r.match(/([^#/?]*)(.*)?/) || []; s === "file:" && (a = a.replace(/\/(?=[A-Za-z]:)/, "")); const { pathname: c, search: u, hash: l } = xa(a); return { protocol: s.toLowerCase(), auth: o ? o.slice(0, Math.max(0, o.length - 1)) : "", host: i, pathname: c, search: u, hash: l, [mu]: !s } } function xa(e = "") { const [t = "", n = "", s = ""] = (e.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1); return { pathname: t, search: n, hash: s } } function Jp(e) { const t = e.pathname || "", n = e.search ? (e.search.startsWith("?") ? "" : "?") + e.search : "", s = e.hash || "", o = e.auth ? e.auth + "@" : "", r = e.host || ""; return (e.protocol || e[mu] ? (e.protocol || "") + "//" : "") + o + r + t + n + s } class Xp extends Error { constructor(t, n) { super(t, n), this.name = "FetchError", n != null && n.cause && !this.cause && (this.cause = n.cause) } } function Zp(e) { var c, u, l, f, h; const t = ((c = e.error) == null ? void 0 : c.message) || ((u = e.error) == null ? void 0 : u.toString()) || "", n = ((l = e.request) == null ? void 0 : l.method) || ((f = e.options) == null ? void 0 : f.method) || "GET", s = ((h = e.request) == null ? void 0 : h.url) || String(e.request) || "/", o = `[${n}] ${JSON.stringify(s)}`, r = e.response ? `${e.response.status} ${e.response.statusText}` : "<no response>", i = `${o}: ${r}${t ? ` ${t}` : ""}`, a = new Xp(i, e.error ? { cause: e.error } : void 0); for (const p of ["request", "options", "response"]) Object.defineProperty(a, p, { get() { return e[p] } }); for (const [p, _] of [["data", "_data"], ["status", "status"], ["statusCode", "status"], ["statusText", "statusText"], ["statusMessage", "statusText"]]) Object.defineProperty(a, p, { get() { return e.response && e.response[_] } }); return a } const eg = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"])); function Ta(e = "GET") { return eg.has(e.toUpperCase()) } function tg(e) { if (e === void 0) return !1; const t = typeof e; return t === "string" || t === "number" || t === "boolean" || t === null ? !0 : t !== "object" ? !1 : Array.isArray(e) ? !0 : e.buffer ? !1 : e.constructor && e.constructor.name === "Object" || typeof e.toJSON == "function" } const ng = new Set(["image/svg", "application/xml", "application/xhtml", "application/html"]), sg = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i; function og(e = "") { if (!e) return "json"; const t = e.split(";").shift() || ""; return sg.test(t) ? "json" : ng.has(t) || t.startsWith("text/") ? "text" : "blob" } function rg(e, t, n, s) { const o = ig((t == null ? void 0 : t.headers) ?? (e == null ? void 0 : e.headers), n == null ? void 0 : n.headers, s); let r; return (n != null && n.query || n != null && n.params || t != null && t.params || t != null && t.query) && (r = { ...n == null ? void 0 : n.params, ...n == null ? void 0 : n.query, ...t == null ? void 0 : t.params, ...t == null ? void 0 : t.query }), { ...n, ...t, query: r, params: r, headers: o } } function ig(e, t, n) { if (!t) return new n(e); const s = new n(t); if (e) for (const [o, r] of Symbol.iterator in e || Array.isArray(e) ? e : new n(e)) s.set(o, r); return s } async function Hs(e, t) { if (t) if (Array.isArray(t)) for (const n of t) await n(e); else await t(e) } const ag = new Set([408, 409, 425, 429, 500, 502, 503, 504]), cg = new Set([101, 204, 205, 304]); function _u(e = {}) { const { fetch: t = globalThis.fetch, Headers: n = globalThis.Headers, AbortController: s = globalThis.AbortController } = e; async function o(a) { const c = a.error && a.error.name === "AbortError" && !a.options.timeout || !1; if (a.options.retry !== !1 && !c) { let l; typeof a.options.retry == "number" ? l = a.options.retry : l = Ta(a.options.method) ? 0 : 1; const f = a.response && a.response.status || 500; if (l > 0 && (Array.isArray(a.options.retryStatusCodes) ? a.options.retryStatusCodes.includes(f) : ag.has(f))) { const h = typeof a.options.retryDelay == "function" ? a.options.retryDelay(a) : a.options.retryDelay || 0; return h > 0 && await new Promise(p => setTimeout(p, h)), r(a.request, { ...a.options, retry: l - 1 }) } } const u = Zp(a); throw Error.captureStackTrace && Error.captureStackTrace(u, r), u } const r = async function (c, u = {}) { const l = { request: c, options: rg(c, u, e.defaults, n), response: void 0, error: void 0 }; l.options.method && (l.options.method = l.options.method.toUpperCase()), l.options.onRequest && await Hs(l, l.options.onRequest), typeof l.request == "string" && (l.options.baseURL && (l.request = Gp(l.request, l.options.baseURL)), l.options.query && (l.request = du(l.request, l.options.query), delete l.options.query), "query" in l.options && delete l.options.query, "params" in l.options && delete l.options.params), l.options.body && Ta(l.options.method) && (tg(l.options.body) ? (l.options.body = typeof l.options.body == "string" ? l.options.body : JSON.stringify(l.options.body), l.options.headers = new n(l.options.headers || {}), l.options.headers.has("content-type") || l.options.headers.set("content-type", "application/json"), l.options.headers.has("accept") || l.options.headers.set("accept", "application/json")) : ("pipeTo" in l.options.body && typeof l.options.body.pipeTo == "function" || typeof l.options.body.pipe == "function") && ("duplex" in l.options || (l.options.duplex = "half"))); let f; if (!l.options.signal && l.options.timeout) { const p = new s; f = setTimeout(() => { const _ = new Error("[TimeoutError]: The operation was aborted due to timeout"); _.name = "TimeoutError", _.code = 23, p.abort(_) }, l.options.timeout), l.options.signal = p.signal } try { l.response = await t(l.request, l.options) } catch (p) { return l.error = p, l.options.onRequestError && await Hs(l, l.options.onRequestError), await o(l) } finally { f && clearTimeout(f) } if ((l.response.body || l.response._bodyInit) && !cg.has(l.response.status) && l.options.method !== "HEAD") { const p = (l.options.parseResponse ? "json" : l.options.responseType) || og(l.response.headers.get("content-type") || ""); switch (p) { case "json": { const _ = await l.response.text(), g = l.options.parseResponse || po; l.response._data = g(_); break } case "stream": { l.response._data = l.response.body || l.response._bodyInit; break } default: l.response._data = await l.response[p]() } } return l.options.onResponse && await Hs(l, l.options.onResponse), !l.options.ignoreResponseError && l.response.status >= 400 && l.response.status < 600 ? (l.options.onResponseError && await Hs(l, l.options.onResponseError), await o(l)) : l.response }, i = async function (c, u) { return (await r(c, u))._data }; return i.raw = r, i.native = (...a) => t(...a), i.create = (a = {}, c = {}) => _u({ ...e, ...c, defaults: { ...e.defaults, ...c.defaults, ...a } }), i } const mo = function () { if (typeof globalThis < "u") return globalThis; if (typeof self < "u") return self; if (typeof window < "u") return window; if (typeof global < "u") return global; throw new Error("unable to locate global object") }(), lg = mo.fetch ? (...e) => mo.fetch(...e) : () => Promise.reject(new Error("[ofetch] global.fetch is not supported!")), ug = mo.Headers, fg = mo.AbortController, hg = _u({ fetch: lg, Headers: ug, AbortController: fg }), dg = hg, pg = () => { var e; return ((e = window == null ? void 0 : window.__NUXT__) == null ? void 0 : e.config) || {} }, yo = pg().app, gg = () => yo.baseURL, mg = () => yo.buildAssetsDir, Ei = (...e) => gu(ki(), mg(), ...e), ki = (...e) => { const t = yo.cdnURL || yo.baseURL; return e.length ? gu(t, ...e) : t }; globalThis.__buildAssetsURL = Ei, globalThis.__publicAssetsURL = ki; globalThis.$fetch || (globalThis.$fetch = dg.create({ baseURL: gg() })); "global" in globalThis || (globalThis.global = globalThis); function Hr(e, t = {}, n) { for (const s in e) { const o = e[s], r = n ? `${n}:${s}` : s; typeof o == "object" && o !== null ? Hr(o, t, r) : typeof o == "function" && (t[r] = o) } return t } const yg = { run: e => e() }, _g = () => yg, bu = typeof console.createTask < "u" ? console.createTask : _g; function bg(e, t) { const n = t.shift(), s = bu(n); return e.reduce((o, r) => o.then(() => s.run(() => r(...t))), Promise.resolve()) } function vg(e, t) { const n = t.shift(), s = bu(n); return Promise.all(e.map(o => s.run(() => o(...t)))) } function or(e, t) { for (const n of [...e]) n(t) } class wg { constructor() { this._hooks = {}, this._before = void 0, this._after = void 0, this._deprecatedMessages = void 0, this._deprecatedHooks = {}, this.hook = this.hook.bind(this), this.callHook = this.callHook.bind(this), this.callHookWith = this.callHookWith.bind(this) } hook(t, n, s = {}) { if (!t || typeof n != "function") return () => { }; const o = t; let r; for (; this._deprecatedHooks[t];)r = this._deprecatedHooks[t], t = r.to; if (r && !s.allowDeprecated) { let i = r.message; i || (i = `${o} hook has been deprecated` + (r.to ? `, please use ${r.to}` : "")), this._deprecatedMessages || (this._deprecatedMessages = new Set), this._deprecatedMessages.has(i) || (console.warn(i), this._deprecatedMessages.add(i)) } if (!n.name) try { Object.defineProperty(n, "name", { get: () => "_" + t.replace(/\W+/g, "_") + "_hook_cb", configurable: !0 }) } catch { } return this._hooks[t] = this._hooks[t] || [], this._hooks[t].push(n), () => { n && (this.removeHook(t, n), n = void 0) } } hookOnce(t, n) { let s, o = (...r) => (typeof s == "function" && s(), s = void 0, o = void 0, n(...r)); return s = this.hook(t, o), s } removeHook(t, n) { if (this._hooks[t]) { const s = this._hooks[t].indexOf(n); s !== -1 && this._hooks[t].splice(s, 1), this._hooks[t].length === 0 && delete this._hooks[t] } } deprecateHook(t, n) { this._deprecatedHooks[t] = typeof n == "string" ? { to: n } : n; const s = this._hooks[t] || []; delete this._hooks[t]; for (const o of s) this.hook(t, o) } deprecateHooks(t) { Object.assign(this._deprecatedHooks, t); for (const n in t) this.deprecateHook(n, t[n]) } addHooks(t) { const n = Hr(t), s = Object.keys(n).map(o => this.hook(o, n[o])); return () => { for (const o of s.splice(0, s.length)) o() } } removeHooks(t) { const n = Hr(t); for (const s in n) this.removeHook(s, n[s]) } removeAllHooks() { for (const t in this._hooks) delete this._hooks[t] } callHook(t, ...n) { return n.unshift(t), this.callHookWith(bg, t, ...n) } callHookParallel(t, ...n) { return n.unshift(t), this.callHookWith(vg, t, ...n) } callHookWith(t, n, ...s) { const o = this._before || this._after ? { name: n, args: s, context: {} } : void 0; this._before && or(this._before, o); const r = t(n in this._hooks ? [...this._hooks[n]] : [], s); return r instanceof Promise ? r.finally(() => { this._after && o && or(this._after, o) }) : (this._after && o && or(this._after, o), r) } beforeEach(t) { return this._before = this._before || [], this._before.push(t), () => { if (this._before !== void 0) { const n = this._before.indexOf(t); n !== -1 && this._before.splice(n, 1) } } } afterEach(t) { return this._after = this._after || [], this._after.push(t), () => { if (this._after !== void 0) { const n = this._after.indexOf(t); n !== -1 && this._after.splice(n, 1) } } } } function vu() { return new wg } function Eg(e = {}) { let t, n = !1; const s = i => { if (t && t !== i) throw new Error("Context conflict") }; let o; if (e.asyncContext) { const i = e.AsyncLocalStorage || globalThis.AsyncLocalStorage; i ? o = new i : console.warn("[unctx] `AsyncLocalStorage` is not provided.") } const r = () => { if (o) { const i = o.getStore(); if (i !== void 0) return i } return t }; return { use: () => { const i = r(); if (i === void 0) throw new Error("Context is not available"); return i }, tryUse: () => r(), set: (i, a) => { a || s(i), t = i, n = !0 }, unset: () => { t = void 0, n = !1 }, call: (i, a) => { s(i), t = i; try { return o ? o.run(i, a) : a() } finally { n || (t = void 0) } }, async callAsync(i, a) { t = i; const c = () => { t = i }, u = () => t === i ? c : void 0; Dr.add(u); try { const l = o ? o.run(i, a) : a(); return n || (t = void 0), await l } finally { Dr.delete(u) } } } } function kg(e = {}) { const t = {}; return { get(n, s = {}) { return t[n] || (t[n] = Eg({ ...e, ...s })), t[n] } } } const _o = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof global < "u" ? global : typeof window < "u" ? window : {}, Pa = "__unctx__", xg = _o[Pa] || (_o[Pa] = kg()), Tg = (e, t = {}) => xg.get(e, t), Sa = "__unctx_async_handlers__", Dr = _o[Sa] || (_o[Sa] = new Set); function An(e) { const t = []; for (const o of Dr) { const r = o(); r && t.push(r) } const n = () => { for (const o of t) o() }; let s = e(); return s && typeof s == "object" && "catch" in s && (s = s.catch(o => { throw n(), o })), [s, n] } const Ca = !1, Pg = !1, Ra = { id: "__nuxt-loader" }, yw = { componentName: "NuxtLink", prefetch: !0, prefetchOn: { visibility: !0 } }, _w = { deep: !1 }, Sg = void 0, Cg = "#__nuxt", wu = "nuxt-app", Aa = 36e5, Rg = "vite:preloadError"; function Eu(e = wu) { return Tg(e, { asyncContext: !1 }) } const Ag = "__nuxt_plugin"; function Ig(e) { var o; let t = 0; const n = { _id: e.id || wu || "nuxt-app", _scope: Bf(), provide: void 0, globalName: "nuxt", versions: { get nuxt() { return "3.17.5" }, get vue() { return n.vueApp.version } }, payload: Rt({ ...((o = e.ssrContext) == null ? void 0 : o.payload) || {}, data: Rt({}), state: ht({}), once: new Set, _errors: Rt({}) }), static: { data: {} }, runWithContext(r) { return n._scope.active && !Ac() ? n._scope.run(() => Ia(n, r)) : Ia(n, r) }, isHydrating: !0, deferHydration() { if (!n.isHydrating) return () => { }; t++; let r = !1; return () => { if (!r && (r = !0, t--, t === 0)) return n.isHydrating = !1, n.callHook("app:suspense:resolve") } }, _asyncDataPromises: {}, _asyncData: Rt({}), _payloadRevivers: {}, ...e }; { const r = window.__NUXT__; if (r) for (const i in r) switch (i) { case "data": case "state": case "_errors": Object.assign(n.payload[i], r[i]); break; default: n.payload[i] = r[i] } } n.hooks = vu(), n.hook = n.hooks.hook, n.callHook = n.hooks.callHook, n.provide = (r, i) => { const a = "$" + r; Ds(n, a, i), Ds(n.vueApp.config.globalProperties, a, i) }, Ds(n.vueApp, "$nuxt", n), Ds(n.vueApp.config.globalProperties, "$nuxt", n); { window.addEventListener(Rg, i => { n.callHook("app:chunkError", { error: i.payload }), i.payload.message.includes("Unable to preload CSS") && i.preventDefault() }), window.useNuxtApp || (window.useNuxtApp = we); const r = n.hook("app:error", (...i) => { console.error("[nuxt] error caught during app initialization", ...i) }); n.hook("app:mounted", r) } const s = n.payload.config; return n.provide("config", s), n } function Og(e, t) { t.hooks && e.hooks.addHooks(t.hooks) } async function Mg(e, t) { if (typeof t == "function") { const { provide: n } = await e.runWithContext(() => t(e)) || {}; if (n && typeof n == "object") for (const s in n) e.provide(s, n[s]) } } async function Lg(e, t) { const n = new Set, s = [], o = [], r = []; let i = 0; async function a(c) { var l; const u = ((l = c.dependsOn) == null ? void 0 : l.filter(f => t.some(h => h._name === f) && !n.has(f))) ?? []; if (u.length > 0) s.push([new Set(u), c]); else { const f = Mg(e, c).then(async () => { c._name && (n.add(c._name), await Promise.all(s.map(async ([h, p]) => { h.has(c._name) && (h.delete(c._name), h.size === 0 && (i++, await a(p))) }))) }); c.parallel ? o.push(f.catch(h => r.push(h))) : await f } } for (const c of t) Og(e, c); for (const c of t) await a(c); if (await Promise.all(o), i) for (let c = 0; c < i; c++)await Promise.all(o); if (r.length) throw r[0] } function qe(e) { if (typeof e == "function") return e; const t = e._name || e.name; return delete e.name, Object.assign(e.setup || (() => { }), e, { [Ag]: !0, _name: t }) } function Ia(e, t, n) { const s = () => t(); return Eu(e._id).set(e), e.vueApp.runWithContext(s) } function Ng(e) { var n; let t; return Ho() && (t = (n = Je()) == null ? void 0 : n.appContext.app.$nuxt), t || (t = Eu(e).tryUse()), t || null } function we(e) { const t = Ng(e); if (!t) throw new Error("[nuxt] instance unavailable"); return t } function pn(e) { return we().$config } function Ds(e, t, n) { Object.defineProperty(e, t, { get: () => n }) } function Hg(e, t) { return { ctx: { table: e }, matchAll: n => xu(n, e) } } function ku(e) { const t = {}; for (const n in e) t[n] = n === "dynamic" ? new Map(Object.entries(e[n]).map(([s, o]) => [s, ku(o)])) : new Map(Object.entries(e[n])); return t } function Dg(e) { return Hg(ku(e)) } function xu(e, t, n) { e.endsWith("/") && (e = e.slice(0, -1) || "/"); const s = []; for (const [r, i] of Oa(t.wildcard)) (e === r || e.startsWith(r + "/")) && s.push(i); for (const [r, i] of Oa(t.dynamic)) if (e.startsWith(r + "/")) { const a = "/" + e.slice(r.length).split("/").splice(2).join("/"); s.push(...xu(a, i)) } const o = t.static.get(e); return o && s.push(o), s.filter(Boolean) } function Oa(e) { return [...e.entries()].sort((t, n) => t[0].length - n[0].length) } function rr(e) { if (e === null || typeof e != "object") return !1; const t = Object.getPrototypeOf(e); return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0 } function Fr(e, t, n = ".", s) { if (!rr(t)) return Fr(e, {}, n, s); const o = Object.assign({}, t); for (const r in e) { if (r === "__proto__" || r === "constructor") continue; const i = e[r]; i != null && (s && s(o, r, i, n) || (Array.isArray(i) && Array.isArray(o[r]) ? o[r] = [...i, ...o[r]] : rr(i) && rr(o[r]) ? o[r] = Fr(i, o[r], (n ? `${n}.` : "") + r.toString(), s) : o[r] = i)) } return o } function Tu(e) { return (...t) => t.reduce((n, s) => Fr(n, s, "", e), {}) } const Pu = Tu(), Fg = Tu((e, t, n) => { if (e[t] !== void 0 && typeof n == "function") return e[t] = n(e[t]), !0 }); function $g(e, t) { try { return t in e } catch { return !1 } } class $r extends Error { constructor(n, s = {}) { super(n, s); Dt(this, "statusCode", 500); Dt(this, "fatal", !1); Dt(this, "unhandled", !1); Dt(this, "statusMessage"); Dt(this, "data"); Dt(this, "cause"); s.cause && !this.cause && (this.cause = s.cause) } toJSON() { const n = { message: this.message, statusCode: jr(this.statusCode, 500) }; return this.statusMessage && (n.statusMessage = Su(this.statusMessage)), this.data !== void 0 && (n.data = this.data), n } } Dt($r, "__h3_error__", !0); function jg(e) { if (typeof e == "string") return new $r(e); if (Ug(e)) return e; const t = new $r(e.message ?? e.statusMessage ?? "", { cause: e.cause || e }); if ($g(e, "stack")) try { Object.defineProperty(t, "stack", { get() { return e.stack } }) } catch { try { t.stack = e.stack } catch { } } if (e.data && (t.data = e.data), e.statusCode ? t.statusCode = jr(e.statusCode, t.statusCode) : e.status && (t.statusCode = jr(e.status, t.statusCode)), e.statusMessage ? t.statusMessage = e.statusMessage : e.statusText && (t.statusMessage = e.statusText), t.statusMessage) { const n = t.statusMessage; Su(t.statusMessage) !== n && console.warn("[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.") } return e.fatal !== void 0 && (t.fatal = e.fatal), e.unhandled !== void 0 && (t.unhandled = e.unhandled), t } function Ug(e) { var t; return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.__h3_error__) === !0 } const Vg = /[^\u0009\u0020-\u007E]/g; function Su(e = "") { return e.replace(Vg, "") } function jr(e, t = 200) { return !e || (typeof e == "string" && (e = Number.parseInt(e, 10)), e < 100 || e > 999) ? t : e } const Bg = Symbol("layout-meta"), $o = Symbol("route"), Qe = () => { var e; return (e = we()) == null ? void 0 : e.$router }, Cu = () => Ho() ? ze($o, we()._route) : we()._route; const Wg = () => { try { if (we()._processingMiddleware) return !0 } catch { return !1 } return !1 }, bw = (e, t) => { e || (e = "/"); const n = typeof e == "string" ? e : "path" in e ? Kg(e) : Qe().resolve(e).href; if (t != null && t.open) { const { target: c = "_blank", windowFeatures: u = {} } = t.open, l = Object.entries(u).filter(([f, h]) => h !== void 0).map(([f, h]) => `${f.toLowerCase()}=${h}`).join(", "); return open(n, c, l), Promise.resolve() } const s = dn(n, { acceptRelative: !0 }), o = (t == null ? void 0 : t.external) || s; if (o) { if (!(t != null && t.external)) throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`."); const { protocol: c } = new URL(n, window.location.href); if (c && Kp(c)) throw new Error(`Cannot navigate to a URL with '${c}' protocol.`) } const r = Wg(); if (!o && r) { if (t != null && t.replace) { if (typeof e == "string") { const { pathname: c, search: u, hash: l } = yu(e); return { path: c, ...u && { query: hu(u) }, ...l && { hash: l }, replace: !0 } } return { ...e, replace: !0 } } return e } const i = Qe(), a = we(); return o ? (a._scope.stop(), t != null && t.replace ? location.replace(n) : location.href = n, r ? a.isHydrating ? new Promise(() => { }) : !1 : Promise.resolve()) : t != null && t.replace ? i.replace(e) : i.push(e) }; function Kg(e) { return du(e.path || "", e.query || {}) + (e.hash || "") } const Ru = "__nuxt_error", jo = () => Yc(we().payload, "error"), en = e => { const t = rn(e); try { const n = we(), s = jo(); n.hooks.callHook("app:error", t), s.value || (s.value = t) } catch { throw t } return t }, zg = async (e = {}) => { const t = we(), n = jo(); t.callHook("app:error:cleared", e), e.redirect && await Qe().replace(e.redirect), n.value = Sg }, Au = e => !!e && typeof e == "object" && Ru in e, rn = e => { const t = jg(e); return Object.defineProperty(t, Ru, { value: !0, configurable: !1, writable: !1 }), t }; function Ma(e) { const t = Gg(e), n = new ArrayBuffer(t.length), s = new DataView(n); for (let o = 0; o < n.byteLength; o++)s.setUint8(o, t.charCodeAt(o)); return n } const qg = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; function Gg(e) { e.length % 4 === 0 && (e = e.replace(/==?$/, "")); let t = "", n = 0, s = 0; for (let o = 0; o < e.length; o++)n <<= 6, n |= qg.indexOf(e[o]), s += 6, s === 24 && (t += String.fromCharCode((n & 16711680) >> 16), t += String.fromCharCode((n & 65280) >> 8), t += String.fromCharCode(n & 255), n = s = 0); return s === 12 ? (n >>= 4, t += String.fromCharCode(n)) : s === 18 && (n >>= 2, t += String.fromCharCode((n & 65280) >> 8), t += String.fromCharCode(n & 255)), t } const Yg = -1, Qg = -2, Jg = -3, Xg = -4, Zg = -5, em = -6; function tm(e, t) { return nm(JSON.parse(e), t) } function nm(e, t) { if (typeof e == "number") return o(e, !0); if (!Array.isArray(e) || e.length === 0) throw new Error("Invalid input"); const n = e, s = Array(n.length); function o(r, i = !1) { if (r === Yg) return; if (r === Jg) return NaN; if (r === Xg) return 1 / 0; if (r === Zg) return -1 / 0; if (r === em) return -0; if (i) throw new Error("Invalid input"); if (r in s) return s[r]; const a = n[r]; if (!a || typeof a != "object") s[r] = a; else if (Array.isArray(a)) if (typeof a[0] == "string") { const c = a[0], u = t == null ? void 0 : t[c]; if (u) return s[r] = u(o(a[1])); switch (c) { case "Date": s[r] = new Date(a[1]); break; case "Set": const l = new Set; s[r] = l; for (let p = 1; p < a.length; p += 1)l.add(o(a[p])); break; case "Map": const f = new Map; s[r] = f; for (let p = 1; p < a.length; p += 2)f.set(o(a[p]), o(a[p + 1])); break; case "RegExp": s[r] = new RegExp(a[1], a[2]); break; case "Object": s[r] = Object(a[1]); break; case "BigInt": s[r] = BigInt(a[1]); break; case "null": const h = Object.create(null); s[r] = h; for (let p = 1; p < a.length; p += 2)h[a[p]] = o(a[p + 1]); break; case "Int8Array": case "Uint8Array": case "Uint8ClampedArray": case "Int16Array": case "Uint16Array": case "Int32Array": case "Uint32Array": case "Float32Array": case "Float64Array": case "BigInt64Array": case "BigUint64Array": { const p = globalThis[c], _ = a[1], g = Ma(_), E = new p(g); s[r] = E; break } case "ArrayBuffer": { const p = a[1], _ = Ma(p); s[r] = _; break } default: throw new Error(`Unknown type ${c}`) } } else { const c = new Array(a.length); s[r] = c; for (let u = 0; u < a.length; u += 1) { const l = a[u]; l !== Qg && (c[u] = o(l)) } } else { const c = {}; s[r] = c; for (const u in a) { const l = a[u]; c[u] = o(l) } } return s[r] } return o(0) } const sm = new Set(["link", "style", "script", "noscript"]), om = new Set(["title", "titleTemplate", "script", "style", "noscript"]), La = new Set(["base", "meta", "link", "style", "script", "noscript"]), rm = new Set(["title", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"]), im = new Set(["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"]), am = new Set(["key", "tagPosition", "tagPriority", "tagDuplicateStrategy", "innerHTML", "textContent", "processTemplateParams"]), cm = new Set(["templateParams", "htmlAttrs", "bodyAttrs"]), xi = new Set(["theme-color", "google-site-verification", "og", "article", "book", "profile", "twitter", "author"]), hs = { META: new Set(["twitter"]), OG: new Set(["og", "book", "article", "profile", "fb"]), MEDIA: new Set(["ogImage", "ogVideo", "ogAudio", "twitterImage"]), HTTP_EQUIV: new Set(["contentType", "defaultStyle", "xUaCompatible"]) }, lm = { articleExpirationTime: "article:expiration_time", articleModifiedTime: "article:modified_time", articlePublishedTime: "article:published_time", bookReleaseDate: "book:release_date", fbAppId: "fb:app_id", ogAudioSecureUrl: "og:audio:secure_url", ogAudioUrl: "og:audio", ogImageSecureUrl: "og:image:secure_url", ogImageUrl: "og:image", ogSiteName: "og:site_name", ogVideoSecureUrl: "og:video:secure_url", ogVideoUrl: "og:video", profileFirstName: "profile:first_name", profileLastName: "profile:last_name", profileUsername: "profile:username", msapplicationConfig: "msapplication-Config", msapplicationTileColor: "msapplication-TileColor", msapplicationTileImage: "msapplication-TileImage" }, Iu = { appleItunesApp: { unpack: { entrySeparator: ", ", resolve: ({ key: e, value: t }) => `${At(e)}=${t}` } }, refresh: { metaKey: "http-equiv", unpack: { entrySeparator: ";", resolve: ({ key: e, value: t }) => e === "seconds" ? `${t}` : void 0 } }, robots: { unpack: { entrySeparator: ", ", resolve: ({ key: e, value: t }) => typeof t == "boolean" ? At(e) : `${At(e)}:${t}` } }, contentSecurityPolicy: { metaKey: "http-equiv", unpack: { entrySeparator: "; ", resolve: ({ key: e, value: t }) => `${At(e)} ${t}` } }, charset: {} }; function At(e) { const t = e.replace(/([A-Z])/g, "-$1").toLowerCase(), n = t.indexOf("-"); return n === -1 ? t : hs.META.has(t.slice(0, n)) || hs.OG.has(t.slice(0, n)) ? e.replace(/([A-Z])/g, ":$1").toLowerCase() : t } function Ou(e) { return Object.fromEntries(Object.entries(e).filter(([t, n]) => String(n) !== "false" && t)) } function Ur(e) { return Array.isArray(e) ? e.map(Ur) : !e || typeof e != "object" ? e : Object.fromEntries(Object.entries(e).map(([t, n]) => [At(t), Ur(n)])) } function Mu(e, t = {}) { const { entrySeparator: n = "", keyValueSeparator: s = "", wrapValue: o, resolve: r } = t; return Object.entries(e).map(([i, a]) => { if (r) { const u = r({ key: i, value: a }); if (u !== void 0) return u } const c = typeof a == "object" ? Mu(a, t) : typeof a == "number" ? a.toString() : typeof a == "string" && o ? `${o}${a.replace(new RegExp(o, "g"), `\\${o}`)}${o}` : a; return `${i}${s}${c}` }).join(n) } function Na(e, t) { const n = Ou(t), s = At(e), o = Lu(s); if (!xi.has(s)) return [{ [o]: s, ...n }]; const r = Object.fromEntries(Object.entries(n).map(([i, a]) => [`${e}${i === "url" ? "" : `${i[0].toUpperCase()}${i.slice(1)}`}`, a])); return bo(r || {}).sort((i, a) => { var c, u; return (((c = i[o]) == null ? void 0 : c.length) || 0) - (((u = a[o]) == null ? void 0 : u.length) || 0) }) } function Lu(e) { var s; if (((s = Iu[e]) == null ? void 0 : s.metaKey) === "http-equiv" || hs.HTTP_EQUIV.has(e)) return "http-equiv"; const t = At(e), n = t.indexOf(":"); return n === -1 ? "name" : hs.OG.has(t.slice(0, n)) ? "property" : "name" } function um(e) { return lm[e] || At(e) } function fm(e, t) { var n; return t === "refresh" ? `${e.seconds};url=${e.url}` : Mu(Ur(e), { keyValueSeparator: "=", entrySeparator: ", ", resolve: ({ value: s, key: o }) => s === null ? "" : typeof s == "boolean" ? o : void 0, ...(n = Iu[t]) == null ? void 0 : n.unpack }) } function bo(e) { const t = [], n = {}; for (const [o, r] of Object.entries(e)) { if (Array.isArray(r)) { if (o === "themeColor") { r.forEach(i => { typeof i == "object" && i !== null && t.push({ name: "theme-color", ...i }) }); continue } for (const i of r) if (typeof i == "object" && i !== null) { const a = [], c = []; for (const [u, l] of Object.entries(i)) { const f = `${o}${u === "url" ? "" : `:${u}`}`, h = bo({ [f]: l }); (u === "url" ? a : c).push(...h) } t.push(...a, ...c) } else t.push(...typeof i == "string" ? bo({ [o]: i }) : Na(o, i)); continue } if (typeof r == "object" && r) if (hs.MEDIA.has(o)) { const i = o.startsWith("twitter") ? "twitter" : "og", a = o.replace(/^(og|twitter)/, "").toLowerCase(), c = i === "twitter" ? "name" : "property"; r.url && t.push({ [c]: `${i}:${a}`, content: r.url }), r.secureUrl && t.push({ [c]: `${i}:${a}:secure_url`, content: r.secureUrl }); for (const [u, l] of Object.entries(r)) u !== "url" && u !== "secureUrl" && t.push({ [c]: `${i}:${a}:${u}`, content: l }) } else xi.has(At(o)) ? t.push(...Na(o, r)) : n[o] = Ou(r); else n[o] = r } const s = Object.entries(n).map(([o, r]) => { if (o === "charset") return { charset: r === null ? "_null" : r }; const i = Lu(o), a = um(o), c = r === null ? "_null" : typeof r == "object" ? fm(r, o) : typeof r == "number" ? r.toString() : r; return i === "http-equiv" ? { "http-equiv": a, content: c } : { [i]: a, content: c } }); return [...t, ...s].map(o => "content" in o && o.content === "_null" ? { ...o, content: null } : o) } const hm = { key: "flatMeta", hooks: { "entries:normalize": e => { const t = []; e.tags = e.tags.map(n => n.tag !== "_flatMeta" ? n : (t.push(bo(n.props).map(s => ({ ...n, tag: "meta", props: s }))), !1)).filter(Boolean).concat(...t) } } }, dm = ["name", "property", "http-equiv"], pm = new Set(["viewport", "description", "keywords", "robots"]); function Nu(e) { const t = e.split(":"); return t.length ? xi.has(t[1]) : !1 } function Vr(e) { const { props: t, tag: n } = e; if (im.has(n)) return n; if (n === "link" && t.rel === "canonical") return "canonical"; if (t.charset) return "charset"; if (e.tag === "meta") { for (const s of dm) if (t[s] !== void 0) { const o = t[s], r = o.includes(":"), i = pm.has(o), c = !(r || i) && e.key ? `:key:${e.key}` : ""; return `${n}:${o}${c}` } } if (e.key) return `${n}:key:${e.key}`; if (t.id) return `${n}:id:${t.id}`; if (om.has(n)) { const s = e.textContent || e.innerHTML; if (s) return `${n}:content:${s}` } } function Ha(e) { const t = e._h || e._d; if (t) return t; const n = e.textContent || e.innerHTML; return n || `${e.tag}:${Object.entries(e.props).map(([s, o]) => `${s}:${String(o)}`).join(",")}` } function vo(e, t, n) { typeof e === "function" && (!n || n !== "titleTemplate" && !(n[0] === "o" && n[1] === "n")) && (e = e()); let o; if (t && (o = t(n, e)), Array.isArray(o)) return o.map(r => vo(r, t)); if ((o == null ? void 0 : o.constructor) === Object) { const r = {}; for (const i of Object.keys(o)) r[i] = vo(o[i], t, i); return r } return o } function gm(e, t) { const n = e === "style" ? new Map : new Set; function s(o) { const r = o.trim(); if (r) if (e === "style") { const [i, ...a] = r.split(":").map(c => c.trim()); i && a.length && n.set(i, a.join(":")) } else r.split(" ").filter(Boolean).forEach(i => n.add(i)) } return typeof t == "string" ? e === "style" ? t.split(";").forEach(s) : s(t) : Array.isArray(t) ? t.forEach(o => s(o)) : t && typeof t == "object" && Object.entries(t).forEach(([o, r]) => { r && r !== "false" && (e === "style" ? n.set(o.trim(), r) : s(o)) }), n } function Hu(e, t) { return e.props = e.props || {}, t && Object.entries(t).forEach(([n, s]) => { if (s === null) { e.props[n] = null; return } if (n === "class" || n === "style") { e.props[n] = gm(n, s); return } if (am.has(n)) { if (["textContent", "innerHTML"].includes(n) && typeof s == "object") { let i = t.type; if (t.type || (i = "application/json"), !(i != null && i.endsWith("json")) && i !== "speculationrules") return; t.type = i, e.props.type = i, e[n] = JSON.stringify(s) } else e[n] = s; return } const o = String(s), r = n.startsWith("data-"); o === "true" || o === "" ? e.props[n] = r ? o : !0 : !s && r && o === "false" ? e.props[n] = "false" : s !== void 0 && (e.props[n] = s) }), e } function mm(e, t) { const n = typeof t == "object" && typeof t != "function" ? t : { [e === "script" || e === "noscript" || e === "style" ? "innerHTML" : "textContent"]: t }, s = Hu({ tag: e, props: {} }, n); return s.key && sm.has(s.tag) && (s.props["data-hid"] = s._h = s.key), s.tag === "script" && typeof s.innerHTML == "object" && (s.innerHTML = JSON.stringify(s.innerHTML), s.props.type = s.props.type || "application/json"), Array.isArray(s.props.content) ? s.props.content.map(o => ({ ...s, props: { ...s.props, content: o } })) : s } function ym(e, t) { if (!e) return []; typeof e == "function" && (e = e()); const n = (o, r) => { for (let i = 0; i < t.length; i++)r = t[i](o, r); return r }; e = n(void 0, e); const s = []; return e = vo(e, n), Object.entries(e || {}).forEach(([o, r]) => { if (r !== void 0) for (const i of Array.isArray(r) ? r : [r]) s.push(mm(o, i)) }), s.flat() } const Da = (e, t) => e._w === t._w ? e._p - t._p : e._w - t._w, Fa = { base: -10, title: 10 }, _m = { critical: -8, high: -1, low: 2 }, $a = { meta: { "content-security-policy": -30, charset: -20, viewport: -15 }, link: { preconnect: 20, stylesheet: 60, preload: 70, modulepreload: 70, prefetch: 90, "dns-prefetch": 90, prerender: 90 }, script: { async: 30, defer: 80, sync: 50 }, style: { imported: 40, sync: 60 } }, bm = /@import/, Bn = e => e === "" || e === !0; function vm(e, t) { var r; if (typeof t.tagPriority == "number") return t.tagPriority; let n = 100; const s = _m[t.tagPriority] || 0, o = e.resolvedOptions.disableCapoSorting ? { link: {}, script: {}, style: {} } : $a; if (t.tag in Fa) n = Fa[t.tag]; else if (t.tag === "meta") { const i = t.props["http-equiv"] === "content-security-policy" ? "content-security-policy" : t.props.charset ? "charset" : t.props.name === "viewport" ? "viewport" : null; i && (n = $a.meta[i]) } else t.tag === "link" && t.props.rel ? n = o.link[t.props.rel] : t.tag === "script" ? Bn(t.props.async) ? n = o.script.async : t.props.src && !Bn(t.props.defer) && !Bn(t.props.async) && t.props.type !== "module" && !((r = t.props.type) != null && r.endsWith("json")) ? n = o.script.sync : Bn(t.props.defer) && t.props.src && !Bn(t.props.async) && (n = o.script.defer) : t.tag === "style" && (n = t.innerHTML && bm.test(t.innerHTML) ? o.style.imported : o.style.sync); return (n || 100) + s } function ja(e, t) { const n = typeof t == "function" ? t(e) : t, s = n.key || String(e.plugins.size + 1); e.plugins.get(s) || (e.plugins.set(s, n), e.hooks.addHooks(n.hooks || {})) } function wm(e = {}) { var a; const t = vu(); t.addHooks(e.hooks || {}); const n = !e.document, s = new Map, o = new Map, r = [], i = { _entryCount: 1, plugins: o, dirty: !1, resolvedOptions: e, hooks: t, ssr: n, entries: s, headEntries() { return [...s.values()] }, use: c => ja(i, c), push(c, u) { const l = { ...u || {} }; delete l.head; const f = l._index ?? i._entryCount++, h = { _i: f, input: c, options: l }, p = { _poll(_ = !1) { i.dirty = !0, !_ && r.push(f), t.callHook("entries:updated", i) }, dispose() { s.delete(f) && p._poll(!0) }, patch(_) { (!l.mode || l.mode === "server" && n || l.mode === "client" && !n) && (h.input = _, s.set(f, h), p._poll()) } }; return p.patch(c), p }, async resolveTags() { var p; const c = { tagMap: new Map, tags: [], entries: [...i.entries.values()] }; for (await t.callHook("entries:resolve", c); r.length;) { const _ = r.shift(), g = s.get(_); if (g) { const E = { tags: ym(g.input, e.propResolvers || []).map(k => Object.assign(k, g.options)), entry: g }; await t.callHook("entries:normalize", E), g._tags = E.tags.map((k, w) => (k._w = vm(i, k), k._p = (g._i << 10) + w, k._d = Vr(k), k)) } } let u = !1; c.entries.flatMap(_ => (_._tags || []).map(g => ({ ...g, props: { ...g.props } }))).sort(Da).reduce((_, g) => { const E = String(g._d || g._p); if (!_.has(E)) return _.set(E, g); const k = _.get(E); if (((g == null ? void 0 : g.tagDuplicateStrategy) || (cm.has(g.tag) ? "merge" : null) || (g.key && g.key === k.key ? "merge" : null)) === "merge") { const d = { ...k.props }; Object.entries(g.props).forEach(([y, x]) => d[y] = y === "style" ? new Map([...k.props.style || new Map, ...x]) : y === "class" ? new Set([...k.props.class || new Set, ...x]) : x), _.set(E, { ...g, props: d }) } else g._p >> 10 === k._p >> 10 && g.tag === "meta" && Nu(E) ? (_.set(E, Object.assign([...Array.isArray(k) ? k : [k], g], g)), u = !0) : (g._w === k._w ? g._p > k._p : (g == null ? void 0 : g._w) < (k == null ? void 0 : k._w)) && _.set(E, g); return _ }, c.tagMap); const l = c.tagMap.get("title"), f = c.tagMap.get("titleTemplate"); if (i._title = l == null ? void 0 : l.textContent, f) { const _ = f == null ? void 0 : f.textContent; if (i._titleTemplate = _, _) { let g = typeof _ == "function" ? _(l == null ? void 0 : l.textContent) : _; typeof g == "string" && !i.plugins.has("template-params") && (g = g.replace("%s", (l == null ? void 0 : l.textContent) || "")), l ? g === null ? c.tagMap.delete("title") : c.tagMap.set("title", { ...l, textContent: g }) : (f.tag = "title", f.textContent = g) } } c.tags = Array.from(c.tagMap.values()), u && (c.tags = c.tags.flat().sort(Da)), await t.callHook("tags:beforeResolve", c), await t.callHook("tags:resolve", c), await t.callHook("tags:afterResolve", c); const h = []; for (const _ of c.tags) { const { innerHTML: g, tag: E, props: k } = _; if (rm.has(E) && !(Object.keys(k).length === 0 && !_.innerHTML && !_.textContent) && !(E === "meta" && !k.content && !k["http-equiv"] && !k.charset)) { if (E === "script" && g) { if ((p = k.type) != null && p.endsWith("json")) { const w = typeof g == "string" ? g : JSON.stringify(g); _.innerHTML = w.replace(/</g, "\\u003C") } else typeof g == "string" && (_.innerHTML = g.replace(new RegExp(`</${E}`, "g"), `<\\/${E}`)); _._d = Vr(_) } h.push(_) } } return h } }; return ((e == null ? void 0 : e.plugins) || []).forEach(c => ja(i, c)), i.hooks.callHook("init", i), (a = e.init) == null || a.forEach(c => c && i.push(c)), i } const Em = (e, t) => xe(t) ? fh(t) : t, Ti = "usehead"; function km(e) { return { install(n) { n.config.globalProperties.$unhead = e, n.config.globalProperties.$head = e, n.provide(Ti, e) } }.install } function Du() { if (Ho()) { const e = ze(Ti); if (!e) throw new Error("useHead() was called without provide context, ensure you call it through the setup() function."); return e } throw new Error("useHead() was called without provide context, ensure you call it through the setup() function.") } function Fu(e, t = {}) { const n = t.head || Du(); return n.ssr ? n.push(e || {}, t) : xm(n, e, t) } function xm(e, t, n = {}) { const s = $e(!1); let o; return fd(() => { const i = s.value ? {} : vo(t, Em); o ? o.patch(i) : o = e.push(i, n) }), Je() && (vs(() => { o.dispose() }), hl(() => { s.value = !0 }), fl(() => { s.value = !1 })), o } function Tm(e = {}, t = {}) { (t.head || Du()).use(hm); const { title: s, titleTemplate: o, ...r } = e; return Fu({ title: s, titleTemplate: o, _flatMeta: r }, t) } function $u(e) { var n; const t = e || we(); return ((n = t.ssrContext) == null ? void 0 : n.head) || t.runWithContext(() => { if (Ho()) { const s = ze(Ti); if (!s) throw new Error("[nuxt] [unhead] Missing Unhead instance."); return s } }) } function ju(e, t = {}) { const n = $u(t.nuxt); return Fu(e, { head: n, ...t }) } function Pm(e, t = {}) { const n = $u(t.nuxt); return Tm(e, { head: n, ...t }) } const Sm = "modulepreload", Cm = function (e, t) { return new URL(e, t).href }, Ua = {}, J = function (t, n, s) { let o = Promise.resolve(); if (n && n.length > 0) { let i = function (l) { return Promise.all(l.map(f => Promise.resolve(f).then(h => ({ status: "fulfilled", value: h }), h => ({ status: "rejected", reason: h })))) }; const a = document.getElementsByTagName("link"), c = document.querySelector("meta[property=csp-nonce]"), u = (c == null ? void 0 : c.nonce) || (c == null ? void 0 : c.getAttribute("nonce")); o = i(n.map(l => { if (l = Cm(l, s), l in Ua) return; Ua[l] = !0; const f = l.endsWith(".css"), h = f ? '[rel="stylesheet"]' : ""; if (!!s) for (let g = a.length - 1; g >= 0; g--) { const E = a[g]; if (E.href === l && (!f || E.rel === "stylesheet")) return } else if (document.querySelector(`link[href="${l}"]${h}`)) return; const _ = document.createElement("link"); if (_.rel = f ? "stylesheet" : Sm, f || (_.as = "script"), _.crossOrigin = "", _.href = l, u && _.setAttribute("nonce", u), document.head.appendChild(_), f) return new Promise((g, E) => { _.addEventListener("load", g), _.addEventListener("error", () => E(new Error(`Unable to preload CSS for ${l}`))) }) })) } function r(i) { const a = new Event("vite:preloadError", { cancelable: !0 }); if (a.payload = i, window.dispatchEvent(a), !a.defaultPrevented) throw i } return o.then(i => { for (const a of i || []) a.status === "rejected" && r(a.reason); return t().catch(r) }) }; let Ks, zs; function Rm() { return Ks = $fetch(Ei(`builds/meta/${pn().app.buildId}.json`), { responseType: "json" }), Ks.then(e => { zs = Dg(e.matcher) }).catch(e => { console.error("[nuxt] Error fetching app manifest.", e) }), Ks } function Uo() { return Ks || Rm() } async function Pi(e) { const t = typeof e == "string" ? e : e.path; if (await Uo(), !zs) return console.error("[nuxt] Error creating app manifest matcher.", zs), {}; try { return Pu({}, ...zs.matchAll(t).reverse()) } catch (n) { return console.error("[nuxt] Error matching route rules.", n), {} } } async function Va(e, t = {}) { if (!await Vu(e)) return null; const s = await Im(e, t); return await Uu(s) || null } const Am = "_payload.json"; async function Im(e, t = {}) { const n = new URL(e, "http://localhost"); if (n.host !== "localhost" || dn(n.pathname, { acceptRelative: !0 })) throw new Error("Payload URL must not include hostname: " + e); const s = pn(), o = t.hash || (t.fresh ? Date.now() : s.app.buildId), r = s.app.cdnURL, i = r && await Vu(e) ? r : s.app.baseURL; return wi(i, n.pathname, Am + (o ? `?${o}` : "")) } async function Uu(e) { const t = fetch(e, { cache: "force-cache" }).then(n => n.text().then(Bu)); try { return await t } catch (n) { console.warn("[nuxt] Cannot load payload ", e, n) } return null } async function Vu(e = Cu().path) { const t = we(); return e = fs(e), (await Uo()).prerendered.includes(e) ? !0 : t.runWithContext(async () => { const s = await Pi({ path: e }); return !!s.prerender && !s.redirect }) } let Zt = null; async function Om() { var s; if (Zt) return Zt; const e = document.getElementById("__NUXT_DATA__"); if (!e) return {}; const t = await Bu(e.textContent || ""), n = e.dataset.src ? await Uu(e.dataset.src) : void 0; return Zt = { ...t, ...n, ...window.__NUXT__ }, (s = Zt.config) != null && s.public && (Zt.config.public = ht(Zt.config.public)), Zt } async function Bu(e) { return await tm(e, we()._payloadRevivers) } function Mm(e, t) { we()._payloadRevivers[e] = t } const Lm = [["NuxtError", e => rn(e)], ["EmptyShallowRef", e => an(e === "_" ? void 0 : e === "0n" ? BigInt(0) : po(e))], ["EmptyRef", e => $e(e === "_" ? void 0 : e === "0n" ? BigInt(0) : po(e))], ["ShallowRef", e => an(e)], ["ShallowReactive", e => Rt(e)], ["Ref", e => $e(e)], ["Reactive", e => ht(e)]], Nm = qe({ name: "nuxt:revive-payload:client", order: -30, async setup(e) { let t, n; for (const [s, o] of Lm) Mm(s, o); Object.assign(e.payload, ([t, n] = An(() => e.runWithContext(Om)), t = await t, n(), t)), window.__NUXT__ = e.payload } }); async function Si(e, t = {}) { const n = t.document || e.resolvedOptions.document; if (!n || !e.dirty) return; const s = { shouldRender: !0, tags: [] }; if (await e.hooks.callHook("dom:beforeRender", s), !!s.shouldRender) return e._domUpdatePromise || (e._domUpdatePromise = new Promise(async o => { var p; const r = new Map, i = new Promise(_ => { e.resolveTags().then(g => { _(g.map(E => { const k = r.get(E._d) || 0, w = { tag: E, id: (k ? `${E._d}:${k}` : E._d) || Ha(E), shouldRender: !0 }; return E._d && Nu(E._d) && r.set(E._d, k + 1), w })) }) }); let a = e._dom; if (!a) { a = { title: n.title, elMap: new Map().set("htmlAttrs", n.documentElement).set("bodyAttrs", n.body) }; for (const _ of ["body", "head"]) { const g = (p = n[_]) == null ? void 0 : p.children; for (const E of g) { const k = E.tagName.toLowerCase(); if (!La.has(k)) continue; const w = Hu({ tag: k, props: {} }, { innerHTML: E.innerHTML, ...E.getAttributeNames().reduce((d, y) => (d[y] = E.getAttribute(y), d), {}) || {} }); if (w.key = E.getAttribute("data-hid") || void 0, w._d = Vr(w) || Ha(w), a.elMap.has(w._d)) { let d = 1, y = w._d; for (; a.elMap.has(y);)y = `${w._d}:${d++}`; a.elMap.set(y, E) } else a.elMap.set(w._d, E) } } } a.pendingSideEffects = { ...a.sideEffects }, a.sideEffects = {}; function c(_, g, E) { const k = `${_}:${g}`; a.sideEffects[k] = E, delete a.pendingSideEffects[k] } function u({ id: _, $el: g, tag: E }) { const k = E.tag.endsWith("Attrs"); a.elMap.set(_, g), k || (E.textContent && E.textContent !== g.textContent && (g.textContent = E.textContent), E.innerHTML && E.innerHTML !== g.innerHTML && (g.innerHTML = E.innerHTML), c(_, "el", () => { g == null || g.remove(), a.elMap.delete(_) })); for (const w in E.props) { if (!Object.prototype.hasOwnProperty.call(E.props, w)) continue; const d = E.props[w]; if (w.startsWith("on") && typeof d == "function") { const x = g == null ? void 0 : g.dataset; if (x && x[`${w}fired`]) { const T = w.slice(0, -5); d.call(g, new Event(T.substring(2))) } g.getAttribute(`data-${w}`) !== "" && ((E.tag === "bodyAttrs" ? n.defaultView : g).addEventListener(w.substring(2), d.bind(g)), g.setAttribute(`data-${w}`, "")); continue } const y = `attr:${w}`; if (w === "class") { if (!d) continue; for (const x of d) k && c(_, `${y}:${x}`, () => g.classList.remove(x)), !g.classList.contains(x) && g.classList.add(x) } else if (w === "style") { if (!d) continue; for (const [x, T] of d) c(_, `${y}:${x}`, () => { g.style.removeProperty(x) }), g.style.setProperty(x, T) } else d !== !1 && d !== null && (g.getAttribute(w) !== d && g.setAttribute(w, d === !0 ? "" : String(d)), k && c(_, y, () => g.removeAttribute(w))) } } const l = [], f = { bodyClose: void 0, bodyOpen: void 0, head: void 0 }, h = await i; for (const _ of h) { const { tag: g, shouldRender: E, id: k } = _; if (E) { if (g.tag === "title") { n.title = g.textContent, c("title", "", () => n.title = a.title); continue } _.$el = _.$el || a.elMap.get(k), _.$el ? u(_) : La.has(g.tag) && l.push(_) } } for (const _ of l) { const g = _.tag.tagPosition || "head"; _.$el = n.createElement(_.tag.tag), u(_), f[g] = f[g] || n.createDocumentFragment(), f[g].appendChild(_.$el) } for (const _ of h) await e.hooks.callHook("dom:renderTag", _, n, c); f.head && n.head.appendChild(f.head), f.bodyOpen && n.body.insertBefore(f.bodyOpen, n.body.firstChild), f.bodyClose && n.body.appendChild(f.bodyClose); for (const _ in a.pendingSideEffects) a.pendingSideEffects[_](); e._dom = a, await e.hooks.callHook("dom:rendered", { renders: h }), o() }).finally(() => { e._domUpdatePromise = void 0, e.dirty = !1 })), e._domUpdatePromise } function Hm(e = {}) { var s, o, r; const t = ((s = e.domOptions) == null ? void 0 : s.render) || Si; e.document = e.document || (typeof window < "u" ? document : void 0); const n = ((r = (o = e.document) == null ? void 0 : o.head.querySelector('script[id="unhead:payload"]')) == null ? void 0 : r.innerHTML) || !1; return wm({ ...e, plugins: [...e.plugins || [], { key: "client", hooks: { "entries:updated": t } }], init: [n ? JSON.parse(n) : !1, ...e.init || []] }) } function Dm(e, t) { let n = 0; return () => { const s = ++n; t(() => { n === s && e() }) } } function Fm(e = {}) { const t = Hm({ domOptions: { render: Dm(() => Si(t), n => setTimeout(n, 0)) }, ...e }); return t.install = km(t), t } const $m = { disableDefaults: !0 }, jm = qe({ name: "nuxt:head", enforce: "pre", setup(e) { const t = Fm($m); e.vueApp.use(t); { let n = !0; const s = async () => { n = !1, await Si(t) }; t.hooks.hook("dom:beforeRender", o => { o.shouldRender = !n }), e.hooks.hook("page:start", () => { n = !0 }), e.hooks.hook("page:finish", () => { e.isHydrating || s() }), e.hooks.hook("app:error", s), e.hooks.hook("app:suspense:resolve", s) } } });/*!
  * vue-router v4.5.1
  * (c) 2025 Eduardo San Martin Morote
  * @license MIT
  */const bn = typeof document < "u"; function Wu(e) { return typeof e == "object" || "displayName" in e || "props" in e || "__vccOpts" in e } function Um(e) { return e.__esModule || e[Symbol.toStringTag] === "Module" || e.default && Wu(e.default) } const ue = Object.assign; function ir(e, t) { const n = {}; for (const s in t) { const o = t[s]; n[s] = ft(o) ? o.map(e) : e(o) } return n } const ts = () => { }, ft = Array.isArray, Ku = /#/g, Vm = /&/g, Bm = /\//g, Wm = /=/g, Km = /\?/g, zu = /\+/g, zm = /%5B/g, qm = /%5D/g, qu = /%5E/g, Gm = /%60/g, Gu = /%7B/g, Ym = /%7C/g, Yu = /%7D/g, Qm = /%20/g; function Ci(e) { return encodeURI("" + e).replace(Ym, "|").replace(zm, "[").replace(qm, "]") } function Jm(e) { return Ci(e).replace(Gu, "{").replace(Yu, "}").replace(qu, "^") } function Br(e) { return Ci(e).replace(zu, "%2B").replace(Qm, "+").replace(Ku, "%23").replace(Vm, "%26").replace(Gm, "`").replace(Gu, "{").replace(Yu, "}").replace(qu, "^") } function Xm(e) { return Br(e).replace(Wm, "%3D") } function Zm(e) { return Ci(e).replace(Ku, "%23").replace(Km, "%3F") } function e0(e) { return e == null ? "" : Zm(e).replace(Bm, "%2F") } function ds(e) { try { return decodeURIComponent("" + e) } catch { } return "" + e } const t0 = /\/$/, n0 = e => e.replace(t0, ""); function ar(e, t, n = "/") { let s, o = {}, r = "", i = ""; const a = t.indexOf("#"); let c = t.indexOf("?"); return a < c && a >= 0 && (c = -1), c > -1 && (s = t.slice(0, c), r = t.slice(c + 1, a > -1 ? a : t.length), o = e(r)), a > -1 && (s = s || t.slice(0, a), i = t.slice(a, t.length)), s = i0(s ?? t, n), { fullPath: s + (r && "?") + r + i, path: s, query: o, hash: ds(i) } } function s0(e, t) { const n = t.query ? e(t.query) : ""; return t.path + (n && "?") + n + (t.hash || "") } function Ba(e, t) { return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/" } function o0(e, t, n) { const s = t.matched.length - 1, o = n.matched.length - 1; return s > -1 && s === o && Ln(t.matched[s], n.matched[o]) && Qu(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash } function Ln(e, t) { return (e.aliasOf || e) === (t.aliasOf || t) } function Qu(e, t) { if (Object.keys(e).length !== Object.keys(t).length) return !1; for (const n in e) if (!r0(e[n], t[n])) return !1; return !0 } function r0(e, t) { return ft(e) ? Wa(e, t) : ft(t) ? Wa(t, e) : e === t } function Wa(e, t) { return ft(t) ? e.length === t.length && e.every((n, s) => n === t[s]) : e.length === 1 && e[0] === t } function i0(e, t) { if (e.startsWith("/")) return e; if (!e) return t; const n = t.split("/"), s = e.split("/"), o = s[s.length - 1]; (o === ".." || o === ".") && s.push(""); let r = n.length - 1, i, a; for (i = 0; i < s.length; i++)if (a = s[i], a !== ".") if (a === "..") r > 1 && r--; else break; return n.slice(0, r).join("/") + "/" + s.slice(i).join("/") } const Ze = { path: "/", name: void 0, params: {}, query: {}, hash: "", fullPath: "/", matched: [], meta: {}, redirectedFrom: void 0 }; var ps; (function (e) { e.pop = "pop", e.push = "push" })(ps || (ps = {})); var ns; (function (e) { e.back = "back", e.forward = "forward", e.unknown = "" })(ns || (ns = {})); function a0(e) { if (!e) if (bn) { const t = document.querySelector("base"); e = t && t.getAttribute("href") || "/", e = e.replace(/^\w+:\/\/[^\/]+/, "") } else e = "/"; return e[0] !== "/" && e[0] !== "#" && (e = "/" + e), n0(e) } const c0 = /^[^#]+#/; function l0(e, t) { return e.replace(c0, "#") + t } function u0(e, t) { const n = document.documentElement.getBoundingClientRect(), s = e.getBoundingClientRect(); return { behavior: t.behavior, left: s.left - n.left - (t.left || 0), top: s.top - n.top - (t.top || 0) } } const Vo = () => ({ left: window.scrollX, top: window.scrollY }); function f0(e) { let t; if ("el" in e) { const n = e.el, s = typeof n == "string" && n.startsWith("#"), o = typeof n == "string" ? s ? document.getElementById(n.slice(1)) : document.querySelector(n) : n; if (!o) return; t = u0(o, e) } else t = e; "scrollBehavior" in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.scrollX, t.top != null ? t.top : window.scrollY) } function Ka(e, t) { return (history.state ? history.state.position - t : -1) + e } const Wr = new Map; function h0(e, t) { Wr.set(e, t) } function d0(e) { const t = Wr.get(e); return Wr.delete(e), t } let p0 = () => location.protocol + "//" + location.host; function Ju(e, t) { const { pathname: n, search: s, hash: o } = t, r = e.indexOf("#"); if (r > -1) { let a = o.includes(e.slice(r)) ? e.slice(r).length : 1, c = o.slice(a); return c[0] !== "/" && (c = "/" + c), Ba(c, "") } return Ba(n, e) + s + o } function g0(e, t, n, s) { let o = [], r = [], i = null; const a = ({ state: h }) => { const p = Ju(e, location), _ = n.value, g = t.value; let E = 0; if (h) { if (n.value = p, t.value = h, i && i === _) { i = null; return } E = g ? h.position - g.position : 0 } else s(p); o.forEach(k => { k(n.value, _, { delta: E, type: ps.pop, direction: E ? E > 0 ? ns.forward : ns.back : ns.unknown }) }) }; function c() { i = n.value } function u(h) { o.push(h); const p = () => { const _ = o.indexOf(h); _ > -1 && o.splice(_, 1) }; return r.push(p), p } function l() { const { history: h } = window; h.state && h.replaceState(ue({}, h.state, { scroll: Vo() }), "") } function f() { for (const h of r) h(); r = [], window.removeEventListener("popstate", a), window.removeEventListener("beforeunload", l) } return window.addEventListener("popstate", a), window.addEventListener("beforeunload", l, { passive: !0 }), { pauseListeners: c, listen: u, destroy: f } } function za(e, t, n, s = !1, o = !1) { return { back: e, current: t, forward: n, replaced: s, position: window.history.length, scroll: o ? Vo() : null } } function m0(e) { const { history: t, location: n } = window, s = { value: Ju(e, n) }, o = { value: t.state }; o.value || r(s.value, { back: null, current: s.value, forward: null, position: t.length - 1, replaced: !0, scroll: null }, !0); function r(c, u, l) { const f = e.indexOf("#"), h = f > -1 ? (n.host && document.querySelector("base") ? e : e.slice(f)) + c : p0() + e + c; try { t[l ? "replaceState" : "pushState"](u, "", h), o.value = u } catch (p) { console.error(p), n[l ? "replace" : "assign"](h) } } function i(c, u) { const l = ue({}, t.state, za(o.value.back, c, o.value.forward, !0), u, { position: o.value.position }); r(c, l, !0), s.value = c } function a(c, u) { const l = ue({}, o.value, t.state, { forward: c, scroll: Vo() }); r(l.current, l, !0); const f = ue({}, za(s.value, c, null), { position: l.position + 1 }, u); r(c, f, !1), s.value = c } return { location: s, state: o, push: a, replace: i } } function y0(e) { e = a0(e); const t = m0(e), n = g0(e, t.state, t.location, t.replace); function s(r, i = !0) { i || n.pauseListeners(), history.go(r) } const o = ue({ location: "", base: e, go: s, createHref: l0.bind(null, e) }, t, n); return Object.defineProperty(o, "location", { enumerable: !0, get: () => t.location.value }), Object.defineProperty(o, "state", { enumerable: !0, get: () => t.state.value }), o } function _0(e) { return typeof e == "string" || e && typeof e == "object" } function Xu(e) { return typeof e == "string" || typeof e == "symbol" } const Zu = Symbol(""); var qa; (function (e) { e[e.aborted = 4] = "aborted", e[e.cancelled = 8] = "cancelled", e[e.duplicated = 16] = "duplicated" })(qa || (qa = {})); function Nn(e, t) { return ue(new Error, { type: e, [Zu]: !0 }, t) } function Et(e, t) { return e instanceof Error && Zu in e && (t == null || !!(e.type & t)) } const Ga = "[^/]+?", b0 = { sensitive: !1, strict: !1, start: !0, end: !0 }, v0 = /[.+*?^${}()[\]/\\]/g; function w0(e, t) { const n = ue({}, b0, t), s = []; let o = n.start ? "^" : ""; const r = []; for (const u of e) { const l = u.length ? [] : [90]; n.strict && !u.length && (o += "/"); for (let f = 0; f < u.length; f++) { const h = u[f]; let p = 40 + (n.sensitive ? .25 : 0); if (h.type === 0) f || (o += "/"), o += h.value.replace(v0, "\\$&"), p += 40; else if (h.type === 1) { const { value: _, repeatable: g, optional: E, regexp: k } = h; r.push({ name: _, repeatable: g, optional: E }); const w = k || Ga; if (w !== Ga) { p += 10; try { new RegExp(`(${w})`) } catch (y) { throw new Error(`Invalid custom RegExp for param "${_}" (${w}): ` + y.message) } } let d = g ? `((?:${w})(?:/(?:${w}))*)` : `(${w})`; f || (d = E && u.length < 2 ? `(?:/${d})` : "/" + d), E && (d += "?"), o += d, p += 20, E && (p += -8), g && (p += -20), w === ".*" && (p += -50) } l.push(p) } s.push(l) } if (n.strict && n.end) { const u = s.length - 1; s[u][s[u].length - 1] += .7000000000000001 } n.strict || (o += "/?"), n.end ? o += "$" : n.strict && !o.endsWith("/") && (o += "(?:/|$)"); const i = new RegExp(o, n.sensitive ? "" : "i"); function a(u) { const l = u.match(i), f = {}; if (!l) return null; for (let h = 1; h < l.length; h++) { const p = l[h] || "", _ = r[h - 1]; f[_.name] = p && _.repeatable ? p.split("/") : p } return f } function c(u) { let l = "", f = !1; for (const h of e) { (!f || !l.endsWith("/")) && (l += "/"), f = !1; for (const p of h) if (p.type === 0) l += p.value; else if (p.type === 1) { const { value: _, repeatable: g, optional: E } = p, k = _ in u ? u[_] : ""; if (ft(k) && !g) throw new Error(`Provided param "${_}" is an array but it is not repeatable (* or + modifiers)`); const w = ft(k) ? k.join("/") : k; if (!w) if (E) h.length < 2 && (l.endsWith("/") ? l = l.slice(0, -1) : f = !0); else throw new Error(`Missing required param "${_}"`); l += w } } return l || "/" } return { re: i, score: s, keys: r, parse: a, stringify: c } } function E0(e, t) { let n = 0; for (; n < e.length && n < t.length;) { const s = t[n] - e[n]; if (s) return s; n++ } return e.length < t.length ? e.length === 1 && e[0] === 80 ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === 80 ? 1 : -1 : 0 } function ef(e, t) { let n = 0; const s = e.score, o = t.score; for (; n < s.length && n < o.length;) { const r = E0(s[n], o[n]); if (r) return r; n++ } if (Math.abs(o.length - s.length) === 1) { if (Ya(s)) return 1; if (Ya(o)) return -1 } return o.length - s.length } function Ya(e) { const t = e[e.length - 1]; return e.length > 0 && t[t.length - 1] < 0 } const k0 = { type: 0, value: "" }, x0 = /[a-zA-Z0-9_]/; function T0(e) { if (!e) return [[]]; if (e === "/") return [[k0]]; if (!e.startsWith("/")) throw new Error(`Invalid path "${e}"`); function t(p) { throw new Error(`ERR (${n})/"${u}": ${p}`) } let n = 0, s = n; const o = []; let r; function i() { r && o.push(r), r = [] } let a = 0, c, u = "", l = ""; function f() { u && (n === 0 ? r.push({ type: 0, value: u }) : n === 1 || n === 2 || n === 3 ? (r.length > 1 && (c === "*" || c === "+") && t(`A repeatable param (${u}) must be alone in its segment. eg: '/:ids+.`), r.push({ type: 1, value: u, regexp: l, repeatable: c === "*" || c === "+", optional: c === "*" || c === "?" })) : t("Invalid state to consume buffer"), u = "") } function h() { u += c } for (; a < e.length;) { if (c = e[a++], c === "\\" && n !== 2) { s = n, n = 4; continue } switch (n) { case 0: c === "/" ? (u && f(), i()) : c === ":" ? (f(), n = 1) : h(); break; case 4: h(), n = s; break; case 1: c === "(" ? n = 2 : x0.test(c) ? h() : (f(), n = 0, c !== "*" && c !== "?" && c !== "+" && a--); break; case 2: c === ")" ? l[l.length - 1] == "\\" ? l = l.slice(0, -1) + c : n = 3 : l += c; break; case 3: f(), n = 0, c !== "*" && c !== "?" && c !== "+" && a--, l = ""; break; default: t("Unknown state"); break } } return n === 2 && t(`Unfinished custom RegExp for param "${u}"`), f(), i(), o } function P0(e, t, n) { const s = w0(T0(e.path), n), o = ue(s, { record: e, parent: t, children: [], alias: [] }); return t && !o.record.aliasOf == !t.record.aliasOf && t.children.push(o), o } function S0(e, t) { const n = [], s = new Map; t = Za({ strict: !1, end: !0, sensitive: !1 }, t); function o(f) { return s.get(f) } function r(f, h, p) { const _ = !p, g = Ja(f); g.aliasOf = p && p.record; const E = Za(t, f), k = [g]; if ("alias" in f) { const y = typeof f.alias == "string" ? [f.alias] : f.alias; for (const x of y) k.push(Ja(ue({}, g, { components: p ? p.record.components : g.components, path: x, aliasOf: p ? p.record : g }))) } let w, d; for (const y of k) { const { path: x } = y; if (h && x[0] !== "/") { const T = h.record.path, S = T[T.length - 1] === "/" ? "" : "/"; y.path = h.record.path + (x && S + x) } if (w = P0(y, h, E), p ? p.alias.push(w) : (d = d || w, d !== w && d.alias.push(w), _ && f.name && !Xa(w) && i(f.name)), tf(w) && c(w), g.children) { const T = g.children; for (let S = 0; S < T.length; S++)r(T[S], w, p && p.children[S]) } p = p || w } return d ? () => { i(d) } : ts } function i(f) { if (Xu(f)) { const h = s.get(f); h && (s.delete(f), n.splice(n.indexOf(h), 1), h.children.forEach(i), h.alias.forEach(i)) } else { const h = n.indexOf(f); h > -1 && (n.splice(h, 1), f.record.name && s.delete(f.record.name), f.children.forEach(i), f.alias.forEach(i)) } } function a() { return n } function c(f) { const h = A0(f, n); n.splice(h, 0, f), f.record.name && !Xa(f) && s.set(f.record.name, f) } function u(f, h) { let p, _ = {}, g, E; if ("name" in f && f.name) { if (p = s.get(f.name), !p) throw Nn(1, { location: f }); E = p.record.name, _ = ue(Qa(h.params, p.keys.filter(d => !d.optional).concat(p.parent ? p.parent.keys.filter(d => d.optional) : []).map(d => d.name)), f.params && Qa(f.params, p.keys.map(d => d.name))), g = p.stringify(_) } else if (f.path != null) g = f.path, p = n.find(d => d.re.test(g)), p && (_ = p.parse(g), E = p.record.name); else { if (p = h.name ? s.get(h.name) : n.find(d => d.re.test(h.path)), !p) throw Nn(1, { location: f, currentLocation: h }); E = p.record.name, _ = ue({}, h.params, f.params), g = p.stringify(_) } const k = []; let w = p; for (; w;)k.unshift(w.record), w = w.parent; return { name: E, path: g, params: _, matched: k, meta: R0(k) } } e.forEach(f => r(f)); function l() { n.length = 0, s.clear() } return { addRoute: r, resolve: u, removeRoute: i, clearRoutes: l, getRoutes: a, getRecordMatcher: o } } function Qa(e, t) { const n = {}; for (const s of t) s in e && (n[s] = e[s]); return n } function Ja(e) { const t = { path: e.path, redirect: e.redirect, name: e.name, meta: e.meta || {}, aliasOf: e.aliasOf, beforeEnter: e.beforeEnter, props: C0(e), children: e.children || [], instances: {}, leaveGuards: new Set, updateGuards: new Set, enterCallbacks: {}, components: "components" in e ? e.components || null : e.component && { default: e.component } }; return Object.defineProperty(t, "mods", { value: {} }), t } function C0(e) { const t = {}, n = e.props || !1; if ("component" in e) t.default = n; else for (const s in e.components) t[s] = typeof n == "object" ? n[s] : n; return t } function Xa(e) { for (; e;) { if (e.record.aliasOf) return !0; e = e.parent } return !1 } function R0(e) { return e.reduce((t, n) => ue(t, n.meta), {}) } function Za(e, t) { const n = {}; for (const s in e) n[s] = s in t ? t[s] : e[s]; return n } function A0(e, t) { let n = 0, s = t.length; for (; n !== s;) { const r = n + s >> 1; ef(e, t[r]) < 0 ? s = r : n = r + 1 } const o = I0(e); return o && (s = t.lastIndexOf(o, s - 1)), s } function I0(e) { let t = e; for (; t = t.parent;)if (tf(t) && ef(e, t) === 0) return t } function tf({ record: e }) { return !!(e.name || e.components && Object.keys(e.components).length || e.redirect) } function O0(e) { const t = {}; if (e === "" || e === "?") return t; const s = (e[0] === "?" ? e.slice(1) : e).split("&"); for (let o = 0; o < s.length; ++o) { const r = s[o].replace(zu, " "), i = r.indexOf("="), a = ds(i < 0 ? r : r.slice(0, i)), c = i < 0 ? null : ds(r.slice(i + 1)); if (a in t) { let u = t[a]; ft(u) || (u = t[a] = [u]), u.push(c) } else t[a] = c } return t } function ec(e) { let t = ""; for (let n in e) { const s = e[n]; if (n = Xm(n), s == null) { s !== void 0 && (t += (t.length ? "&" : "") + n); continue } (ft(s) ? s.map(r => r && Br(r)) : [s && Br(s)]).forEach(r => { r !== void 0 && (t += (t.length ? "&" : "") + n, r != null && (t += "=" + r)) }) } return t } function M0(e) { const t = {}; for (const n in e) { const s = e[n]; s !== void 0 && (t[n] = ft(s) ? s.map(o => o == null ? null : "" + o) : s == null ? s : "" + s) } return t } const L0 = Symbol(""), tc = Symbol(""), Ri = Symbol(""), nf = Symbol(""), Kr = Symbol(""); function Wn() { let e = []; function t(s) { return e.push(s), () => { const o = e.indexOf(s); o > -1 && e.splice(o, 1) } } function n() { e = [] } return { add: t, list: () => e.slice(), reset: n } } function Wt(e, t, n, s, o, r = i => i()) { const i = s && (s.enterCallbacks[o] = s.enterCallbacks[o] || []); return () => new Promise((a, c) => { const u = h => { h === !1 ? c(Nn(4, { from: n, to: t })) : h instanceof Error ? c(h) : _0(h) ? c(Nn(2, { from: t, to: h })) : (i && s.enterCallbacks[o] === i && typeof h == "function" && i.push(h), a()) }, l = r(() => e.call(s && s.instances[o], t, n, u)); let f = Promise.resolve(l); e.length < 3 && (f = f.then(u)), f.catch(h => c(h)) }) } function cr(e, t, n, s, o = r => r()) { const r = []; for (const i of e) for (const a in i.components) { let c = i.components[a]; if (!(t !== "beforeRouteEnter" && !i.instances[a])) if (Wu(c)) { const l = (c.__vccOpts || c)[t]; l && r.push(Wt(l, n, s, i, a, o)) } else { let u = c(); r.push(() => u.then(l => { if (!l) throw new Error(`Couldn't resolve component "${a}" at "${i.path}"`); const f = Um(l) ? l.default : l; i.mods[a] = l, i.components[a] = f; const p = (f.__vccOpts || f)[t]; return p && Wt(p, n, s, i, a, o)() })) } } return r } function nc(e) { const t = ze(Ri), n = ze(nf), s = et(() => { const c = be(e.to); return t.resolve(c) }), o = et(() => { const { matched: c } = s.value, { length: u } = c, l = c[u - 1], f = n.matched; if (!l || !f.length) return -1; const h = f.findIndex(Ln.bind(null, l)); if (h > -1) return h; const p = sc(c[u - 2]); return u > 1 && sc(l) === p && f[f.length - 1].path !== p ? f.findIndex(Ln.bind(null, c[u - 2])) : h }), r = et(() => o.value > -1 && $0(n.params, s.value.params)), i = et(() => o.value > -1 && o.value === n.matched.length - 1 && Qu(n.params, s.value.params)); function a(c = {}) { if (F0(c)) { const u = t[be(e.replace) ? "replace" : "push"](be(e.to)).catch(ts); return e.viewTransition && typeof document < "u" && "startViewTransition" in document && document.startViewTransition(() => u), u } return Promise.resolve() } return { route: s, href: et(() => s.value.href), isActive: r, isExactActive: i, navigate: a } } function N0(e) { return e.length === 1 ? e[0] : e } const H0 = vt({ name: "RouterLink", compatConfig: { MODE: 3 }, props: { to: { type: [String, Object], required: !0 }, replace: Boolean, activeClass: String, exactActiveClass: String, custom: Boolean, ariaCurrentValue: { type: String, default: "page" }, viewTransition: Boolean }, useLink: nc, setup(e, { slots: t }) { const n = ht(nc(e)), { options: s } = ze(Ri), o = et(() => ({ [oc(e.activeClass, s.linkActiveClass, "router-link-active")]: n.isActive, [oc(e.exactActiveClass, s.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive })); return () => { const r = t.default && N0(t.default(n)); return e.custom ? r : Ke("a", { "aria-current": n.isExactActive ? e.ariaCurrentValue : null, href: n.href, onClick: n.navigate, class: o.value }, r) } } }), D0 = H0; function F0(e) { if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) { if (e.currentTarget && e.currentTarget.getAttribute) { const t = e.currentTarget.getAttribute("target"); if (/\b_blank\b/i.test(t)) return } return e.preventDefault && e.preventDefault(), !0 } } function $0(e, t) { for (const n in t) { const s = t[n], o = e[n]; if (typeof s == "string") { if (s !== o) return !1 } else if (!ft(o) || o.length !== s.length || s.some((r, i) => r !== o[i])) return !1 } return !0 } function sc(e) { return e ? e.aliasOf ? e.aliasOf.path : e.path : "" } const oc = (e, t, n) => e ?? t ?? n, j0 = vt({ name: "RouterView", inheritAttrs: !1, props: { name: { type: String, default: "default" }, route: Object }, compatConfig: { MODE: 3 }, setup(e, { attrs: t, slots: n }) { const s = ze(Kr), o = et(() => e.route || s.value), r = ze(tc, 0), i = et(() => { let u = be(r); const { matched: l } = o.value; let f; for (; (f = l[u]) && !f.components;)u++; return u }), a = et(() => o.value.matched[i.value]); Sn(tc, et(() => i.value + 1)), Sn(L0, a), Sn(Kr, o); const c = $e(); return bt(() => [c.value, a.value, e.name], ([u, l, f], [h, p, _]) => { l && (l.instances[f] = u, p && p !== l && u && u === h && (l.leaveGuards.size || (l.leaveGuards = p.leaveGuards), l.updateGuards.size || (l.updateGuards = p.updateGuards))), u && l && (!p || !Ln(l, p) || !h) && (l.enterCallbacks[f] || []).forEach(g => g(u)) }, { flush: "post" }), () => { const u = o.value, l = e.name, f = a.value, h = f && f.components[l]; if (!h) return rc(n.default, { Component: h, route: u }); const p = f.props[l], _ = p ? p === !0 ? u.params : typeof p == "function" ? p(u) : p : null, E = Ke(h, ue({}, _, t, { onVnodeUnmounted: k => { k.component.isUnmounted && (f.instances[l] = null) }, ref: c })); return rc(n.default, { Component: E, route: u }) || E } } }); function rc(e, t) { if (!e) return null; const n = e(t); return n.length === 1 ? n[0] : n } const sf = j0; function U0(e) { const t = S0(e.routes, e), n = e.parseQuery || O0, s = e.stringifyQuery || ec, o = e.history, r = Wn(), i = Wn(), a = Wn(), c = an(Ze); let u = Ze; bn && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual"); const l = ir.bind(null, R => "" + R), f = ir.bind(null, e0), h = ir.bind(null, ds); function p(R, B) { let j, G; return Xu(R) ? (j = t.getRecordMatcher(R), G = B) : G = R, t.addRoute(G, j) } function _(R) { const B = t.getRecordMatcher(R); B && t.removeRoute(B) } function g() { return t.getRoutes().map(R => R.record) } function E(R) { return !!t.getRecordMatcher(R) } function k(R, B) { if (B = ue({}, B || c.value), typeof R == "string") { const b = ar(n, R, B.path), P = t.resolve({ path: b.path }, B), M = o.createHref(b.fullPath); return ue(b, P, { params: h(P.params), hash: ds(b.hash), redirectedFrom: void 0, href: M }) } let j; if (R.path != null) j = ue({}, R, { path: ar(n, R.path, B.path).path }); else { const b = ue({}, R.params); for (const P in b) b[P] == null && delete b[P]; j = ue({}, R, { params: f(b) }), B.params = f(B.params) } const G = t.resolve(j, B), ce = R.hash || ""; G.params = l(h(G.params)); const ge = s0(s, ue({}, R, { hash: Jm(ce), path: G.path })), m = o.createHref(ge); return ue({ fullPath: ge, hash: ce, query: s === ec ? M0(R.query) : R.query || {} }, G, { redirectedFrom: void 0, href: m }) } function w(R) { return typeof R == "string" ? ar(n, R, c.value.path) : ue({}, R) } function d(R, B) { if (u !== R) return Nn(8, { from: B, to: R }) } function y(R) { return S(R) } function x(R) { return y(ue(w(R), { replace: !0 })) } function T(R) { const B = R.matched[R.matched.length - 1]; if (B && B.redirect) { const { redirect: j } = B; let G = typeof j == "function" ? j(R) : j; return typeof G == "string" && (G = G.includes("?") || G.includes("#") ? G = w(G) : { path: G }, G.params = {}), ue({ query: R.query, hash: R.hash, params: G.path != null ? {} : R.params }, G) } } function S(R, B) { const j = u = k(R), G = c.value, ce = R.state, ge = R.force, m = R.replace === !0, b = T(j); if (b) return S(ue(w(b), { state: typeof b == "object" ? ue({}, ce, b.state) : ce, force: ge, replace: m }), B || j); const P = j; P.redirectedFrom = B; let M; return !ge && o0(s, G, j) && (M = Nn(16, { to: P, from: G }), Ee(G, G, !0, !1)), (M ? Promise.resolve(M) : I(P, G)).catch(C => Et(C) ? Et(C, 2) ? C : se(C) : v(C, P, G)).then(C => { if (C) { if (Et(C, 2)) return S(ue({ replace: m }, w(C.to), { state: typeof C.to == "object" ? ue({}, ce, C.to.state) : ce, force: ge }), B || P) } else C = A(P, G, !0, m, ce); return q(P, G, C), C }) } function F(R, B) { const j = d(R, B); return j ? Promise.reject(j) : Promise.resolve() } function O(R) { const B = ot.values().next().value; return B && typeof B.runWithContext == "function" ? B.runWithContext(R) : R() } function I(R, B) { let j; const [G, ce, ge] = V0(R, B); j = cr(G.reverse(), "beforeRouteLeave", R, B); for (const b of G) b.leaveGuards.forEach(P => { j.push(Wt(P, R, B)) }); const m = F.bind(null, R, B); return j.push(m), je(j).then(() => { j = []; for (const b of r.list()) j.push(Wt(b, R, B)); return j.push(m), je(j) }).then(() => { j = cr(ce, "beforeRouteUpdate", R, B); for (const b of ce) b.updateGuards.forEach(P => { j.push(Wt(P, R, B)) }); return j.push(m), je(j) }).then(() => { j = []; for (const b of ge) if (b.beforeEnter) if (ft(b.beforeEnter)) for (const P of b.beforeEnter) j.push(Wt(P, R, B)); else j.push(Wt(b.beforeEnter, R, B)); return j.push(m), je(j) }).then(() => (R.matched.forEach(b => b.enterCallbacks = {}), j = cr(ge, "beforeRouteEnter", R, B, O), j.push(m), je(j))).then(() => { j = []; for (const b of i.list()) j.push(Wt(b, R, B)); return j.push(m), je(j) }).catch(b => Et(b, 8) ? b : Promise.reject(b)) } function q(R, B, j) { a.list().forEach(G => O(() => G(R, B, j))) } function A(R, B, j, G, ce) { const ge = d(R, B); if (ge) return ge; const m = B === Ze, b = bn ? history.state : {}; j && (G || m ? o.replace(R.fullPath, ue({ scroll: m && b && b.scroll }, ce)) : o.push(R.fullPath, ce)), c.value = R, Ee(R, B, j, m), se() } let W; function ne() { W || (W = o.listen((R, B, j) => { if (!Ht.listening) return; const G = k(R), ce = T(G); if (ce) { S(ue(ce, { replace: !0, force: !0 }), G).catch(ts); return } u = G; const ge = c.value; bn && h0(Ka(ge.fullPath, j.delta), Vo()), I(G, ge).catch(m => Et(m, 12) ? m : Et(m, 2) ? (S(ue(w(m.to), { force: !0 }), G).then(b => { Et(b, 20) && !j.delta && j.type === ps.pop && o.go(-1, !1) }).catch(ts), Promise.reject()) : (j.delta && o.go(-j.delta, !1), v(m, G, ge))).then(m => { m = m || A(G, ge, !1), m && (j.delta && !Et(m, 8) ? o.go(-j.delta, !1) : j.type === ps.pop && Et(m, 20) && o.go(-1, !1)), q(G, ge, m) }).catch(ts) })) } let ie = Wn(), K = Wn(), Z; function v(R, B, j) { se(R); const G = K.list(); return G.length ? G.forEach(ce => ce(R, B, j)) : console.error(R), Promise.reject(R) } function L() { return Z && c.value !== Ze ? Promise.resolve() : new Promise((R, B) => { ie.add([R, B]) }) } function se(R) { return Z || (Z = !R, ne(), ie.list().forEach(([B, j]) => R ? j(R) : B()), ie.reset()), R } function Ee(R, B, j, G) { const { scrollBehavior: ce } = e; if (!bn || !ce) return Promise.resolve(); const ge = !j && d0(Ka(R.fullPath, 0)) || (G || !j) && history.state && history.state.scroll || null; return qt().then(() => ce(R, B, ge)).then(m => m && f0(m)).catch(m => v(m, R, B)) } const ve = R => o.go(R); let dt; const ot = new Set, Ht = { currentRoute: c, listening: !0, addRoute: p, removeRoute: _, clearRoutes: t.clearRoutes, hasRoute: E, getRoutes: g, resolve: k, options: e, push: y, replace: x, go: ve, back: () => ve(-1), forward: () => ve(1), beforeEach: r.add, beforeResolve: i.add, afterEach: a.add, onError: K.add, isReady: L, install(R) { const B = this; R.component("RouterLink", D0), R.component("RouterView", sf), R.config.globalProperties.$router = B, Object.defineProperty(R.config.globalProperties, "$route", { enumerable: !0, get: () => be(c) }), bn && !dt && c.value === Ze && (dt = !0, y(o.location).catch(ce => { })); const j = {}; for (const ce in Ze) Object.defineProperty(j, ce, { get: () => c.value[ce], enumerable: !0 }); R.provide(Ri, B), R.provide(nf, Rt(j)), R.provide(Kr, c); const G = R.unmount; ot.add(R), R.unmount = function () { ot.delete(R), ot.size < 1 && (u = Ze, W && W(), W = null, c.value = Ze, dt = !1, Z = !1), G() } } }; function je(R) { return R.reduce((B, j) => B.then(() => O(j)), Promise.resolve()) } return Ht } function V0(e, t) { const n = [], s = [], o = [], r = Math.max(t.matched.length, e.matched.length); for (let i = 0; i < r; i++) { const a = t.matched[i]; a && (e.matched.find(u => Ln(u, a)) ? s.push(a) : n.push(a)); const c = e.matched[i]; c && (t.matched.find(u => Ln(u, c)) || o.push(c)) } return [n, s, o] } const B0 = /(:\w+)\([^)]+\)/g, W0 = /(:\w+)[?+*]/g, K0 = /:\w+/g, z0 = (e, t) => t.path.replace(B0, "$1").replace(W0, "$1").replace(K0, n => { var s; return ((s = e.params[n.slice(1)]) == null ? void 0 : s.toString()) || "" }), zr = (e, t) => { const n = e.route.matched.find(o => { var r; return ((r = o.components) == null ? void 0 : r.default) === e.Component.type }), s = t ?? (n == null ? void 0 : n.meta.key) ?? (n && z0(e.route, n)); return typeof s == "function" ? s(e.route) : s }, q0 = (e, t) => ({ default: () => e ? Ke(Fh, e === !0 ? {} : e, t) : t }); function Ai(e) { return Array.isArray(e) ? e : [e] } const lr = [{ name: "index", path: "/", component: () => J(() => import("./j9-6koyx.js").then(e => e.i), __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]), import.meta.url) }], G0 = (e, t) => ({ default: () => { var n; return e ? Ke(jd, e === !0 ? {} : e, t) : (n = t.default) == null ? void 0 : n.call(t) } }), Y0 = /(:\w+)\([^)]+\)/g, Q0 = /(:\w+)[?+*]/g, J0 = /:\w+/g; function ic(e) { const t = (e == null ? void 0 : e.meta.key) ?? e.path.replace(Y0, "$1").replace(Q0, "$1").replace(J0, n => { var s; return ((s = e.params[n.slice(1)]) == null ? void 0 : s.toString()) || "" }); return typeof t == "function" ? t(e) : t } function X0(e, t) { return e === t || t === Ze ? !1 : ic(e) !== ic(t) ? !0 : !e.matched.every((s, o) => { var r, i; return s.components && s.components.default === ((i = (r = t.matched[o]) == null ? void 0 : r.components) == null ? void 0 : i.default) }) } const Z0 = { scrollBehavior(e, t, n) { var c; const s = we(), o = ((c = Qe().options) == null ? void 0 : c.scrollBehaviorType) ?? "auto"; if (e.path === t.path) return t.hash && !e.hash ? { left: 0, top: 0 } : e.hash ? { el: e.hash, top: of(e.hash), behavior: o } : !1; if ((typeof e.meta.scrollToTop == "function" ? e.meta.scrollToTop(e, t) : e.meta.scrollToTop) === !1) return !1; let i = n || void 0; !i && X0(e, t) && (i = { left: 0, top: 0 }); const a = s._runningTransition ? "page:transition:finish" : "page:loading:end"; return new Promise(u => { if (t === Ze) { u(ac(e, "instant", i)); return } s.hooks.hookOnce(a, () => { requestAnimationFrame(() => u(ac(e, "instant", i))) }) }) } }; function of(e) { try { const t = document.querySelector(e); if (t) return (Number.parseFloat(getComputedStyle(t).scrollMarginTop) || 0) + (Number.parseFloat(getComputedStyle(document.documentElement).scrollPaddingTop) || 0) } catch { } return 0 } function ac(e, t, n) { return n || (e.hash ? { el: e.hash, top: of(e.hash), behavior: t } : { left: 0, top: 0, behavior: t }) } const ey = { hashMode: !1, scrollBehaviorType: "smooth" }, gt = { ...ey, ...Z0 }, ty = async (e, t) => { var i; let n, s; if (!((i = e.meta) != null && i.validate)) return; const o = ([n, s] = An(() => Promise.resolve(e.meta.validate(e))), n = await n, s(), n); if (o === !0) return; const r = rn({ fatal: !0, statusCode: o && o.statusCode || 404, statusMessage: o && o.statusMessage || `Page Not Found: ${e.fullPath}`, data: { path: e.fullPath } }); return typeof window < "u" && window.history.pushState({}, "", t.fullPath), r }, ny = async e => { let t, n; const s = ([t, n] = An(() => Pi({ path: e.path })), t = await t, n(), t); if (s.redirect) return dn(s.redirect, { acceptRelative: !0 }) ? (window.location.href = s.redirect, !1) : s.redirect }, sy = [ty, ny], ss = {}; function oy(e, t, n) { const { pathname: s, search: o, hash: r } = t, i = e.indexOf("#"); if (i > -1) { const u = r.includes(e.slice(i)) ? e.slice(i).length : 1; let l = r.slice(u); return l[0] !== "/" && (l = "/" + l), ka(l, "") } const a = ka(s, e), c = !n || Qp(a, n) ? a : n; return c + (c.includes("?") ? "" : o) + r } const ry = qe({ name: "nuxt:router", enforce: "pre", async setup(e) { var E; let t, n, s = pn().app.baseURL; const o = ((E = gt.history) == null ? void 0 : E.call(gt, s)) ?? y0(s), r = gt.routes ? ([t, n] = An(() => gt.routes(lr)), t = await t, n(), t ?? lr) : lr; let i; const a = U0({ ...gt, scrollBehavior: (k, w, d) => { if (w === Ze) { i = d; return } if (gt.scrollBehavior) { if (a.options.scrollBehavior = gt.scrollBehavior, "scrollRestoration" in window.history) { const y = a.beforeEach(() => { y(), window.history.scrollRestoration = "manual" }) } return gt.scrollBehavior(k, Ze, i || d) } }, history: o, routes: r }); "scrollRestoration" in window.history && (window.history.scrollRestoration = "auto"), e.vueApp.use(a); const c = an(a.currentRoute.value); a.afterEach((k, w) => { c.value = w }), Object.defineProperty(e.vueApp.config.globalProperties, "previousRoute", { get: () => c.value }); const u = oy(s, window.location, e.payload.path), l = an(a.currentRoute.value), f = () => { l.value = a.currentRoute.value }; e.hook("page:finish", f), a.afterEach((k, w) => { var d, y, x, T; ((y = (d = k.matched[0]) == null ? void 0 : d.components) == null ? void 0 : y.default) === ((T = (x = w.matched[0]) == null ? void 0 : x.components) == null ? void 0 : T.default) && f() }); const h = {}; for (const k in l.value) Object.defineProperty(h, k, { get: () => l.value[k], enumerable: !0 }); e._route = Rt(h), e._middleware || (e._middleware = { global: [], named: {} }); const p = jo(); a.afterEach(async (k, w, d) => { delete e._processingMiddleware, !e.isHydrating && p.value && await e.runWithContext(zg), d && await e.callHook("page:loading:end") }); try { [t, n] = An(() => a.isReady()), await t, n() } catch (k) { [t, n] = An(() => e.runWithContext(() => en(k))), await t, n() } const _ = u !== a.currentRoute.value.fullPath ? a.resolve(u) : a.currentRoute.value; f(); const g = e.payload.state._layout; return a.beforeEach(async (k, w) => { var d; await e.callHook("page:loading:start"), k.meta = ht(k.meta), e.isHydrating && g && !Mt(k.meta.layout) && (k.meta.layout = g), e._processingMiddleware = !0; { const y = new Set([...sy, ...e._middleware.global]); for (const x of k.matched) { const T = x.meta.middleware; if (T) for (const S of Ai(T)) y.add(S) } { const x = await e.runWithContext(() => Pi({ path: k.path })); if (x.appMiddleware) for (const T in x.appMiddleware) x.appMiddleware[T] ? y.add(T) : y.delete(T) } for (const x of y) { const T = typeof x == "string" ? e._middleware.named[x] || await ((d = ss[x]) == null ? void 0 : d.call(ss).then(S => S.default || S)) : x; if (!T) throw new Error(`Unknown route middleware: '${x}'.`); try { const S = await e.runWithContext(() => T(k, w)); if (!e.payload.serverRendered && e.isHydrating && (S === !1 || S instanceof Error)) { const F = S || rn({ statusCode: 404, statusMessage: `Page Not Found: ${u}` }); return await e.runWithContext(() => en(F)), !1 } if (S === !0) continue; if (S === !1) return S; if (S) return Au(S) && S.fatal && await e.runWithContext(() => en(S)), S } catch (S) { const F = rn(S); return F.fatal && await e.runWithContext(() => en(F)), F } } } }), a.onError(async () => { delete e._processingMiddleware, await e.callHook("page:loading:end") }), a.afterEach(async (k, w) => { k.matched.length === 0 && await e.runWithContext(() => en(rn({ statusCode: 404, fatal: !1, statusMessage: `Page not found: ${k.fullPath}`, data: { path: k.fullPath } }))) }), e.hooks.hookOnce("app:created", async () => { try { "name" in _ && (_.name = void 0), await a.replace({ ..._, force: !0 }), a.options.scrollBehavior = gt.scrollBehavior } catch (k) { await e.runWithContext(() => en(k)) } }), { provide: { router: a } } } }), cc = globalThis.requestIdleCallback || (e => { const t = Date.now(), n = { didTimeout: !1, timeRemaining: () => Math.max(0, 50 - (Date.now() - t)) }; return setTimeout(() => { e(n) }, 1) }), vw = globalThis.cancelIdleCallback || (e => { clearTimeout(e) }), Ii = e => { const t = we(); t.isHydrating ? t.hooks.hookOnce("app:suspense:resolve", () => { cc(() => e()) }) : cc(() => e()) }, iy = qe({ name: "nuxt:payload", setup(e) { const t = new Set; Qe().beforeResolve(async (n, s) => { if (n.path === s.path) return; const o = await Va(n.path); if (o) { for (const r of t) delete e.static.data[r]; for (const r in o.data) r in e.static.data || t.add(r), e.static.data[r] = o.data[r] } }), Ii(() => { var n; e.hooks.hook("link:prefetch", async s => { const { hostname: o } = new URL(s, window.location.href); o === window.location.hostname && await Va(s).catch(() => { console.warn("[nuxt] Error preloading payload for", s) }) }), ((n = navigator.connection) == null ? void 0 : n.effectiveType) !== "slow-2g" && setTimeout(Uo, 1e3) }) } }), ay = qe(() => { const e = Qe(); Ii(() => { e.beforeResolve(async () => { await new Promise(t => { setTimeout(t, 100), requestAnimationFrame(() => { setTimeout(t, 0) }) }) }) }) }), cy = qe(e => { let t; async function n() { const s = await Uo(); t && clearTimeout(t), t = setTimeout(n, Aa); try { const o = await $fetch(Ei("builds/latest.json") + `?${Date.now()}`); o.id !== s.id && e.hooks.callHook("app:manifest:update", o) } catch { } } Ii(() => { t = setTimeout(n, Aa) }) }); function ly(e = {}) { const t = e.path || window.location.pathname; let n = {}; try { n = po(sessionStorage.getItem("nuxt:reload") || "{}") } catch { } if (e.force || (n == null ? void 0 : n.path) !== t || (n == null ? void 0 : n.expires) < Date.now()) { try { sessionStorage.setItem("nuxt:reload", JSON.stringify({ path: t, expires: Date.now() + (e.ttl ?? 1e4) })) } catch { } if (e.persistState) try { sessionStorage.setItem("nuxt:reload:state", JSON.stringify({ state: we().payload.state })) } catch { } window.location.pathname !== t ? window.location.href = t : window.location.reload() } } const uy = qe({ name: "nuxt:chunk-reload", setup(e) { const t = Qe(), n = pn(), s = new Set; t.beforeEach(() => { s.clear() }), e.hook("app:chunkError", ({ error: r }) => { s.add(r) }); function o(r) { const a = "href" in r && r.href[0] === "#" ? n.app.baseURL + r.href : wi(n.app.baseURL, r.fullPath); ly({ path: a, persistState: !0 }) } e.hook("app:manifest:update", () => { t.beforeResolve(o) }), t.onError((r, i) => { s.has(r) && o(i) }) } }), fy = X(() => J(() => import("./waQEoPDL.js"), __vite__mapDeps([18, 11, 12, 4, 5, 13, 9, 10, 8]), import.meta.url).then(e => e.default || e.default || e)), hy = X(() => J(() => import("./BrmFu2QI.js"), __vite__mapDeps([19, 20, 4, 5, 6, 7, 8, 9, 21, 22, 13, 23, 24, 10, 25, 26]), import.meta.url).then(e => e.default || e.default || e)), dy = X(() => J(() => import("./C3fPimzh.js"), __vite__mapDeps([27, 5]), import.meta.url).then(e => e.default || e.default || e)), py = X(() => J(() => import("./DvCqd2SC.js"), __vite__mapDeps([28, 29, 4, 5, 6, 7, 8, 9, 2, 3, 10, 30, 1]), import.meta.url).then(e => e.default || e.default || e)), gy = X(() => J(() => import("./BlmDa_Bk.js"), __vite__mapDeps([31, 5]), import.meta.url).then(e => e.default || e.default || e)), my = X(() => J(() => import("./DLHDsG_2.js"), __vite__mapDeps([32, 11, 12, 4, 5, 13, 9, 10, 8, 6, 7, 30, 1]), import.meta.url).then(e => e.default || e.default || e)), yy = X(() => J(() => import("./DtMzF6Ps.js"), __vite__mapDeps([33, 11, 12, 4, 5, 13, 9, 10, 8, 6, 7, 30, 1]), import.meta.url).then(e => e.default || e.default || e)), _y = X(() => J(() => import("./ncxNjMGg.js"), __vite__mapDeps([34, 5]), import.meta.url).then(e => e.default || e.default || e)), by = X(() => J(() => import("./cskS5pPq.js"), __vite__mapDeps([35, 5]), import.meta.url).then(e => e.default || e.default || e)), vy = X(() => J(() => import("./_py3v4u-.js"), __vite__mapDeps([36, 37, 29, 20, 4, 5, 11, 12, 13, 9, 10, 8, 6, 7, 2, 3, 38]), import.meta.url).then(e => e.default || e.default || e)), wy = X(() => J(() => import("./C6rfD890.js"), __vite__mapDeps([39, 5, 40, 6, 7, 8, 9, 41, 24, 22, 26, 10, 42, 23]), import.meta.url).then(e => e.default || e.default || e)), Ey = X(() => J(() => import("./2tfsRbNX.js"), __vite__mapDeps([40, 6, 7, 8, 9]), import.meta.url).then(e => e.default || e.default || e)), ky = X(() => J(() => import("./aZ4Y0Lae.js"), __vite__mapDeps([43, 5]), import.meta.url).then(e => e.default || e.default || e)), xy = X(() => J(() => import("./f8YF1zu8.js"), __vite__mapDeps([44, 6, 7, 8, 9, 45, 5, 40, 22, 42, 10, 23, 13]), import.meta.url).then(e => e.default || e.default || e)), Ty = X(() => J(() => import("./g1R2rD7M.js"), __vite__mapDeps([46, 6, 7, 8, 9, 4, 5, 21, 25, 22, 24, 26, 10, 38, 20]), import.meta.url).then(e => e.default || e.default || e)), Py = X(() => J(() => import("./zgP0N6he.js"), __vite__mapDeps([47, 5]), import.meta.url).then(e => e.default || e.default || e)), Sy = X(() => J(() => import("./Dq1RDenS.js"), __vite__mapDeps([48, 30, 1, 5, 10]), import.meta.url).then(e => e.default || e.default || e)), Cy = X(() => J(() => import("./iD0nA9sm.js"), __vite__mapDeps([49, 5, 10]), import.meta.url).then(e => e.default || e.default || e)), Ry = X(() => J(() => import("./BiypBkFv.js"), __vite__mapDeps([50, 5]), import.meta.url).then(e => e.default || e.default || e)), Ay = X(() => J(() => import("./C-5-m7rD.js"), __vite__mapDeps([51, 6, 7, 8, 9, 5]), import.meta.url).then(e => e.default || e.default || e)), Iy = X(() => J(() => import("./BZMBIxbL.js"), __vite__mapDeps([52, 6, 7, 8, 9, 5]), import.meta.url).then(e => e.default || e.default || e)), Oy = X(() => J(() => import("./DnQDlVPo.js"), __vite__mapDeps([53, 5]), import.meta.url).then(e => e.default || e.default || e)), My = X(() => J(() => import("./CdpTe8-F.js"), __vite__mapDeps([54, 5]), import.meta.url).then(e => e.default || e.default || e)), Ly = X(() => J(() => import("./Cgbf1oAS.js"), __vite__mapDeps([55, 6, 7, 8, 9, 5]), import.meta.url).then(e => e.default || e.default || e)), Ny = X(() => J(() => import("./vblv4vQm.js"), __vite__mapDeps([56, 45, 9, 3, 5, 22, 24, 10]), import.meta.url).then(e => e.default || e.default || e)), Hy = X(() => J(() => import("./Bvor1FgC.js"), __vite__mapDeps([57, 9, 4, 5, 10]), import.meta.url).then(e => e.default || e.default || e)), Dy = X(() => J(() => import("./D0-o2vGv.js"), __vite__mapDeps([15, 5]), import.meta.url).then(e => e.default || e.default || e)), Fy = X(() => J(() => import("./RWJD3NuS.js"), __vite__mapDeps([58, 5]), import.meta.url).then(e => e.default || e.default || e)), $y = X(() => J(() => import("./575nGSK0.js"), __vite__mapDeps([14, 5]), import.meta.url).then(e => e.default || e.default || e)), jy = X(() => J(() => import("./GQQZIvEN.js"), __vite__mapDeps([59, 37, 29, 20, 4, 5, 11, 12, 13, 9, 10, 8, 6, 7, 2, 3, 45, 38, 40, 60]), import.meta.url).then(e => e.default || e.default || e)), Uy = X(() => J(() => import("./DoalG-R9.js"), [], import.meta.url).then(e => e.default || e.default || e)), Vy = X(() => J(() => import("./UXufbzxE.js"), __vite__mapDeps([61, 5]), import.meta.url).then(e => e.default || e.default || e)), By = X(() => J(() => import("./UMSFwOrz.js"), __vite__mapDeps([62, 5]), import.meta.url).then(e => e.default || e.default || e)), Wy = X(() => J(() => import("./Dv1X7N87.js"), __vite__mapDeps([63, 5]), import.meta.url).then(e => e.default || e.default || e)), Ky = X(() => J(() => import("./BzgfWQNs.js"), __vite__mapDeps([64, 20, 4, 5, 6, 7, 8, 9, 2, 3, 10, 21, 41, 24, 22, 26, 42, 23]), import.meta.url).then(e => e.default || e.default || e)), zy = X(() => J(() => import("./0e6i6oB-.js"), __vite__mapDeps([65, 5]), import.meta.url).then(e => e.default || e.default || e)), qy = X(() => J(() => import("./CbfeJvhz.js"), __vite__mapDeps([66, 5]), import.meta.url).then(e => e.default || e.default || e)), Gy = X(() => J(() => import("./D91nHZiB.js"), __vite__mapDeps([67, 5]), import.meta.url).then(e => e.default || e.default || e)), Yy = X(() => J(() => import("./Brnk9azS.js"), __vite__mapDeps([68, 5]), import.meta.url).then(e => e.default || e.default || e)), Qy = X(() => J(() => import("./DUsHpl6e.js"), __vite__mapDeps([69, 5]), import.meta.url).then(e => e.default || e.default || e)), Jy = X(() => J(() => import("./DTfug1Wx.js"), __vite__mapDeps([70, 5]), import.meta.url).then(e => e.default || e.default || e)), Xy = X(() => J(() => import("./Bw3nkGR1.js"), __vite__mapDeps([16, 5]), import.meta.url).then(e => e.default || e.default || e)), Zy = X(() => J(() => import("./D9YW5nRf.js"), __vite__mapDeps([71, 30, 1, 32, 11, 12, 4, 5, 13, 9, 10, 8, 6, 7]), import.meta.url).then(e => e.default || e.default || e)), e_ = X(() => J(() => import("./znhT23nw.js"), __vite__mapDeps([72, 30, 1, 32, 11, 12, 4, 5, 13, 9, 10, 8, 6, 7]), import.meta.url).then(e => e.default || e.default || e)), t_ = X(() => J(() => import("./P_1yuZuv.js"), __vite__mapDeps([73, 30, 1, 32, 11, 12, 4, 5, 13, 9, 10, 8, 6, 7]), import.meta.url).then(e => e.default || e.default || e)), n_ = X(() => J(() => import("./BcocdFyD.js"), __vite__mapDeps([74, 30, 1, 32, 11, 12, 4, 5, 13, 9, 10, 8, 6, 7]), import.meta.url).then(e => e.default || e.default || e)), s_ = X(() => J(() => import("./CgG_Arcu.js"), [], import.meta.url).then(e => e.default || e.default || e)), o_ = X(() => J(() => import("./ChWBdZ07.js"), [], import.meta.url).then(e => e.default || e.default || e)), r_ = X(() => J(() => import("./DLkoZ6XF.js"), [], import.meta.url).then(e => e.default || e.default || e)), i_ = [["ProseA", fy], ["ProseAccordion", hy], ["ProseAccordionItem", dy], ["ProseBadge", py], ["ProseBlockquote", gy], ["ProseCallout", my], ["ProseCard", yy], ["ProseCardGroup", _y], ["ProseCode", by], ["ProseCodeCollapse", vy], ["ProseCodeGroup", wy], ["ProseCodeIcon", Ey], ["ProseCodePreview", ky], ["ProseCodeTree", xy], ["ProseCollapsible", Ty], ["ProseEm", Py], ["ProseField", Sy], ["ProseFieldGroup", Cy], ["ProseH1", Ry], ["ProseH2", Ay], ["ProseH3", Iy], ["ProseH4", Oy], ["ProseHr", My], ["ProseIcon", Ly], ["ProseImg", Ny], ["ProseKbd", Hy], ["ProseLi", Dy], ["ProseOl", Fy], ["ProseP", $y], ["ProsePre", jy], ["ProseScript", Uy], ["ProseSteps", Vy], ["ProseStrong", By], ["ProseTable", Wy], ["ProseTabs", Ky], ["ProseTabsItem", zy], ["ProseTbody", qy], ["ProseTd", Gy], ["ProseTh", Yy], ["ProseThead", Qy], ["ProseTr", Jy], ["ProseUl", Xy], ["ProseCaution", Zy], ["ProseNote", e_], ["ProseTip", t_], ["ProseWarning", n_], ["ProseH5", s_], ["ProseH6", o_], ["Icon", r_]], a_ = qe({ name: "nuxt:global-components", setup(e) { for (const [t, n] of i_) e.vueApp.component(t, n), e.vueApp.component("Lazy" + t, n) } }), Fs = {}; function c_(e) { if (e != null && e.__asyncLoader && !e.__asyncResolved) return e.__asyncLoader() } async function l_(e, t = Qe()) { const { path: n, matched: s } = t.resolve(e); if (!s.length || (t._routePreloaded || (t._routePreloaded = new Set), t._routePreloaded.has(n))) return; const o = t._preloadPromises || (t._preloadPromises = []); if (o.length > 4) return Promise.all(o).then(() => l_(e, t)); t._routePreloaded.add(n); const r = s.map(i => { var a; return (a = i.components) == null ? void 0 : a.default }).filter(i => typeof i == "function"); for (const i of r) { const a = Promise.resolve(i()).catch(() => { }).finally(() => o.splice(o.indexOf(a))); o.push(a) } await Promise.all(o) } const u_ = qe({ name: "nuxt:prefetch", setup(e) { const t = Qe(); e.hooks.hook("app:mounted", () => { t.beforeEach(async n => { var o; const s = (o = n == null ? void 0 : n.meta) == null ? void 0 : o.layout; s && typeof Fs[s] == "function" && await Fs[s]() }) }), e.hooks.hook("link:prefetch", n => { if (dn(n)) return; const s = t.resolve(n); if (!s) return; const o = s.meta.layout; let r = Ai(s.meta.middleware); r = r.filter(i => typeof i == "string"); for (const i of r) typeof ss[i] == "function" && ss[i](); typeof o == "string" && o in Fs && c_(Fs[o]) }) } }); function f_(e) { return e === "file:" } function h_(e, t, n) { return n ? t.some(s => e === s || e.endsWith(`.${s}`)) : t.includes(e) } function d_() { try { return localStorage.getItem("plausible_ignore") === "true" } catch { return !1 } } function p_(e = {}) { const { url: t, referrer: n, deviceWidth: s } = e; return { url: t ?? window.location.href, referrer: n ?? document.referrer, deviceWidth: s ?? window.innerWidth } } function g_(e, t, n) { return fetch(`${e}/api/event`, { method: "POST", headers: { "Content-Type": "text/plain" }, body: JSON.stringify(t) }).then(s => { n == null || n({ status: s.status }) }).catch(() => { }) } function m_(e, t, n, s) { return { n: e, u: n.url, d: t.domain, r: n.referrer, w: n.deviceWidth, h: t.hashMode ? 1 : 0, p: s && s.props ? JSON.stringify(s.props) : void 0, $: s && s.revenue ? s.revenue : void 0 } } function y_(e) { const t = window.location.protocol, s = { ...{ enabled: !0, hashMode: !1, domain: window.location.hostname, apiHost: "https://plausible.io", ignoredHostnames: ["localhost"], ignoreSubDomains: !1, logIgnored: !1 }, ...e }, o = (a, c) => g_(s.apiHost, a, c); function r(a, c) { var f; if (!s.enabled) return; const u = p_(c == null ? void 0 : c.data), l = m_(a, s, u, c); if (f_(t) || h_(s.domain, s.ignoredHostnames, s.ignoreSubDomains) || d_()) s.logIgnored && console.info(`[Plausible] ${a}`, l), (f = c == null ? void 0 : c.callback) == null || f.call(c, { status: null }); else return o(l, c == null ? void 0 : c.callback) } function i(a) { return r("pageview", a) } return window.plausible = r, { trackEvent: r, trackPageview: i, options: s } } const __ = "$s"; function b_(...e) { const t = typeof e[e.length - 1] == "string" ? e.pop() : void 0; typeof e[0] != "string" && e.unshift(t); const [n, s] = e; if (!n || typeof n != "string") throw new TypeError("[nuxt] [useState] key must be a string: " + n); if (s !== void 0 && typeof s != "function") throw new Error("[nuxt] [useState] init must be a function: " + s); const o = __ + n, r = we(), i = Yc(r.payload.state, o); if (i.value === void 0 && s) { const a = s(); if (xe(a)) return r.payload.state[o] = a, a; i.value = a } return i } const v_ = { ui: { colors: { primary: "slate", neutral: "slate" } }, uiPro: { prose: { a: { base: "text-highlighted font-bold border-b border-highlighted hover:text-highlighted/80" } } } }, w_ = { nuxt: {}, ui: { colors: { primary: "green", secondary: "blue", success: "green", info: "blue", warning: "yellow", error: "red", neutral: "slate" }, icons: { arrowLeft: "i-lucide-arrow-left", arrowRight: "i-lucide-arrow-right", check: "i-lucide-check", chevronDoubleLeft: "i-lucide-chevrons-left", chevronDoubleRight: "i-lucide-chevrons-right", chevronDown: "i-lucide-chevron-down", chevronLeft: "i-lucide-chevron-left", chevronRight: "i-lucide-chevron-right", chevronUp: "i-lucide-chevron-up", close: "i-lucide-x", ellipsis: "i-lucide-ellipsis", external: "i-lucide-arrow-up-right", folder: "i-lucide-folder", folderOpen: "i-lucide-folder-open", loading: "i-lucide-loader-circle", minus: "i-lucide-minus", plus: "i-lucide-plus", search: "i-lucide-search", arrowUp: "i-lucide-arrow-up", arrowDown: "i-lucide-arrow-down", caution: "i-lucide-circle-alert", copy: "i-lucide-copy", copyCheck: "i-lucide-copy-check", dark: "i-lucide-moon", error: "i-lucide-circle-x", eye: "i-lucide-eye", eyeOff: "i-lucide-eye-off", file: "i-lucide-file-text", hash: "i-lucide-hash", info: "i-lucide-info", light: "i-lucide-sun", menu: "i-lucide-menu", panelClose: "i-lucide-panel-left-close", panelOpen: "i-lucide-panel-left-open", reload: "i-lucide-rotate-ccw", stop: "i-lucide-square", success: "i-lucide-circle-check", system: "i-lucide-monitor", tip: "i-lucide-lightbulb", warning: "i-lucide-triangle-alert" } }, icon: { provider: "server", class: "", aliases: {}, iconifyApiEndpoint: "https://api.iconify.design", localApiEndpoint: "/api/_nuxt_icon", fallbackToApi: !0, cssSelectorPrefix: "i-", cssWherePseudo: !0, cssLayer: "components", mode: "css", attrs: { "aria-hidden": !0 }, collections: ["academicons", "akar-icons", "ant-design", "arcticons", "basil", "bi", "bitcoin-icons", "bpmn", "brandico", "bx", "bxl", "bxs", "bytesize", "carbon", "catppuccin", "cbi", "charm", "ci", "cib", "cif", "cil", "circle-flags", "circum", "clarity", "codicon", "covid", "cryptocurrency", "cryptocurrency-color", "dashicons", "devicon", "devicon-plain", "ei", "el", "emojione", "emojione-monotone", "emojione-v1", "entypo", "entypo-social", "eos-icons", "ep", "et", "eva", "f7", "fa", "fa-brands", "fa-regular", "fa-solid", "fa6-brands", "fa6-regular", "fa6-solid", "fad", "fe", "feather", "file-icons", "flag", "flagpack", "flat-color-icons", "flat-ui", "flowbite", "fluent", "fluent-emoji", "fluent-emoji-flat", "fluent-emoji-high-contrast", "fluent-mdl2", "fontelico", "fontisto", "formkit", "foundation", "fxemoji", "gala", "game-icons", "geo", "gg", "gis", "gravity-ui", "gridicons", "grommet-icons", "guidance", "healthicons", "heroicons", "heroicons-outline", "heroicons-solid", "hugeicons", "humbleicons", "ic", "icomoon-free", "icon-park", "icon-park-outline", "icon-park-solid", "icon-park-twotone", "iconamoon", "iconoir", "icons8", "il", "ion", "iwwa", "jam", "la", "lets-icons", "line-md", "logos", "ls", "lucide", "lucide-lab", "mage", "majesticons", "maki", "map", "marketeq", "material-symbols", "material-symbols-light", "mdi", "mdi-light", "medical-icon", "memory", "meteocons", "mi", "mingcute", "mono-icons", "mynaui", "nimbus", "nonicons", "noto", "noto-v1", "octicon", "oi", "ooui", "openmoji", "oui", "pajamas", "pepicons", "pepicons-pencil", "pepicons-pop", "pepicons-print", "ph", "pixelarticons", "prime", "ps", "quill", "radix-icons", "raphael", "ri", "rivet-icons", "si-glyph", "simple-icons", "simple-line-icons", "skill-icons", "solar", "streamline", "streamline-emojis", "subway", "svg-spinners", "system-uicons", "tabler", "tdesign", "teenyicons", "token", "token-branded", "topcoat", "twemoji", "typcn", "uil", "uim", "uis", "uit", "uiw", "unjs", "vaadin", "vs", "vscode-icons", "websymbol", "weui", "whh", "wi", "wpf", "zmdi", "zondicons"], fetchTimeout: 1500 }, uiPro: {} }, E_ = Fg(v_, w_); function rf() { const e = we(); return e._appConfig || (e._appConfig = ht(E_)), e._appConfig } const k_ = qe({ name: "plausible", setup() { const e = pn().public.plausible; return e.enabled ? { provide: { plausible: y_({ ...e, logIgnored: e.logIgnoredEvents, domain: e.domain || window.location.hostname, apiHost: e.proxy ? e.proxyBaseEndpoint : e.apiHost }) } } : void 0 } }); var $s = { inherit: "inherit", current: "currentcolor", transparent: "transparent", black: "#000", white: "#fff", slate: { 50: "oklch(98.4% 0.003 247.858)", 100: "oklch(96.8% 0.007 247.896)", 200: "oklch(92.9% 0.013 255.508)", 300: "oklch(86.9% 0.022 252.894)", 400: "oklch(70.4% 0.04 256.788)", 500: "oklch(55.4% 0.046 257.417)", 600: "oklch(44.6% 0.043 257.281)", 700: "oklch(37.2% 0.044 257.287)", 800: "oklch(27.9% 0.041 260.031)", 900: "oklch(20.8% 0.042 265.755)", 950: "oklch(12.9% 0.042 264.695)" }, gray: { 50: "oklch(98.5% 0.002 247.839)", 100: "oklch(96.7% 0.003 264.542)", 200: "oklch(92.8% 0.006 264.531)", 300: "oklch(87.2% 0.01 258.338)", 400: "oklch(70.7% 0.022 261.325)", 500: "oklch(55.1% 0.027 264.364)", 600: "oklch(44.6% 0.03 256.802)", 700: "oklch(37.3% 0.034 259.733)", 800: "oklch(27.8% 0.033 256.848)", 900: "oklch(21% 0.034 264.665)", 950: "oklch(13% 0.028 261.692)" }, zinc: { 50: "oklch(98.5% 0 0)", 100: "oklch(96.7% 0.001 286.375)", 200: "oklch(92% 0.004 286.32)", 300: "oklch(87.1% 0.006 286.286)", 400: "oklch(70.5% 0.015 286.067)", 500: "oklch(55.2% 0.016 285.938)", 600: "oklch(44.2% 0.017 285.786)", 700: "oklch(37% 0.013 285.805)", 800: "oklch(27.4% 0.006 286.033)", 900: "oklch(21% 0.006 285.885)", 950: "oklch(14.1% 0.005 285.823)" }, neutral: { 50: "oklch(98.5% 0 0)", 100: "oklch(97% 0 0)", 200: "oklch(92.2% 0 0)", 300: "oklch(87% 0 0)", 400: "oklch(70.8% 0 0)", 500: "oklch(55.6% 0 0)", 600: "oklch(43.9% 0 0)", 700: "oklch(37.1% 0 0)", 800: "oklch(26.9% 0 0)", 900: "oklch(20.5% 0 0)", 950: "oklch(14.5% 0 0)" }, stone: { 50: "oklch(98.5% 0.001 106.423)", 100: "oklch(97% 0.001 106.424)", 200: "oklch(92.3% 0.003 48.717)", 300: "oklch(86.9% 0.005 56.366)", 400: "oklch(70.9% 0.01 56.259)", 500: "oklch(55.3% 0.013 58.071)", 600: "oklch(44.4% 0.011 73.639)", 700: "oklch(37.4% 0.01 67.558)", 800: "oklch(26.8% 0.007 34.298)", 900: "oklch(21.6% 0.006 56.043)", 950: "oklch(14.7% 0.004 49.25)" }, red: { 50: "oklch(97.1% 0.013 17.38)", 100: "oklch(93.6% 0.032 17.717)", 200: "oklch(88.5% 0.062 18.334)", 300: "oklch(80.8% 0.114 19.571)", 400: "oklch(70.4% 0.191 22.216)", 500: "oklch(63.7% 0.237 25.331)", 600: "oklch(57.7% 0.245 27.325)", 700: "oklch(50.5% 0.213 27.518)", 800: "oklch(44.4% 0.177 26.899)", 900: "oklch(39.6% 0.141 25.723)", 950: "oklch(25.8% 0.092 26.042)" }, orange: { 50: "oklch(98% 0.016 73.684)", 100: "oklch(95.4% 0.038 75.164)", 200: "oklch(90.1% 0.076 70.697)", 300: "oklch(83.7% 0.128 66.29)", 400: "oklch(75% 0.183 55.934)", 500: "oklch(70.5% 0.213 47.604)", 600: "oklch(64.6% 0.222 41.116)", 700: "oklch(55.3% 0.195 38.402)", 800: "oklch(47% 0.157 37.304)", 900: "oklch(40.8% 0.123 38.172)", 950: "oklch(26.6% 0.079 36.259)" }, amber: { 50: "oklch(98.7% 0.022 95.277)", 100: "oklch(96.2% 0.059 95.617)", 200: "oklch(92.4% 0.12 95.746)", 300: "oklch(87.9% 0.169 91.605)", 400: "oklch(82.8% 0.189 84.429)", 500: "oklch(76.9% 0.188 70.08)", 600: "oklch(66.6% 0.179 58.318)", 700: "oklch(55.5% 0.163 48.998)", 800: "oklch(47.3% 0.137 46.201)", 900: "oklch(41.4% 0.112 45.904)", 950: "oklch(27.9% 0.077 45.635)" }, yellow: { 50: "oklch(98.7% 0.026 102.212)", 100: "oklch(97.3% 0.071 103.193)", 200: "oklch(94.5% 0.129 101.54)", 300: "oklch(90.5% 0.182 98.111)", 400: "oklch(85.2% 0.199 91.936)", 500: "oklch(79.5% 0.184 86.047)", 600: "oklch(68.1% 0.162 75.834)", 700: "oklch(55.4% 0.135 66.442)", 800: "oklch(47.6% 0.114 61.907)", 900: "oklch(42.1% 0.095 57.708)", 950: "oklch(28.6% 0.066 53.813)" }, lime: { 50: "oklch(98.6% 0.031 120.757)", 100: "oklch(96.7% 0.067 122.328)", 200: "oklch(93.8% 0.127 124.321)", 300: "oklch(89.7% 0.196 126.665)", 400: "oklch(84.1% 0.238 128.85)", 500: "oklch(76.8% 0.233 130.85)", 600: "oklch(64.8% 0.2 131.684)", 700: "oklch(53.2% 0.157 131.589)", 800: "oklch(45.3% 0.124 130.933)", 900: "oklch(40.5% 0.101 131.063)", 950: "oklch(27.4% 0.072 132.109)" }, green: { 50: "oklch(98.2% 0.018 155.826)", 100: "oklch(96.2% 0.044 156.743)", 200: "oklch(92.5% 0.084 155.995)", 300: "oklch(87.1% 0.15 154.449)", 400: "oklch(79.2% 0.209 151.711)", 500: "oklch(72.3% 0.219 149.579)", 600: "oklch(62.7% 0.194 149.214)", 700: "oklch(52.7% 0.154 150.069)", 800: "oklch(44.8% 0.119 151.328)", 900: "oklch(39.3% 0.095 152.535)", 950: "oklch(26.6% 0.065 152.934)" }, emerald: { 50: "oklch(97.9% 0.021 166.113)", 100: "oklch(95% 0.052 163.051)", 200: "oklch(90.5% 0.093 164.15)", 300: "oklch(84.5% 0.143 164.978)", 400: "oklch(76.5% 0.177 163.223)", 500: "oklch(69.6% 0.17 162.48)", 600: "oklch(59.6% 0.145 163.225)", 700: "oklch(50.8% 0.118 165.612)", 800: "oklch(43.2% 0.095 166.913)", 900: "oklch(37.8% 0.077 168.94)", 950: "oklch(26.2% 0.051 172.552)" }, teal: { 50: "oklch(98.4% 0.014 180.72)", 100: "oklch(95.3% 0.051 180.801)", 200: "oklch(91% 0.096 180.426)", 300: "oklch(85.5% 0.138 181.071)", 400: "oklch(77.7% 0.152 181.912)", 500: "oklch(70.4% 0.14 182.503)", 600: "oklch(60% 0.118 184.704)", 700: "oklch(51.1% 0.096 186.391)", 800: "oklch(43.7% 0.078 188.216)", 900: "oklch(38.6% 0.063 188.416)", 950: "oklch(27.7% 0.046 192.524)" }, cyan: { 50: "oklch(98.4% 0.019 200.873)", 100: "oklch(95.6% 0.045 203.388)", 200: "oklch(91.7% 0.08 205.041)", 300: "oklch(86.5% 0.127 207.078)", 400: "oklch(78.9% 0.154 211.53)", 500: "oklch(71.5% 0.143 215.221)", 600: "oklch(60.9% 0.126 221.723)", 700: "oklch(52% 0.105 223.128)", 800: "oklch(45% 0.085 224.283)", 900: "oklch(39.8% 0.07 227.392)", 950: "oklch(30.2% 0.056 229.695)" }, sky: { 50: "oklch(97.7% 0.013 236.62)", 100: "oklch(95.1% 0.026 236.824)", 200: "oklch(90.1% 0.058 230.902)", 300: "oklch(82.8% 0.111 230.318)", 400: "oklch(74.6% 0.16 232.661)", 500: "oklch(68.5% 0.169 237.323)", 600: "oklch(58.8% 0.158 241.966)", 700: "oklch(50% 0.134 242.749)", 800: "oklch(44.3% 0.11 240.79)", 900: "oklch(39.1% 0.09 240.876)", 950: "oklch(29.3% 0.066 243.157)" }, blue: { 50: "oklch(97% 0.014 254.604)", 100: "oklch(93.2% 0.032 255.585)", 200: "oklch(88.2% 0.059 254.128)", 300: "oklch(80.9% 0.105 251.813)", 400: "oklch(70.7% 0.165 254.624)", 500: "oklch(62.3% 0.214 259.815)", 600: "oklch(54.6% 0.245 262.881)", 700: "oklch(48.8% 0.243 264.376)", 800: "oklch(42.4% 0.199 265.638)", 900: "oklch(37.9% 0.146 265.522)", 950: "oklch(28.2% 0.091 267.935)" }, indigo: { 50: "oklch(96.2% 0.018 272.314)", 100: "oklch(93% 0.034 272.788)", 200: "oklch(87% 0.065 274.039)", 300: "oklch(78.5% 0.115 274.713)", 400: "oklch(67.3% 0.182 276.935)", 500: "oklch(58.5% 0.233 277.117)", 600: "oklch(51.1% 0.262 276.966)", 700: "oklch(45.7% 0.24 277.023)", 800: "oklch(39.8% 0.195 277.366)", 900: "oklch(35.9% 0.144 278.697)", 950: "oklch(25.7% 0.09 281.288)" }, violet: { 50: "oklch(96.9% 0.016 293.756)", 100: "oklch(94.3% 0.029 294.588)", 200: "oklch(89.4% 0.057 293.283)", 300: "oklch(81.1% 0.111 293.571)", 400: "oklch(70.2% 0.183 293.541)", 500: "oklch(60.6% 0.25 292.717)", 600: "oklch(54.1% 0.281 293.009)", 700: "oklch(49.1% 0.27 292.581)", 800: "oklch(43.2% 0.232 292.759)", 900: "oklch(38% 0.189 293.745)", 950: "oklch(28.3% 0.141 291.089)" }, purple: { 50: "oklch(97.7% 0.014 308.299)", 100: "oklch(94.6% 0.033 307.174)", 200: "oklch(90.2% 0.063 306.703)", 300: "oklch(82.7% 0.119 306.383)", 400: "oklch(71.4% 0.203 305.504)", 500: "oklch(62.7% 0.265 303.9)", 600: "oklch(55.8% 0.288 302.321)", 700: "oklch(49.6% 0.265 301.924)", 800: "oklch(43.8% 0.218 303.724)", 900: "oklch(38.1% 0.176 304.987)", 950: "oklch(29.1% 0.149 302.717)" }, fuchsia: { 50: "oklch(97.7% 0.017 320.058)", 100: "oklch(95.2% 0.037 318.852)", 200: "oklch(90.3% 0.076 319.62)", 300: "oklch(83.3% 0.145 321.434)", 400: "oklch(74% 0.238 322.16)", 500: "oklch(66.7% 0.295 322.15)", 600: "oklch(59.1% 0.293 322.896)", 700: "oklch(51.8% 0.253 323.949)", 800: "oklch(45.2% 0.211 324.591)", 900: "oklch(40.1% 0.17 325.612)", 950: "oklch(29.3% 0.136 325.661)" }, pink: { 50: "oklch(97.1% 0.014 343.198)", 100: "oklch(94.8% 0.028 342.258)", 200: "oklch(89.9% 0.061 343.231)", 300: "oklch(82.3% 0.12 346.018)", 400: "oklch(71.8% 0.202 349.761)", 500: "oklch(65.6% 0.241 354.308)", 600: "oklch(59.2% 0.249 0.584)", 700: "oklch(52.5% 0.223 3.958)", 800: "oklch(45.9% 0.187 3.815)", 900: "oklch(40.8% 0.153 2.432)", 950: "oklch(28.4% 0.109 3.907)" }, rose: { 50: "oklch(96.9% 0.015 12.422)", 100: "oklch(94.1% 0.03 12.58)", 200: "oklch(89.2% 0.058 10.001)", 300: "oklch(81% 0.117 11.638)", 400: "oklch(71.2% 0.194 13.428)", 500: "oklch(64.5% 0.246 16.439)", 600: "oklch(58.6% 0.253 17.585)", 700: "oklch(51.4% 0.222 16.935)", 800: "oklch(45.5% 0.188 13.697)", 900: "oklch(41% 0.159 10.272)", 950: "oklch(27.1% 0.105 12.094)" } }; const x_ = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950]; function T_(e, t) { return e in $s && typeof $s[e] == "object" && t in $s[e] ? $s[e][t] : "" } function P_(e, t) {
    return `${x_.map(n => `--ui-color-${e}-${n}: var(--color-${t === "neutral" ? "old-neutral" : t}-${n}, ${T_(t, n)});`).join(`
  `)}`
} function lc(e, t) { return `--ui-${e}: var(--ui-color-${e}-${t});` } const S_ = qe(() => {
    const e = rf(), t = we(), n = et(() => {
        const { neutral: o, ...r } = e.ui.colors; return `@layer base {
  :root {
  ${Object.entries(e.ui.colors).map(([i, a]) => P_(i, a)).join(`
  `)}
  }
  :root, .light {
  ${Object.keys(r).map(i => lc(i, 500)).join(`
  `)}
  }
  .dark {
  ${Object.keys(r).map(i => lc(i, 400)).join(`
  `)}
  }
}`}), s = { style: [{ innerHTML: () => n.value, tagPriority: -2, id: "nuxt-ui-colors" }] }; if (t.isHydrating && !t.payload.serverRendered) { const o = document.createElement("style"); o.innerHTML = n.value, o.setAttribute("data-nuxt-ui-colors", ""), document.head.appendChild(o), s.script = [{ innerHTML: "document.head.removeChild(document.querySelector('[data-nuxt-ui-colors]'))" }] } ju(s)
}), C_ = "__NUXT_COLOR_MODE__", ur = "nuxt-color-mode", R_ = "localStorage", kt = window[C_] || {}, A_ = qe(e => { const t = b_("color-mode", () => ht({ preference: kt.preference, value: kt.value, unknown: !1, forced: !1 })).value; Qe().afterEach(r => { const i = r.meta.colorMode; i && i !== "system" ? (t.value = i, t.forced = !0) : (i === "system" && console.warn("You cannot force the colorMode to system at the page level."), t.forced = !1, t.value = t.preference === "system" ? kt.getColorScheme() : t.preference) }); let n; function s() { n || !window.matchMedia || (n = window.matchMedia("(prefers-color-scheme: dark)"), n.addEventListener("change", () => { !t.forced && t.preference === "system" && (t.value = kt.getColorScheme()) })) } function o(r, i) { var a, c; switch (r) { case "cookie": window.document.cookie = ur + "=" + i; break; case "sessionStorage": (a = window.sessionStorage) == null || a.setItem(ur, i); break; case "localStorage": default: (c = window.localStorage) == null || c.setItem(ur, i) } } bt(() => t.preference, r => { t.forced || (r === "system" ? (t.value = kt.getColorScheme(), s()) : t.value = r, o(R_, r)) }, { immediate: !0 }), bt(() => t.value, (r, i) => { let a; a = window.document.createElement("style"), a.appendChild(document.createTextNode("*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), window.document.head.appendChild(a), kt.removeColorScheme(i), kt.addColorScheme(r), window.getComputedStyle(a).opacity, document.head.removeChild(a) }), t.preference === "system" && s(), e.hook("app:mounted", () => { t.unknown && (t.preference = kt.preference, t.value = kt.value, t.unknown = !1) }), e.provide("colorMode", t) }), af = /^[a-z0-9]+(-[a-z0-9]+)*$/, Ts = (e, t, n, s = "") => { const o = e.split(":"); if (e.slice(0, 1) === "@") { if (o.length < 2 || o.length > 3) return null; s = o.shift().slice(1) } if (o.length > 3 || !o.length) return null; if (o.length > 1) { const a = o.pop(), c = o.pop(), u = { provider: o.length > 0 ? o[0] : s, prefix: c, name: a }; return t && !qs(u) ? null : u } const r = o[0], i = r.split("-"); if (i.length > 1) { const a = { provider: s, prefix: i.shift(), name: i.join("-") }; return t && !qs(a) ? null : a } if (n && s === "") { const a = { provider: s, prefix: "", name: r }; return t && !qs(a, n) ? null : a } return null }, qs = (e, t) => e ? !!((t && e.prefix === "" || e.prefix) && e.name) : !1, cf = Object.freeze({ left: 0, top: 0, width: 16, height: 16 }), wo = Object.freeze({ rotate: 0, vFlip: !1, hFlip: !1 }), Fn = Object.freeze({ ...cf, ...wo }), qr = Object.freeze({ ...Fn, body: "", hidden: !1 }); function I_(e, t) { const n = {}; !e.hFlip != !t.hFlip && (n.hFlip = !0), !e.vFlip != !t.vFlip && (n.vFlip = !0); const s = ((e.rotate || 0) + (t.rotate || 0)) % 4; return s && (n.rotate = s), n } function uc(e, t) { const n = I_(e, t); for (const s in qr) s in wo ? s in e && !(s in n) && (n[s] = wo[s]) : s in t ? n[s] = t[s] : s in e && (n[s] = e[s]); return n } function O_(e, t) { const n = e.icons, s = e.aliases || Object.create(null), o = Object.create(null); function r(i) { if (n[i]) return o[i] = []; if (!(i in o)) { o[i] = null; const a = s[i] && s[i].parent, c = a && r(a); c && (o[i] = [a].concat(c)) } return o[i] } return Object.keys(n).concat(Object.keys(s)).forEach(r), o } function M_(e, t, n) { const s = e.icons, o = e.aliases || Object.create(null); let r = {}; function i(a) { r = uc(s[a] || o[a], r) } return i(t), n.forEach(i), uc(e, r) } function lf(e, t) { const n = []; if (typeof e != "object" || typeof e.icons != "object") return n; e.not_found instanceof Array && e.not_found.forEach(o => { t(o, null), n.push(o) }); const s = O_(e); for (const o in s) { const r = s[o]; r && (t(o, M_(e, o, r)), n.push(o)) } return n } const L_ = { provider: "", aliases: {}, not_found: {}, ...cf }; function fr(e, t) { for (const n in t) if (n in e && typeof e[n] != typeof t[n]) return !1; return !0 } function uf(e) { if (typeof e != "object" || e === null) return null; const t = e; if (typeof t.prefix != "string" || !e.icons || typeof e.icons != "object" || !fr(e, L_)) return null; const n = t.icons; for (const o in n) { const r = n[o]; if (!o || typeof r.body != "string" || !fr(r, qr)) return null } const s = t.aliases || Object.create(null); for (const o in s) { const r = s[o], i = r.parent; if (!o || typeof i != "string" || !n[i] && !s[i] || !fr(r, qr)) return null } return t } const fc = Object.create(null); function N_(e, t) { return { provider: e, prefix: t, icons: Object.create(null), missing: new Set } } function un(e, t) { const n = fc[e] || (fc[e] = Object.create(null)); return n[t] || (n[t] = N_(e, t)) } function ff(e, t) { return uf(t) ? lf(t, (n, s) => { s ? e.icons[n] = s : e.missing.add(n) }) : [] } function H_(e, t, n) { try { if (typeof n.body == "string") return e.icons[t] = { ...n }, !0 } catch { } return !1 } let gs = !1; function hf(e) { return typeof e == "boolean" && (gs = e), gs } function Oi(e) { const t = typeof e == "string" ? Ts(e, !0, gs) : e; if (t) { const n = un(t.provider, t.prefix), s = t.name; return n.icons[s] || (n.missing.has(s) ? null : void 0) } } function D_(e, t) { const n = Ts(e, !0, gs); if (!n) return !1; const s = un(n.provider, n.prefix); return t ? H_(s, n.name, t) : (s.missing.add(n.name), !0) } function F_(e, t) { if (typeof e != "object") return !1; if (typeof t != "string" && (t = e.provider || ""), gs && !t && !e.prefix) { let o = !1; return uf(e) && (e.prefix = "", lf(e, (r, i) => { D_(r, i) && (o = !0) })), o } const n = e.prefix; if (!qs({ prefix: n, name: "a" })) return !1; const s = un(t, n); return !!ff(s, e) } function ww(e) { const t = Oi(e); return t && { ...Fn, ...t } } const df = Object.freeze({ width: null, height: null }), pf = Object.freeze({ ...df, ...wo }), $_ = /(-?[0-9.]*[0-9]+[0-9.]*)/g, j_ = /^-?[0-9.]*[0-9]+[0-9.]*$/g; function hc(e, t, n) { if (t === 1) return e; if (n = n || 100, typeof e == "number") return Math.ceil(e * t * n) / n; if (typeof e != "string") return e; const s = e.split($_); if (s === null || !s.length) return e; const o = []; let r = s.shift(), i = j_.test(r); for (; ;) { if (i) { const a = parseFloat(r); isNaN(a) ? o.push(r) : o.push(Math.ceil(a * t * n) / n) } else o.push(r); if (r = s.shift(), r === void 0) return o.join(""); i = !i } } function U_(e, t = "defs") { let n = ""; const s = e.indexOf("<" + t); for (; s >= 0;) { const o = e.indexOf(">", s), r = e.indexOf("</" + t); if (o === -1 || r === -1) break; const i = e.indexOf(">", r); if (i === -1) break; n += e.slice(o + 1, r).trim(), e = e.slice(0, s).trim() + e.slice(i + 1) } return { defs: n, content: e } } function V_(e, t) { return e ? "<defs>" + e + "</defs>" + t : t } function B_(e, t, n) { const s = U_(e); return V_(s.defs, t + s.content + n) } const W_ = e => e === "unset" || e === "undefined" || e === "none"; function K_(e, t) { const n = { ...Fn, ...e }, s = { ...pf, ...t }, o = { left: n.left, top: n.top, width: n.width, height: n.height }; let r = n.body;[n, s].forEach(g => { const E = [], k = g.hFlip, w = g.vFlip; let d = g.rotate; k ? w ? d += 2 : (E.push("translate(" + (o.width + o.left).toString() + " " + (0 - o.top).toString() + ")"), E.push("scale(-1 1)"), o.top = o.left = 0) : w && (E.push("translate(" + (0 - o.left).toString() + " " + (o.height + o.top).toString() + ")"), E.push("scale(1 -1)"), o.top = o.left = 0); let y; switch (d < 0 && (d -= Math.floor(d / 4) * 4), d = d % 4, d) { case 1: y = o.height / 2 + o.top, E.unshift("rotate(90 " + y.toString() + " " + y.toString() + ")"); break; case 2: E.unshift("rotate(180 " + (o.width / 2 + o.left).toString() + " " + (o.height / 2 + o.top).toString() + ")"); break; case 3: y = o.width / 2 + o.left, E.unshift("rotate(-90 " + y.toString() + " " + y.toString() + ")"); break }d % 2 === 1 && (o.left !== o.top && (y = o.left, o.left = o.top, o.top = y), o.width !== o.height && (y = o.width, o.width = o.height, o.height = y)), E.length && (r = B_(r, '<g transform="' + E.join(" ") + '">', "</g>")) }); const i = s.width, a = s.height, c = o.width, u = o.height; let l, f; i === null ? (f = a === null ? "1em" : a === "auto" ? u : a, l = hc(f, c / u)) : (l = i === "auto" ? c : i, f = a === null ? hc(l, u / c) : a === "auto" ? u : a); const h = {}, p = (g, E) => { W_(E) || (h[g] = E.toString()) }; p("width", l), p("height", f); const _ = [o.left, o.top, c, u]; return h.viewBox = _.join(" "), { attributes: h, viewBox: _, body: r } } const z_ = /\sid="(\S+)"/g, q_ = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16); let G_ = 0; function Y_(e, t = q_) { const n = []; let s; for (; s = z_.exec(e);)n.push(s[1]); if (!n.length) return e; const o = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16); return n.forEach(r => { const i = typeof t == "function" ? t(r) : t + (G_++).toString(), a = r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); e = e.replace(new RegExp('([#;"])(' + a + ')([")]|\\.[a-z])', "g"), "$1" + i + o + "$3") }), e = e.replace(new RegExp(o, "g"), ""), e } const Gr = Object.create(null); function gf(e, t) { Gr[e] = t } function Yr(e) { return Gr[e] || Gr[""] } function Mi(e) { let t; if (typeof e.resources == "string") t = [e.resources]; else if (t = e.resources, !(t instanceof Array) || !t.length) return null; return { resources: t, path: e.path || "/", maxURL: e.maxURL || 500, rotate: e.rotate || 750, timeout: e.timeout || 5e3, random: e.random === !0, index: e.index || 0, dataAfterTimeout: e.dataAfterTimeout !== !1 } } const Bo = Object.create(null), Kn = ["https://api.simplesvg.com", "https://api.unisvg.com"], Gs = []; for (; Kn.length > 0;)Kn.length === 1 || Math.random() > .5 ? Gs.push(Kn.shift()) : Gs.push(Kn.pop()); Bo[""] = Mi({ resources: ["https://api.iconify.design"].concat(Gs) }); function mf(e, t) { const n = Mi(t); return n === null ? !1 : (Bo[e] = n, !0) } function Wo(e) { return Bo[e] } function Q_() { return Object.keys(Bo) } const J_ = () => { let e; try { if (e = fetch, typeof e == "function") return e } catch { } }; let Eo = J_(); function X_(e) { Eo = e } function Z_() { return Eo } function eb(e, t) { const n = Wo(e); if (!n) return 0; let s; if (!n.maxURL) s = 0; else { let o = 0; n.resources.forEach(i => { o = Math.max(o, i.length) }); const r = t + ".json?icons="; s = n.maxURL - o - n.path.length - r.length } return s } function tb(e) { return e === 404 } const nb = (e, t, n) => { const s = [], o = eb(e, t), r = "icons"; let i = { type: r, provider: e, prefix: t, icons: [] }, a = 0; return n.forEach((c, u) => { a += c.length + 1, a >= o && u > 0 && (s.push(i), i = { type: r, provider: e, prefix: t, icons: [] }, a = c.length), i.icons.push(c) }), s.push(i), s }; function sb(e) { if (typeof e == "string") { const t = Wo(e); if (t) return t.path } return "/" } const ob = (e, t, n) => { if (!Eo) { n("abort", 424); return } let s = sb(t.provider); switch (t.type) { case "icons": { const r = t.prefix, a = t.icons.join(","), c = new URLSearchParams({ icons: a }); s += r + ".json?" + c.toString(); break } case "custom": { const r = t.uri; s += r.slice(0, 1) === "/" ? r.slice(1) : r; break } default: n("abort", 400); return }let o = 503; Eo(e + s).then(r => { const i = r.status; if (i !== 200) { setTimeout(() => { n(tb(i) ? "abort" : "next", i) }); return } return o = 501, r.json() }).then(r => { if (typeof r != "object" || r === null) { setTimeout(() => { r === 404 ? n("abort", r) : n("next", o) }); return } setTimeout(() => { n("success", r) }) }).catch(() => { n("next", o) }) }, rb = { prepare: nb, send: ob }; function ib(e) { const t = { loaded: [], missing: [], pending: [] }, n = Object.create(null); e.sort((o, r) => o.provider !== r.provider ? o.provider.localeCompare(r.provider) : o.prefix !== r.prefix ? o.prefix.localeCompare(r.prefix) : o.name.localeCompare(r.name)); let s = { provider: "", prefix: "", name: "" }; return e.forEach(o => { if (s.name === o.name && s.prefix === o.prefix && s.provider === o.provider) return; s = o; const r = o.provider, i = o.prefix, a = o.name, c = n[r] || (n[r] = Object.create(null)), u = c[i] || (c[i] = un(r, i)); let l; a in u.icons ? l = t.loaded : i === "" || u.missing.has(a) ? l = t.missing : l = t.pending; const f = { provider: r, prefix: i, name: a }; l.push(f) }), t } function yf(e, t) { e.forEach(n => { const s = n.loaderCallbacks; s && (n.loaderCallbacks = s.filter(o => o.id !== t)) }) } function ab(e) { e.pendingCallbacksFlag || (e.pendingCallbacksFlag = !0, setTimeout(() => { e.pendingCallbacksFlag = !1; const t = e.loaderCallbacks ? e.loaderCallbacks.slice(0) : []; if (!t.length) return; let n = !1; const s = e.provider, o = e.prefix; t.forEach(r => { const i = r.icons, a = i.pending.length; i.pending = i.pending.filter(c => { if (c.prefix !== o) return !0; const u = c.name; if (e.icons[u]) i.loaded.push({ provider: s, prefix: o, name: u }); else if (e.missing.has(u)) i.missing.push({ provider: s, prefix: o, name: u }); else return n = !0, !0; return !1 }), i.pending.length !== a && (n || yf([e], r.id), r.callback(i.loaded.slice(0), i.missing.slice(0), i.pending.slice(0), r.abort)) }) })) } let cb = 0; function lb(e, t, n) { const s = cb++, o = yf.bind(null, n, s); if (!t.pending.length) return o; const r = { id: s, icons: t, callback: e, abort: o }; return n.forEach(i => { (i.loaderCallbacks || (i.loaderCallbacks = [])).push(r) }), o } function ub(e, t = !0, n = !1) { const s = []; return e.forEach(o => { const r = typeof o == "string" ? Ts(o, t, n) : o; r && s.push(r) }), s } var fb = { resources: [], index: 0, timeout: 2e3, rotate: 750, random: !1, dataAfterTimeout: !1 }; function hb(e, t, n, s) { const o = e.resources.length, r = e.random ? Math.floor(Math.random() * o) : e.index; let i; if (e.random) { let T = e.resources.slice(0); for (i = []; T.length > 1;) { const S = Math.floor(Math.random() * T.length); i.push(T[S]), T = T.slice(0, S).concat(T.slice(S + 1)) } i = i.concat(T) } else i = e.resources.slice(r).concat(e.resources.slice(0, r)); const a = Date.now(); let c = "pending", u = 0, l, f = null, h = [], p = []; typeof s == "function" && p.push(s); function _() { f && (clearTimeout(f), f = null) } function g() { c === "pending" && (c = "aborted"), _(), h.forEach(T => { T.status === "pending" && (T.status = "aborted") }), h = [] } function E(T, S) { S && (p = []), typeof T == "function" && p.push(T) } function k() { return { startTime: a, payload: t, status: c, queriesSent: u, queriesPending: h.length, subscribe: E, abort: g } } function w() { c = "failed", p.forEach(T => { T(void 0, l) }) } function d() { h.forEach(T => { T.status === "pending" && (T.status = "aborted") }), h = [] } function y(T, S, F) { const O = S !== "success"; switch (h = h.filter(I => I !== T), c) { case "pending": break; case "failed": if (O || !e.dataAfterTimeout) return; break; default: return }if (S === "abort") { l = F, w(); return } if (O) { l = F, h.length || (i.length ? x() : w()); return } if (_(), d(), !e.random) { const I = e.resources.indexOf(T.resource); I !== -1 && I !== e.index && (e.index = I) } c = "completed", p.forEach(I => { I(F) }) } function x() { if (c !== "pending") return; _(); const T = i.shift(); if (T === void 0) { if (h.length) { f = setTimeout(() => { _(), c === "pending" && (d(), w()) }, e.timeout); return } w(); return } const S = { status: "pending", resource: T, callback: (F, O) => { y(S, F, O) } }; h.push(S), u++, f = setTimeout(x, e.rotate), n(T, t, S.callback) } return setTimeout(x), k } function _f(e) { const t = { ...fb, ...e }; let n = []; function s() { n = n.filter(a => a().status === "pending") } function o(a, c, u) { const l = hb(t, a, c, (f, h) => { s(), u && u(f, h) }); return n.push(l), l } function r(a) { return n.find(c => a(c)) || null } return { query: o, find: r, setIndex: a => { t.index = a }, getIndex: () => t.index, cleanup: s } } function dc() { } const hr = Object.create(null); function db(e) { if (!hr[e]) { const t = Wo(e); if (!t) return; const n = _f(t), s = { config: t, redundancy: n }; hr[e] = s } return hr[e] } function bf(e, t, n) { let s, o; if (typeof e == "string") { const r = Yr(e); if (!r) return n(void 0, 424), dc; o = r.send; const i = db(e); i && (s = i.redundancy) } else { const r = Mi(e); if (r) { s = _f(r); const i = e.resources ? e.resources[0] : "", a = Yr(i); a && (o = a.send) } } return !s || !o ? (n(void 0, 424), dc) : s.query(t, o, n)().abort } function pc() { } function pb(e) { e.iconsLoaderFlag || (e.iconsLoaderFlag = !0, setTimeout(() => { e.iconsLoaderFlag = !1, ab(e) })) } function gb(e) { const t = [], n = []; return e.forEach(s => { (s.match(af) ? t : n).push(s) }), { valid: t, invalid: n } } function zn(e, t, n) { function s() { const o = e.pendingIcons; t.forEach(r => { o && o.delete(r), e.icons[r] || e.missing.add(r) }) } if (n && typeof n == "object") try { if (!ff(e, n).length) { s(); return } } catch (o) { console.error(o) } s(), pb(e) } function gc(e, t) { e instanceof Promise ? e.then(n => { t(n) }).catch(() => { t(null) }) : t(e) } function mb(e, t) { e.iconsToLoad ? e.iconsToLoad = e.iconsToLoad.concat(t).sort() : e.iconsToLoad = t, e.iconsQueueFlag || (e.iconsQueueFlag = !0, setTimeout(() => { e.iconsQueueFlag = !1; const { provider: n, prefix: s } = e, o = e.iconsToLoad; if (delete e.iconsToLoad, !o || !o.length) return; const r = e.loadIcon; if (e.loadIcons && (o.length > 1 || !r)) { gc(e.loadIcons(o, s, n), l => { zn(e, o, l) }); return } if (r) { o.forEach(l => { const f = r(l, s, n); gc(f, h => { const p = h ? { prefix: s, icons: { [l]: h } } : null; zn(e, [l], p) }) }); return } const { valid: i, invalid: a } = gb(o); if (a.length && zn(e, a, null), !i.length) return; const c = s.match(af) ? Yr(n) : null; if (!c) { zn(e, i, null); return } c.prepare(n, s, i).forEach(l => { bf(n, l, f => { zn(e, l.icons, f) }) }) })) } const vf = (e, t) => { const n = ub(e, !0, hf()), s = ib(n); if (!s.pending.length) { let c = !0; return t && setTimeout(() => { c && t(s.loaded, s.missing, s.pending, pc) }), () => { c = !1 } } const o = Object.create(null), r = []; let i, a; return s.pending.forEach(c => { const { provider: u, prefix: l } = c; if (l === a && u === i) return; i = u, a = l, r.push(un(u, l)); const f = o[u] || (o[u] = Object.create(null)); f[l] || (f[l] = []) }), s.pending.forEach(c => { const { provider: u, prefix: l, name: f } = c, h = un(u, l), p = h.pendingIcons || (h.pendingIcons = new Set); p.has(f) || (p.add(f), o[u][l].push(f)) }), r.forEach(c => { const u = o[c.provider][c.prefix]; u.length && mb(c, u) }), t ? lb(t, s, r) : pc }, Ew = e => new Promise((t, n) => { const s = typeof e == "string" ? Ts(e, !0) : e; if (!s) { n(e); return } vf([s || e], o => { if (o.length && s) { const r = Oi(s); if (r) { t({ ...Fn, ...r }); return } } n(e) }) }); function yb(e, t, n) { un("", t).loadIcons = e } function _b(e, t) { const n = { ...e }; for (const s in t) { const o = t[s], r = typeof o; s in df ? (o === null || o && (r === "string" || r === "number")) && (n[s] = o) : r === typeof n[s] && (n[s] = s === "rotate" ? o % 4 : o) } return n } const bb = /[\s,]+/; function vb(e, t) { t.split(bb).forEach(n => { switch (n.trim()) { case "horizontal": e.hFlip = !0; break; case "vertical": e.vFlip = !0; break } }) } function wb(e, t = 0) { const n = e.replace(/^-?[0-9.]*/, ""); function s(o) { for (; o < 0;)o += 4; return o % 4 } if (n === "") { const o = parseInt(e); return isNaN(o) ? 0 : s(o) } else if (n !== e) { let o = 0; switch (n) { case "%": o = 25; break; case "deg": o = 90 }if (o) { let r = parseFloat(e.slice(0, e.length - n.length)); return isNaN(r) ? 0 : (r = r / o, r % 1 === 0 ? s(r) : 0) } } return t } function Eb(e, t) { let n = e.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"'; for (const s in t) n += " " + s + '="' + t[s] + '"'; return '<svg xmlns="http://www.w3.org/2000/svg"' + n + ">" + e + "</svg>" } function kb(e) { return e.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ") } function xb(e) { return "data:image/svg+xml," + kb(e) } function Tb(e) { return 'url("' + xb(e) + '")' } const mc = { ...pf, inline: !1 }, Pb = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", "aria-hidden": !0, role: "img" }, Sb = { display: "inline-block" }, Qr = { backgroundColor: "currentColor" }, wf = { backgroundColor: "transparent" }, yc = { Image: "var(--svg)", Repeat: "no-repeat", Size: "100% 100%" }, _c = { webkitMask: Qr, mask: Qr, background: wf }; for (const e in _c) { const t = _c[e]; for (const n in yc) t[e + n] = yc[n] } const Ys = {};["horizontal", "vertical"].forEach(e => { const t = e.slice(0, 1) + "Flip"; Ys[e + "-flip"] = t, Ys[e.slice(0, 1) + "-flip"] = t, Ys[e + "Flip"] = t }); function bc(e) { return e + (e.match(/^[-0-9.]+$/) ? "px" : "") } const vc = (e, t) => { const n = _b(mc, t), s = { ...Pb }, o = t.mode || "svg", r = {}, i = t.style, a = typeof i == "object" && !(i instanceof Array) ? i : {}; for (let g in t) { const E = t[g]; if (E !== void 0) switch (g) { case "icon": case "style": case "onLoad": case "mode": case "ssr": break; case "inline": case "hFlip": case "vFlip": n[g] = E === !0 || E === "true" || E === 1; break; case "flip": typeof E == "string" && vb(n, E); break; case "color": r.color = E; break; case "rotate": typeof E == "string" ? n[g] = wb(E) : typeof E == "number" && (n[g] = E); break; case "ariaHidden": case "aria-hidden": E !== !0 && E !== "true" && delete s["aria-hidden"]; break; default: { const k = Ys[g]; k ? (E === !0 || E === "true" || E === 1) && (n[k] = !0) : mc[g] === void 0 && (s[g] = E) } } } const c = K_(e, n), u = c.attributes; if (n.inline && (r.verticalAlign = "-0.125em"), o === "svg") { s.style = { ...r, ...a }, Object.assign(s, u); let g = 0, E = t.id; return typeof E == "string" && (E = E.replace(/-/g, "_")), s.innerHTML = Y_(c.body, E ? () => E + "ID" + g++ : "iconifyVue"), Ke("svg", s) } const { body: l, width: f, height: h } = e, p = o === "mask" || (o === "bg" ? !1 : l.indexOf("currentColor") !== -1), _ = Eb(l, { ...u, width: f + "", height: h + "" }); return s.style = { ...r, "--svg": Tb(_), width: bc(u.width), height: bc(u.height), ...Sb, ...p ? Qr : wf, ...a }, Ke("span", s) }; hf(!0); gf("", rb); if (typeof document < "u" && typeof window < "u") { const e = window; if (e.IconifyPreload !== void 0) { const t = e.IconifyPreload, n = "Invalid IconifyPreload syntax."; typeof t == "object" && t !== null && (t instanceof Array ? t : [t]).forEach(s => { try { (typeof s != "object" || s === null || s instanceof Array || typeof s.icons != "object" || typeof s.prefix != "string" || !F_(s)) && console.error(n) } catch { console.error(n) } }) } if (e.IconifyProviders !== void 0) { const t = e.IconifyProviders; if (typeof t == "object" && t !== null) for (let n in t) { const s = "IconifyProviders[" + n + "] is invalid."; try { const o = t[n]; if (typeof o != "object" || !o || o.resources === void 0) continue; mf(n, o) || console.error(s) } catch { console.error(s) } } } } const Cb = { ...Fn, body: "" }, kw = vt((e, { emit: t }) => { const n = $e(null); function s() { var u, l; n.value && ((l = (u = n.value).abort) == null || l.call(u), n.value = null) } const o = $e(!!e.ssr), r = $e(""), i = an(null); function a() { const u = e.icon; if (typeof u == "object" && u !== null && typeof u.body == "string") return r.value = "", { data: u }; let l; if (typeof u != "string" || (l = Ts(u, !1, !0)) === null) return null; let f = Oi(l); if (!f) { const _ = n.value; return (!_ || _.name !== u) && (f === null ? n.value = { name: u } : n.value = { name: u, abort: vf([l], c) }), null } s(), r.value !== u && (r.value = u, qt(() => { t("load", u) })); const h = e.customise; if (h) { f = Object.assign({}, f); const _ = h(f.body, l.name, l.prefix, l.provider); typeof _ == "string" && (f.body = _) } const p = ["iconify"]; return l.prefix !== "" && p.push("iconify--" + l.prefix), l.provider !== "" && p.push("iconify--" + l.provider), { data: f, classes: p } } function c() { var l; const u = a(); u ? u.data !== ((l = i.value) == null ? void 0 : l.data) && (i.value = u) : i.value = null } return o.value ? c() : hn(() => { o.value = !0, c() }), bt(() => e.icon, c), ws(s), () => { const u = i.value; if (!u) return vc(Cb, e); let l = e; return u.classes && (l = { ...e, class: u.classes.join(" ") }), vc({ ...Fn, ...u.data }, l) } }, { props: ["icon", "mode", "ssr", "width", "height", "style", "color", "inline", "rotate", "hFlip", "horizontalFlip", "vFlip", "verticalFlip", "flip", "id", "ariaHidden", "customise", "title"], emits: ["load"] }), wc = { getAPIConfig: Wo, setAPIModule: gf, sendAPIQuery: bf, setFetch: X_, getFetch: Z_, listAPIProviders: Q_ }, Rb = qe({ name: "@nuxt/icon", setup() { var o, r; const e = pn(), t = rf().icon; wc.setFetch($fetch.native); const n = []; if (t.provider === "server") { const i = ((r = (o = e.app) == null ? void 0 : o.baseURL) == null ? void 0 : r.replace(/\/$/, "")) ?? ""; n.push(i + (t.localApiEndpoint || "/api/_nuxt_icon")), (t.fallbackToApi === !0 || t.fallbackToApi === "client-only") && n.push(t.iconifyApiEndpoint) } else t.provider === "none" ? wc.setFetch(() => Promise.resolve(new Response)) : n.push(t.iconifyApiEndpoint); async function s(i, a) { try { const c = await $fetch(n[0] + "/" + a + ".json", { query: { icons: i.join(",") } }); if (!c || c.prefix !== a || !c.icons) throw new Error("Invalid data" + JSON.stringify(c)); return c } catch (c) { return console.error("Failed to load custom icons", c), null } } mf("", { resources: n }); for (const i of t.customCollections || []) i && yb(s, i) } }); function Ab(e, t) { const n = { ...t }; function s(c) { Object.assign(n, c) } function o() { e.trackPageview(n) } const r = history.pushState; function i() { r && (history.pushState = function (...c) { r.apply(this, c), o() }, window.addEventListener("popstate", o)), e.options.hashMode && window.addEventListener("hashchange", o), o() } function a() { r && (history.pushState = r, window.removeEventListener("popstate", o)), e.options.hashMode && window.removeEventListener("hashchange", o) } return { install: i, cleanup: a, setEventOptions: s } } const Ib = qe({ setup() { const e = pn().public.plausible, { $plausible: t } = we(); e.enabled && e.autoPageviews && Ab(t).install() } }), Ob = [Nm, jm, ry, iy, ay, cy, uy, a_, u_, k_, S_, A_, Rb, Ib], Mb = vt({ __name: "MouseLight", setup(e) { const t = $e(), n = $e(!1), s = ht({ x: 0, y: 0 }), o = i => { s.x = i.clientX, s.y = i.clientY, n.value = !0, t.value && (t.value.style.setProperty("--mouse-x", `${i.clientX}px`), t.value.style.setProperty("--mouse-y", `${i.clientY}px`)) }, r = () => { n.value = !1 }; return hn(() => { document.addEventListener("mousemove", o), document.addEventListener("mouseleave", r) }), ws(() => { document.removeEventListener("mousemove", o), document.removeEventListener("mouseleave", r) }), (i, a) => (Fe(), ks("div", { ref_key: "lightElement", ref: t, class: ys(["hidden sm:block mouse-light pointer-events-none fixed inset-0 z-10 transition-opacity duration-300", { "opacity-0": !be(n) }]) }, null, 2)) } }), Ef = (e, t) => { const n = e.__vccOpts || e; for (const [s, o] of t) n[s] = o; return n }, Lb = Object.assign(Ef(Mb, [["__scopeId", "data-v-1afb87d9"]]), { __name: "MouseLight" }), Nb = ki("/nuxt-x-vercel.svg"); let Jr = null; {
    const e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (Z) { setTimeout(Z, 10) }; let t, n, s, o, r, i, a, c, u, l, f, h, p, _, g, E, k, w, d, y, x, T, S, F, O, I, q, A, W, ne = 0, ie = 0; Jr = class {
        constructor(v) { let L = {}; v && (v.nodeName ? (L = JSON.parse(JSON.stringify(v.dataset)), v.nodeName === "IMG" ? L.image = v : L.wrapperElement = v) : L = v), this.state = "stopped", this.touches = [], this.on("imageLoaded", this._onImageLoaded), this._initImage(L) } on(v, L) { this.events = this.events || {}, this.events[v] = this.events[v] || [], this.events[v].push(L) } emit(v, L) { const se = this.events[v]; if (se && se.length) for (let Ee = 0; Ee < se.length; Ee++)se[Ee].call(this, L) } get renderer() { return this._renderer } set renderer(v) { this._renderer = v, this._draw = this["_" + v + "Renderer"]; try { this["_" + v + "InitContext"]() } catch (L) { console.log(L), v !== "default" && (this.renderer = "default") } } set color(v) { this.colorArr = this._parseColor(v), this.colorArr && (isNaN(this.colorArr[3]) && (this.colorArr[3] = 255), 0 < this.colorArr[3] && this.colorArr[3] <= 1 && (this.colorArr[3] *= 255)) } start(v) { const L = v || {}; this.initPosition = L.initPosition || this.initPosition, this.initDirection = L.initDirection || this.initDirection, this.canvas && (this.canvas.width = this.width, this.canvas.height = this.height, this.canvas.style.display = ""), this._initOrigins(), this._initParticles(), this._webglSetAttributes(), this.state !== "running" && (this.state = "running", this.disableInteraction || ("ontouchstart" in window || window.navigator.msPointerEnabled ? (document.body.addEventListener("touchstart", this._touchHandler), document.body.addEventListener("touchmove", this._touchHandler), document.body.addEventListener("touchend", this._clearTouches), document.body.addEventListener("touchcancel", this._clearTouches)) : (this.canvas.addEventListener("mousemove", this._mouseHandler), this.canvas.addEventListener("mouseout", this._clearTouches), this.canvas.addEventListener("click", this._clickHandler))), this._animate()) } stop(v) { const L = v || {}; this.fadePosition = L.fadePosition || this.fadePosition, this.fadeDirection = L.fadeDirection || this.fadeDirection, this._fade(), document.body.removeEventListener("touchstart", this._touchHandler), document.body.removeEventListener("touchmove", this._touchHandler), document.body.removeEventListener("touchend", this._clearTouches), document.body.removeEventListener("touchcancel", this._clearTouches), this.canvas && (this.canvas.removeEventListener("mousemove", this._mouseHandler), this.canvas.removeEventListener("mouseout", this._clearTouches), this.canvas.removeEventListener("click", this._clickHandler)) } _animate() { this.state !== "stopped" ? (this._calculate(), this._draw(), e(() => this._animate())) : this.emit("stopped") } get _mouseHandler() { return v => { this.touches = [{ x: v.offsetX, y: v.offsetY, z: 49 + (this.layerCount - 1) * this.layerDistance, force: 1 }] } } get _clickHandler() { return v => { const L = this.clickStrength; this.origins.map(se => se.z -= L), setTimeout(() => { this.origins.map(se => se.z += L) }, 100) } } get _touchHandler() { return v => { for (this.touches = [], l = this.canvas.getBoundingClientRect(), u = 0; u < v.changedTouches.length; u++)c = v.changedTouches[u], c.target === this.canvas && (this.touches.push({ x: c.pageX - l.left, y: c.pageY - l.top, z: 49 + (this.layerCount - 1) * this.layerDistance, force: c.force || 1 }), v.preventDefault()) } } get _clearTouches() { return v => { this.touches = [] } } _onImageLoaded(v) { this.imageWidth = this.image.naturalWidth || this.image.width, this.imageHeight = this.image.naturalHeight || this.image.height, this.imageRatio = this.imageWidth / this.imageHeight, this.width = this.width || this.imageWidth, this.height = this.height || this.imageHeight, this.renderSize = (this.width + this.height) / 4, this.srcImage && (this.srcImage.style.display = "none"), this._initSettings(v), this._initContext(v), this._initResponsive(v), this.start() } _initImage(v) { this.srcImage = v.image, !this.srcImage && v.imageId && (this.srcImage = document.getElementById(v.imageId)), this.imageUrl = v.imageUrl || this.srcImage.src, this.image = document.createElement("img"), this.wrapperElement = v.wrapperElement || this.srcImage.parentElement, this.image.onload = () => this.emit("imageLoaded", v), this.image.crossOrigin = "Anonymous", v.addTimestamp && (/\?/.test(this.imageUrl) ? this.imageUrl += "&d=" + Date.now() : this.imageUrl += "?d=" + Date.now()), this.image.src = this.imageUrl } _initContext(v) { this.canvas = v.canvas, !this.canvas && !this.context && this.wrapperElement && (this.canvas = document.createElement("canvas"), this.wrapperElement.appendChild(this.canvas)), this.convas && (this.convas.style.display = "none"), this.context = v.context, this.renderer = v.renderer || "default" } _defaultInitContext(v) { this.context = this.context || this.canvas.getContext("2d") } _webglInitContext() {
            this.context = this.context || this.canvas.getContext("webgl2") || this.canvas.getContext("experimental-webgl"), this.fragmentShaderScript = `#version 300 es

        precision highp float;

        in vec4 vColor;
        out vec4 fragColor;

        void main(void) {
          // fragColor = vec4(1, 1, 1, 0.1);
          fragColor = vColor;
        }
      `, this.vertexShaderScript = `#version 300 es

        precision highp float;

        in vec3 vertexPosition;
        in vec4 vertexColor;
        uniform vec3 vertexOffset;
        uniform float pointSize;
        uniform float depth;
        vec3 mirror = vec3(1, -1, 1);

        uniform mat4 modelViewMatrix;
        uniform mat4 perspectiveMatrix;
        uniform mat4 rotationMatrix;

        out vec4 vColor;

        void main(void) {
          gl_Position = rotationMatrix * perspectiveMatrix * modelViewMatrix * vec4(mirror * vertexPosition + vertexOffset, vertexPosition);
          gl_PointSize = pointSize + max((log(vertexPosition.z) - 3.91) * depth, -pointSize + 1.0);
          vColor = vertexColor;
        }
      `, this.context.viewport(0, 0, this.width, this.height); const v = this.context.createShader(this.context.VERTEX_SHADER); this.context.shaderSource(v, this.vertexShaderScript), this.context.compileShader(v), this.context.getShaderParameter(v, this.context.COMPILE_STATUS) || console.log(this.context.getShaderInfoLog(v)); const L = this.context.createShader(this.context.FRAGMENT_SHADER); this.context.shaderSource(L, this.fragmentShaderScript), this.context.compileShader(L), this.context.getShaderParameter(L, this.context.COMPILE_STATUS) || console.log(this.context.getShaderInfoLog(L)), this.program = this.context.createProgram(), this.context.attachShader(this.program, v), this.context.attachShader(this.program, L), this.context.linkProgram(this.program), this.context.useProgram(this.program), this.vertexPosition = this.context.getAttribLocation(this.program, "vertexPosition"), this.context.enableVertexAttribArray(this.vertexPosition), this.vertexColor = this.context.getAttribLocation(this.program, "vertexColor"), this.context.enableVertexAttribArray(this.vertexColor), this.context.clearColor(0, 0, 0, 0), this.context.enable(this.context.BLEND), this.context.disable(this.context.DEPTH_TEST), this.context.blendFunc(this.context.SRC_ALPHA, this.context.ONE), this.vertexBuffer = this.context.createBuffer(), this.context.bindBuffer(this.context.ARRAY_BUFFER, this.vertexBuffer), this.context.clear(this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT), this.vertexOffset = this.context.getUniformLocation(this.program, "vertexOffset"), this.context.uniform3f(this.vertexOffset, 0, 0, 1e3), this.context.vertexAttribPointer(this.vertexPosition, 3, this.context.FLOAT, !1, 28, 0), this.context.vertexAttribPointer(this.vertexColor, 4, this.context.FLOAT, !1, 28, 12), this.uModelViewMatrix = this.context.getUniformLocation(this.program, "modelViewMatrix"), this.uPerspectiveMatrix = this.context.getUniformLocation(this.program, "perspectiveMatrix"), this.uRotationMatrix = this.context.getUniformLocation(this.program, "rotationMatrix"), this.uPointSize = this.context.getUniformLocation(this.program, "pointSize"), this.uDepth = this.context.getUniformLocation(this.program, "depth"), this._webglSetAttributes()
        } _webglSetAttributes() { if (this.renderer === "webgl") { var v = 1, L = this.canvas.width / this.canvas.height, se = 10, Ee = 100, ve = se * Math.tan(v * Math.PI / 360), dt = -ve, ot = ve * L, Ht = -ot, je = (ot + Ht) / (ot - Ht), R = (ve + dt) / (ve - dt), B = (Ee + se) / (Ee - se), j = 2 * Ee * se / (Ee - se), G = 2 * se / (ot - Ht), ce = 2 * se / (ve - dt), ge = [G, 0, je, 0, 0, ce, R, 0, 0, 0, B, j, 0, 0, -1, 0], m = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; this.context.viewport(0, 0, this.width, this.height), this.context.uniformMatrix4fv(this.uModelViewMatrix, !1, new Float32Array(ge)), this.context.uniformMatrix4fv(this.uPerspectiveMatrix, !1, new Float32Array(m)), this.context.uniform1f(this.uPointSize, this.particleSize), this.context.uniform1f(this.uDepth, this.depth), this._updateRotation() } } _updateRotation() { const v = Math.cos(ne), L = Math.sin(ne), se = Math.cos(ie), Ee = Math.sin(ie); var ve = [se, 0, Ee, 0, 0, v, -L, 0, -se, L, v, 0, 0, 0, 0, 1]; this.context.uniformMatrix4fv(this.uRotationMatrix, !1, new Float32Array(ve)) } _webglRenderer() { x = new Float32Array(this.vertices), this.context.bufferData(this.context.ARRAY_BUFFER, x, this.context.STATIC_DRAW), this.context.clear(this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT), this.context.drawArrays(this.context.POINTS, 0, this.particles.length), this.context.flush() } _initSettings(v) { this.width = v.width * 1 || this.width, this.height = v.height * 1 || this.height, this.maxWidth = v.maxWidth, this.maxHeight = v.maxHeight, this.minWidth = v.minWidth, this.minHeight = v.minHeight, this.maxWidth && (/%$/.test(this.maxWidth) ? this.maxWidth = this.width * this.maxWidth.replace("%", "") / 100 : this.maxWidth *= 1), this.maxHeight && (/%$/.test(this.maxHeight) ? this.maxHeight = this.height * this.maxHeight.replace("%", "") / 100 : this.maxHeight *= 1), this.minWidth && (/%$/.test(this.minWidth) ? this.minWidth = this.width * this.minWidth.replace("%", "") / 100 : this.minWidth *= 1), this.minHeight && (/%$/.test(this.minHeight) ? this.minHeight = this.height * this.minHeight.replace("%", "") / 100 : this.minHeight *= 1), this.alphaFade = .4, this.gravity = v.gravity * 1 || .08, this.particleGap = v.particleGap * 1 || 3, this.particleSize = v.particleSize * 1 || 1, this.layerCount = v.layerCount * 1 || 1, this.depth = v.depth * 1 || 1, this.rotationDuration = v.rotationDuration * 1 || 0, this.growDuration = v.growDuration * 1 || 200, this.waitDuration = v.waitDuration * 1 || 200, this.shrinkDuration = v.shrinkDuration * 1 || 200, this.shrinkDistance = v.shrinkDistance * 1 || 50, this.threeDimensional = v.threeDimensional !== void 0 && v.threeDimensional !== "false" ? !!v.threeDimensional : !1, this.lifeCycle = v.lifeCycle !== void 0 && v.lifeCycle !== "false" ? !!v.lifeCycle : !1, this.layerDistance = v.layerDistance || this.particleGap, this.initPosition = v.initPosition || "random", this.initDirection = v.initDirection || "random", this.fadePosition = v.fadePosition || "none", this.fadeDirection = v.fadeDirection || "none", this.noise = isNaN(v.noise * 1) ? 10 : v.noise * 1, this.disableInteraction = v.disableInteraction, this.mouseForce = v.mouseForce * 1 || 30, this.clickStrength = v.clickStrength * 1 || 0, this.color = v.color, this.colorArr = v.colorArr || this.colorArr } _initResponsive(v) { this.responsiveWidth = this.wrapperElement && v.responsiveWidth, this.responsiveWidth && (this.on("stopped", () => { this.width = this.wrapperElement.clientWidth, this.start() }), this.wrapperElement.addEventListener("resize", () => { this.width !== this.wrapperElement.clientWidth && this.stop() }), this.width = this.wrapperElement.clientWidth) } _calculate() { for (this.vertices = this.renderer === "webgl" ? [] : !1, n = 0, s = 0; s < this.particles.length; s++) { for (i = this.origins[s], a = this.particles[s], _ = i.x - a.x + (Math.random() - .5) * this.noise, g = i.y - a.y + (Math.random() - .5) * this.noise, E = i.z - a.z + (Math.random() - .5) * this.noise / 1e3, k = Math.sqrt(_ * _ + g * g + E * E), w = k * .01, a.vx += w * (_ / k) * this.speed, a.vy += w * (g / k) * this.speed, a.vz += w * (E / k) * this.speed, u = 0; u < this.touches.length; u++)c = this.touches[u], _ = a.x - c.x, g = a.y - c.y, E = a.z - c.z, k = Math.sqrt(_ * _ + g * g + E * E), w = this.mouseForce * c.force / k, a.vx += w * (_ / k) * this.speed, a.vy += w * (g / k) * this.speed, a.vz += w * (E / k) * this.speed; a.vx *= this.gravityFactor, a.vy *= this.gravityFactor, a.vz *= this.gravityFactor, a.x += a.vx, a.y += a.vy, a.z += a.vz, 0 > a.x || a.x >= this.width || 0 > a.y || a.y >= this.height ? (a.isHidden = !0, this.state === "stopping" && (a.isDead = !0)) : (this.state === "stopping" && !a.isDead && n++, a.isHidden = !1), this.vertices && (f = a.x - this.width / 2, h = a.y - this.height / 2, p = a.z, A = i.vertexColors[3], this.lifeCycle && (i.tick += 1, i.tick >= 0 ? i.tick < this.growDuration ? A = A * (i.tick / this.growDuration) : (W = i.tick - this.growDuration - this.waitDuration, W >= 0 && W <= this.shrinkDuration && (c = this.touches[u], k = Math.sqrt(f * f + h * h + (p - 50) * (p - 50)), w = W / this.shrinkDuration, f += this.shrinkDistance * (f / k) * w, h += this.shrinkDistance * (h / k) * w, p += this.shrinkDistance * ((p - 50) / k) * w, A *= 1 - w, W === this.shrinkDuration && (i.tick = 0))) : A = 0), this.vertices.push(f, h, p, i.vertexColors[0], i.vertexColors[1], i.vertexColors[2], A)) } this.state === "stopping" && n === 0 && (this.state = "stopped") } _defaultRenderer() { for (this.depth = Math.max(this.layerDistance * this.layerCount / 2, this.mouseForce), this.minZ = -this.depth, this.maxZ = this.depth, t = this.context.createImageData(this.width, this.height), s = 0; s < this.origins.length; s++)i = this.origins[s], a = this.particles[s], !a.isDead && !a.isHidden && (f = ~~a.x, h = ~~a.y, A = i.color[3], this.alphaFade > 0 && this.layerCount > 1 && (p = Math.max(Math.min(a.z, this.maxZ), this.minZ) - this.minZ, A = A * (1 - this.alphaFade) + A * this.alphaFade * (p / (this.maxZ - this.minZ)), A = Math.max(Math.min(~~A, 255), 0)), o = (f + h * this.width) * 4, t.data[o + 0] = i.color[0], t.data[o + 1] = i.color[1], t.data[o + 2] = i.color[2], t.data[o + 3] = A); this.context.putImageData(t, 0, 0) } _initParticles() { for (this.particles = void 0, this.particles = [], s = 0; s < this.origins.length; s++)i = this.origins[s], a = {}, this._initParticlePosition(i, a), this._initParticleDirection(a), this.particles.push(a) } _initParticlePosition(v, L) { switch (L.z = 0, this.initPosition) { case "random": { L.x = Math.random() * this.width, L.y = Math.random() * this.height; break } case "top": { L.x = Math.random() * this.width * 3 - this.width, L.y = -Math.random() * this.height; break } case "left": { L.x = -Math.random() * this.width, L.y = Math.random() * this.height * 3 - this.height; break } case "bottom": { L.x = Math.random() * this.width * 3 - this.width, L.y = this.height + Math.random() * this.height; break } case "right": { L.x = this.width + Math.random() * this.width, L.y = Math.random() * this.height * 3 - this.height; break } case "misplaced": { L.x = v.x + Math.random() * this.width * .3 - this.width * .1, L.y = v.y + Math.random() * this.height * .3 - this.height * .1; break } default: L.x = v.x, L.y = v.y } } _fade() { if (this.fadePosition === "explode" || this.fadePosition === "top" || this.fadePosition === "left" || this.fadePosition === "bottom" || this.fadePosition === "right" ? this.state = "stopping" : this.state = "stopped", this.origins) for (s = 0; s < this.origins.length; s++)this._fadeOriginPosition(this.origins[s]), this._fadeOriginDirection(this.particles[s]) } _fadeOriginPosition(v) { switch (this.fadePosition) { case "random": { v.x = Math.random() * this.width * 2 - this.width, v.y = Math.random() * this.height * 2 - this.height, v.x > 0 && (v.x += this.width), v.y > 0 && (v.y += this.height); break } case "top": { v.x = Math.random() * this.width * 3 - this.width, v.y = -Math.random() * this.height; break } case "left": { v.x = -Math.random() * this.width, v.y = Math.random() * this.height * 3 - this.height; break } case "bottom": { v.x = Math.random() * this.width * 3 - this.width, v.y = this.height + Math.random() * this.height; break } case "right": { v.x = this.width + Math.random() * this.width, v.y = Math.random() * this.height * 3 - this.height; break } } } _initParticleDirection(v) { switch (v.vz = 0, this.initDirection) { case "random": { d = Math.random() * Math.PI * 2, y = Math.random(), v.vx = this.width * y * Math.sin(d) * .1, v.vy = this.height * y * Math.cos(d) * .1; break } case "top": { d = Math.random() * Math.PI - Math.PI / 2, y = Math.random(), v.vx = this.width * y * Math.sin(d) * .1, v.vy = this.height * y * Math.cos(d) * .1; break } case "left": { d = Math.random() * Math.PI + Math.PI, y = Math.random(), v.vx = this.width * y * Math.sin(d) * .1, v.vy = this.height * y * Math.cos(d) * .1; break } case "bottom": { d = Math.random() * Math.PI + Math.PI / 2, y = Math.random(), v.vx = this.width * y * Math.sin(d) * .1, v.vy = this.height * y * Math.cos(d) * .1; break } case "right": { d = Math.random() * Math.PI, y = Math.random(), v.vx = this.width * y * Math.sin(d) * .1, v.vy = this.height * y * Math.cos(d) * .1; break } default: v.vx = 0, v.vy = 0 } } _fadeOriginDirection(v) { switch (this.fadeDirection) { case "random": { d = Math.random() * Math.PI * 2, y = Math.random(), v.vx += this.width * y * Math.sin(d) * .1, v.vy += this.height * y * Math.cos(d) * .1; break } case "top": { d = Math.random() * Math.PI - Math.PI / 2, y = Math.random(), v.vx += this.width * y * Math.sin(d) * .1, v.vy += this.height * y * Math.cos(d) * .1; break } case "left": { d = Math.random() * Math.PI + Math.PI, y = Math.random(), v.vx += this.width * y * Math.sin(d) * .1, v.vy += this.height * y * Math.cos(d) * .1; break } case "bottom": { d = Math.random() * Math.PI + Math.PI / 2, y = Math.random(), v.vx += this.width * y * Math.sin(d) * .1, v.vy += this.height * y * Math.cos(d) * .1; break } case "right": { d = Math.random() * Math.PI, y = Math.random(), v.vx += this.width * y * Math.sin(d) * .1, v.vy += this.height * y * Math.cos(d) * .1; break } default: v.vx = 0, v.vy = 0 } } _initOrigins() { T = document.createElement("canvas"), this.responsiveWidth && (this.width = this.wrapperElement.clientWidth), this.ratio = Math.min(this.width, this.maxWidth || Number.POSITIVE_INFINITY) / Math.min(this.height, this.maxHeight || Number.POSITIVE_INFINITY), this.ratio < this.imageRatio ? (this.renderWidth = ~~Math.min(this.width || Number.POSITIVE_INFINITY, this.minWidth || this.imageWidth || Number.POSITIVE_INFINITY, this.maxWidth || Number.POSITIVE_INFINITY), this.renderHeight = ~~(this.renderWidth / this.imageRatio)) : (this.renderHeight = ~~Math.min(this.height || Number.POSITIVE_INFINITY, this.minHeight || this.imageHeight || Number.POSITIVE_INFINITY, this.maxHeight || Number.POSITIVE_INFINITY), this.renderWidth = ~~(this.renderHeight * this.imageRatio)), this.offsetX = ~~((this.width - this.renderWidth) / 2), this.offsetY = ~~((this.height - this.renderHeight) / 2), T.width = this.renderWidth, T.height = this.renderHeight, S = T.getContext("2d"), S.drawImage(this.image, 0, 0, this.renderWidth, this.renderHeight), F = S.getImageData(0, 0, this.renderWidth, this.renderHeight).data, this.origins = void 0, this.origins = []; const v = this.growDuration + this.waitDuration + this.shrinkDuration; for (f = 0; f < this.renderWidth; f += this.particleGap)for (h = 0; h < this.renderHeight; h += this.particleGap)if (s = (f + h * this.renderWidth) * 4, A = F[s + 3], A > 0) { const L = Math.random(); if (W = -Math.floor(L * v), this.colorArr) for (r = 0; r < this.layerCount; r++)this.origins.push({ x: this.offsetX + f, y: this.offsetY + h, z: r * this.layerDistance + 50, color: this.colorArr, tick: W, seed: L, vertexColors: this.colorArr.map(se => se / 255) }); else for (O = F[s], I = F[s + 1], q = F[s + 2], r = 0; r < this.layerCount; r++)this.origins.push({ x: this.offsetX + f, y: this.offsetY + h, z: r * this.layerDistance + 50, color: [O, I, q, A], tick: W, seed: L, vertexColors: [O / 255, I / 255, q / 255, A / 255] }) } this.speed = Math.log(this.origins.length) / 10, this.gravityFactor = 1 - this.gravity * this.speed } _parseColor(v) { let L; if (typeof v != "string") return; const se = v.replace(" ", ""); if (L = /^#([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})/.exec(se)) L = [parseInt(L[1], 16), parseInt(L[2], 16), parseInt(L[3], 16)]; else if (L = /^#([\da-fA-F])([\da-fA-F])([\da-fA-F])/.exec(se)) L = [parseInt(L[1], 16) * 17, parseInt(L[2], 16) * 17, parseInt(L[3], 16) * 17]; else if (L = /^rgba\(([\d]+),([\d]+),([\d]+),([\d]+|[\d]*.[\d]+)\)/.exec(se)) L = [+L[1], +L[2], +L[3], +L[4]]; else if (L = /^rgb\(([\d]+),([\d]+),([\d]+)\)/.exec(se)) L = [+L[1], +L[2], +L[3]]; else return; return L }
    }; const K = document.getElementsByClassName("next-particle"); for (let Z = 0; Z < K.length; Z++) { const v = K[Z]; v.nextParticle = new Jr(v) }
} const Hb = vt({ __name: "Particles", setup(e) { const t = $e(); return hn(() => { new Jr({ image: t.value, width: 350, height: 150, maxWidth: 250, gravity: .11, mouseForce: 20, noise: 3, particleGap: 1 }) }), (n, s) => (Fe(), ks("img", { ref_key: "logo", ref: t, src: Nb, width: "256", height: "222", class: "hidden", alt: "Nuxt x Vercel Logo" }, null, 512)) } }), Db = Object.assign(Hb, { __name: "Particles" }), kf = (e = "RouteProvider") => vt({ name: e, props: { route: { type: Object, required: !0 }, vnode: Object, vnodeRef: Object, renderKey: String, trackRootNodes: Boolean }, setup(t) { const n = t.renderKey, s = t.route, o = {}; for (const r in t.route) Object.defineProperty(o, r, { get: () => n === t.renderKey ? t.route[r] : s[r], enumerable: !0 }); return Sn($o, Rt(o)), () => t.vnode ? Ke(t.vnode, { ref: t.vnodeRef }) : t.vnode } }), Fb = kf(), Ec = new WeakMap, $b = vt({ name: "NuxtPage", inheritAttrs: !1, props: { name: { type: String }, transition: { type: [Boolean, Object], default: void 0 }, keepalive: { type: [Boolean, Object], default: void 0 }, route: { type: Object }, pageKey: { type: [Function, String], default: null } }, setup(e, { attrs: t, slots: n, expose: s }) { const o = we(), r = $e(), i = ze($o, null); let a; s({ pageRef: r }); const c = ze(Bg, null); let u; const l = o.deferHydration(); if (o.isHydrating) { const h = o.hooks.hookOnce("app:error", l); Qe().beforeEach(h) } e.pageKey && bt(() => e.pageKey, (h, p) => { h !== p && o.callHook("page:loading:start") }); let f = !1; { const h = Qe().beforeResolve(() => { f = !1 }); vs(() => { h() }) } return () => Ke(sf, { name: e.name, route: e.route, ...t }, { default: h => { const p = Ub(i, h.route, h.Component), _ = i && i.matched.length === h.route.matched.length; if (!h.Component) { if (u && !_) return u; l(); return } if (u && c && !c.isCurrent(h.route)) return u; if (p && i && (!c || c != null && c.isCurrent(i))) return _ ? u : null; const g = zr(h, e.pageKey), E = Vb(i, h.route, h.Component); !o.isHydrating && a === g && !E && qt(() => { f = !0, o.callHook("page:loading:end") }), a = g; const k = !!(e.transition ?? h.route.meta.pageTransition ?? Ca), w = k && jb([e.transition, h.route.meta.pageTransition, Ca, { onBeforeLeave() { o._runningTransition = !0 }, onAfterLeave() { delete o._runningTransition, o.callHook("page:transition:finish", h.Component) } }]), d = e.keepalive ?? h.route.meta.keepalive ?? Pg; return u = G0(k && w, q0(d, Ke(Ll, { suspensible: !0, onPending: () => o.callHook("page:start", h.Component), onResolve: () => { qt(() => o.callHook("page:finish", h.Component).then(() => { if (!f && !E) return f = !0, o.callHook("page:loading:end") }).finally(l)) } }, { default: () => { const y = { key: g || void 0, vnode: n.default ? Bb(n.default, h) : h.Component, route: h.route, renderKey: g || void 0, trackRootNodes: k, vnodeRef: r }; if (!d) return Ke(Fb, y); const x = h.Component.type, T = x; let S = Ec.get(T); return S || (S = kf(x.name || x.__name), Ec.set(T, S)), Ke(S, y) } }))).default(), u } }) } }); function jb(e) { const t = e.filter(Boolean).map(n => ({ ...n, onAfterLeave: n.onAfterLeave ? Ai(n.onAfterLeave) : void 0 })); return Pu(...t) } function Ub(e, t, n) { if (!e) return !1; const s = t.matched.findIndex(o => { var r; return ((r = o.components) == null ? void 0 : r.default) === (n == null ? void 0 : n.type) }); return !s || s === -1 ? !1 : t.matched.slice(0, s).some((o, r) => { var i, a, c; return ((i = o.components) == null ? void 0 : i.default) !== ((c = (a = e.matched[r]) == null ? void 0 : a.components) == null ? void 0 : c.default) }) || n && zr({ route: t, Component: n }) !== zr({ route: e, Component: n }) } function Vb(e, t, n) { return e ? t.matched.findIndex(o => { var r; return ((r = o.components) == null ? void 0 : r.default) === (n == null ? void 0 : n.type) }) < t.matched.length - 1 : !1 } function Bb(e, t) { const n = e(t); return n.length === 1 ? Ke(n[0]) : Ke(Ce, void 0, n) } const Wb = {}, Kb = { class: "stars w-screen absolute pointer-events-none inset-x-0 -top-8 h-screen opacity-75" }; function zb(e, t) { return Fe(), ks("div", Kb, t[0] || (t[0] = [it("div", { class: "h-px w-px rounded-full bg-transparent" }, null, -1), it("div", { class: "h-px w-px rounded-full bg-transparent" }, null, -1), it("div", { class: "h-px w-px rounded-full bg-transparent" }, null, -1)])) } const qb = Object.assign(Ef(Wb, [["render", zb], ["__scopeId", "data-v-e32bae92"]]), { __name: "Stars" }), Gb = { class: "dark min-h-screen overflow-hidden relative" }, Yb = { class: "grid grid-cols-1 lg:grid-cols-[1fr_3fr_1fr] gap-0" }, Qb = { class: "flex flex-col items-center justify-center px-6 py-12 lg:px-8" }, Jb = { class: "flex items-center justify-center gap-x-4 min-h-[150px] sm:mb-8 sm:translate-y-8" }, Xb = { class: "w-full max-w-3xl" }, Zb = { class: "absolute inset-0 opacity-60 pointer-events-none" }, ev = vt({ __name: "app", setup(e) { return ju({ meta: [{ name: "viewport", content: "width=device-width, initial-scale=1" }], link: [{ rel: "icon", type: "image/png", href: "/nuxt.png" }], htmlAttrs: { lang: "en" } }), Pm({ ogSiteName: "NuxtLabs", ogType: "website", twitterCard: "summary_large_image", ogImage: "https://nuxtlabs.com/social.png", twitterSite: "nuxtlabs" }), (t, n) => { const s = Lb, o = Db, r = $b, i = qb; return Fe(), ks("div", Gb, [it("div", Yb, [he(s), n[0] || (n[0] = Pd('<div class="absolute -top-40 -left-40 size-100 pointer-events-none opacity-30"><div class="size-full bg-radial from-white/20 via-white/10 to-transparent blur-3xl mix-blend-soft-light"></div></div><div class="absolute -bottom-40 -right-40 size-100 pointer-events-none opacity-30"><div class="size-full bg-radial from-white/15 via-white/8 to-transparent blur-3xl mix-blend-soft-light"></div></div><div class="hidden lg:block"></div>', 3)), it("div", Qb, [it("div", Jb, [he(o)]), it("div", Xb, [he(r)])]), n[1] || (n[1] = it("div", { class: "hidden lg:block" }, null, -1))]), it("div", Zb, [he(i)])]) } } }), tv = {
    __name: "nuxt-error-page", props: { error: Object }, setup(e) {
        const n = e.error; n.stack && n.stack.split(`
`).splice(1).map(f => ({ text: f.replace("webpack:/", "").replace(".vue", ".js").trim(), internal: f.includes("node_modules") && !f.includes(".cache") || f.includes("internal") || f.includes("new Promise") })).map(f => `<span class="stack${f.internal ? " internal" : ""}">${f.text}</span>`).join(`
`); const s = Number(n.statusCode || 500), o = s === 404, r = n.statusMessage ?? (o ? "Page Not Found" : "Internal Server Error"), i = n.message || n.toString(), a = void 0, l = o ? X(() => J(() => import("./BzjYKYyZ.js"), __vite__mapDeps([75, 12, 76]), import.meta.url)) : X(() => J(() => import("./CrPR4iX1.js"), __vite__mapDeps([77, 78]), import.meta.url)); return (f, h) => (Fe(), St(be(l), Ff(jl({ statusCode: be(s), statusMessage: be(r), description: be(i), stack: be(a) })), null, 16))
    }
}, nv = { key: 0 }, kc = { __name: "nuxt-root", setup(e) { const t = () => null, n = we(), s = n.deferHydration(); if (n.isHydrating) { const u = n.hooks.hookOnce("app:error", s); Qe().beforeEach(u) } const o = !1; Sn($o, Cu()), n.hooks.callHookWith(u => u.map(l => l()), "vue:setup"); const r = jo(), i = !1, a = /bot\b|chrome-lighthouse|facebookexternalhit|google\b/i; gl((u, l, f) => { if (n.hooks.callHook("vue:error", u, l, f).catch(h => console.error("[nuxt] Error in `vue:error` hook", h)), a.test(navigator.userAgent)) return n.hooks.callHook("app:error", u), console.error(`[nuxt] Not rendering error page for bot with user agent \`${navigator.userAgent}\`:`, u), !1; if (Au(u) && (u.fatal || u.unhandled)) return n.runWithContext(() => en(u)), !1 }); const c = !1; return (u, l) => (Fe(), St(Ll, { onResolve: be(s) }, { default: ai(() => [be(i) ? (Fe(), ks("div", nv)) : be(r) ? (Fe(), St(be(tv), { key: 1, error: be(r) }, null, 8, ["error"])) : be(c) ? (Fe(), St(be(t), { key: 2, context: be(c) }, null, 8, ["context"])) : be(o) ? (Fe(), St(Kh(be(o)), { key: 3 })) : (Fe(), St(be(ev), { key: 4 }))]), _: 1 }, 8, ["onResolve"])) } }; let xc; { let e; xc = async function () { var i, a; if (e) return e; const n = !!(((i = window.__NUXT__) == null ? void 0 : i.serverRendered) ?? ((a = document.getElementById("__NUXT_DATA__")) == null ? void 0 : a.dataset.ssr) === "true"), s = n ? lu(kc) : Mr(kc), o = Ig({ vueApp: s }); async function r(c) { var u; await o.callHook("app:error", c), (u = o.payload).error || (u.error = rn(c)) } s.config.errorHandler = r, o.hook("app:suspense:resolve", () => { s.config.errorHandler === r && (s.config.errorHandler = void 0) }), !n && Ra.id && o.hook("app:suspense:resolve", () => { var c; (c = document.getElementById(Ra.id)) == null || c.remove() }); try { await Lg(o, Ob) } catch (c) { r(c) } try { await o.hooks.callHook("app:created", s), await o.hooks.callHook("app:beforeMount", s), s.mount(Cg), await o.hooks.callHook("app:mounted", s), await qt() } catch (c) { r(c) } return s }, e = xc().catch(t => { throw console.error("Error while mounting app:", t), t }) } export { Cv as $, Ke as A, ae as B, ht as C, Pv as D, X as E, ke as F, po as G, pn as H, St as I, Av as J, ys as K, J as L, $v as M, rf as N, Gv as O, Sd as P, hn as Q, vs as R, Ce as S, on as T, fs as U, Ng as V, Wv as W, Pm as X, lv as Y, dw as Z, Ef as _, it as a, ad as a$, pl as a0, Kh as a1, Vv as a2, zv as a3, b_ as a4, hw as a5, bv as a6, Ff as a7, jl as a8, Sn as a9, xe as aA, zc as aB, ph as aC, ww as aD, Ew as aE, D_ as aF, kw as aG, js as aH, Ch as aI, al as aJ, iw as aK, Rc as aL, pv as aM, ew as aN, Fh as aO, Xs as aP, Rn as aQ, Ll as aR, uv as aS, fv as aT, bi as aU, dv as aV, ut as aW, _s as aX, Po as aY, rw as aZ, Mr as a_, jd as aa, fw as ab, jv as ac, ui as ad, Lt as ae, mw as af, zp as ag, wi as ah, Qe as ai, Ii as aj, cc as ak, vw as al, hu as am, Kg as an, l_ as ao, dn as ap, bw as aq, yw as ar, Cu as as, Pu as at, E_ as au, yu as av, Fp as aw, Le as ax, Bf as ay, av as az, he as b, aw as b$, Bv as b0, id as b1, lu as b2, Rv as b3, Pd as b4, op as b5, Mv as b6, Lv as b7, Dv as b8, Nv as b9, fl as bA, hl as bB, gl as bC, Bh as bD, Vh as bE, Uh as bF, bh as bG, mv as bH, Gc as bI, gv as bJ, so as bK, Yv as bL, vp as bM, Sv as bN, ow as bO, cs as bP, ea as bQ, nw as bR, Gt as bS, Rt as bT, ld as bU, sw as bV, iv as bW, Iv as bX, qv as bY, cv as bZ, uw as b_, Ov as ba, cw as bb, Hv as bc, tw as bd, rv as be, hv as bf, ci as bg, Dn as bh, Ho as bi, pw as bj, Ev as bk, Tv as bl, xv as bm, kv as bn, Jv as bo, gw as bp, Md as bq, ri as br, nn as bs, Mt as bt, Qv as bu, nt as bv, Yt as bw, lh as bx, Uv as by, Co as bz, ks as c, ip as c0, vv as c1, ud as c2, lw as c3, wv as c4, il as c5, nu as c6, gp as c7, su as c8, pp as c9, Or as ca, Wd as cb, Ld as cc, Zv as cd, fd as ce, Kv as cf, hd as cg, Fv as ch, _v as ci, Xv as cj, yv as ck, Ul as d, et as e, fh as f, we as g, _w as h, Je as i, jh as j, ws as k, ze as l, bt as m, ov as n, Fe as o, Yc as p, qt as q, $e as r, an as s, Vf as t, ju as u, rn as v, ai as w, be as x, Ac as y, vt as z };
